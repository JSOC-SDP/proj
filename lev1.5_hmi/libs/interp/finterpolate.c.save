#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <math.h>
#include <mkl_blas.h>
#include <mkl_service.h>
#include <mkl_lapack.h>
#include <mkl_vml_functions.h>
#include "finterpolate.h"
#define minval(x,y) (((x) < (y)) ? (x) : (y))

void init_finterpolate(
  struct fint_struct *pars,
  int method
)
{
  const int malign=32;
  const int nsubin0=100,nsubin=nsubin0+1,maxorder=32;
  int i,j,k;
  double *kers;
  FILE *fileptr;

  if (method != fint_test) {
    printf("Unimplemented method in init_finterpolate\n");
    abort;
  }
  pars->method=method;
  pars->maxorder=maxorder;
  pars->fover=nsubin0;
  pars->nsub=nsubin0+1;

  kers=(double *)(MKL_malloc(nsubin*maxorder*(maxorder+1)*sizeof(double),malign));
  fileptr = fopen ("/tmp20/schou/coeff3_0-32_100_double.bin", "r");
  fread ((char*)kers,sizeof(double),(maxorder+1)*nsubin*maxorder,fileptr);
  fclose(fileptr);

  pars->kersx=(float *)(MKL_malloc(nsubin*maxorder*(maxorder+1)*sizeof(float),malign));
  for (i=0;i<=maxorder;i++) {
    for (j=0;j<nsubin;j++) {
      for (k=0;k<maxorder;k++) {
        pars->kersx[i*nsubin*maxorder+j*maxorder+k]=kers[i*nsubin*maxorder+j*maxorder+k];
      }
    }
  }
  MKL_free(kers);
}

void free_finterpolate(
  struct fint_struct *pars
)
{
  MKL_free (pars->kersx);
}

void finterpolate(
struct fint_struct *pars,
int order,
float *image_in,
float *xin,
float *yin,
float *image_out,
int nx,
int ny,
int nlead
)

{
  int i,j,i1,j1;
  int order2,lorder;
  float *xker,*yker;
  const int ione = 1;
  int malign=32;
  int leaddiv=4;
  int ixin,iyin,ixin1,iyin1;
  float *ixins,*iyins,*ixin1s,*iyin1s;
  float fxin1,fyin1,fxin2,fyin2;
  float *fxins,*fyins,*xinp,*yinp,*helpf,*fxin1s,*fyin1s;
  float *xk1,*xk2,*yk1,*yk2;
  float *imp;
  float sum,sum1;
  float *kerso;

  ixins=(float *)(MKL_malloc(nx*sizeof(int),malign));
  iyins=(float *)(MKL_malloc(nx*sizeof(int),malign));
  fxins=(float *)(MKL_malloc(nx*sizeof(float),malign));
  fyins=(float *)(MKL_malloc(nx*sizeof(float),malign));
  ixin1s=(float *)(MKL_malloc(nx*sizeof(float),malign));
  iyin1s=(float *)(MKL_malloc(nx*sizeof(float),malign));
  fxin1s=(float *)(MKL_malloc(nx*sizeof(float),malign));
  fyin1s=(float *)(MKL_malloc(nx*sizeof(float),malign));
  helpf=(float *)(MKL_malloc(nx*sizeof(float),malign));

  xker=(float *)(MKL_malloc(order*sizeof(float),malign));
  yker=(float *)(MKL_malloc(order*sizeof(float),malign));

  order2=order/2;
  lorder=leaddiv*((order-1)/leaddiv+1);
  kerso=pars->kersx+order*(pars->maxorder)*(pars->nsub);


// This awful code basically hardcodes the common cases and allows the
// compiler to optimize the code for a significant speed improvement
  switch(order) {
  case 2:
#define OOO1 2
#define OOO2 1
#include "finterpolate.i"
#undef OOO1
#undef OOO2
    break;
  case 4:
#define OOO1 4
#define OOO2 2
#include "finterpolate.i"
#undef OOO1
#undef OOO2
    break;
  case 6:
#define OOO1 6
#define OOO2 3
#include "finterpolate.i"
#undef OOO1
#undef OOO2
    break;
  case 8:
#define OOO1 8
#define OOO2 4
#include "finterpolate.i"
#undef OOO1
#undef OOO2
    break;
  case 10:
#define OOO1 10
#define OOO2 5
#include "finterpolate.i"
#undef OOO1
#undef OOO2
    break;
  case 12:
#define OOO1 12
#define OOO2 6
#include "finterpolate.i"
#undef OOO1
#undef OOO2
    break;
  case 14:
#define OOO1 14
#define OOO2 7
#include "finterpolate.i"
#undef OOO1
#undef OOO2
    break;
  case 16:
#define OOO1 16
#define OOO2 8
#include "finterpolate.i"
#undef OOO1
#undef OOO2
    break;
  case 18:
#define OOO1 18
#define OOO2 9
#include "finterpolate.i"
#undef OOO1
#undef OOO2
    break;
  case 20:
#define OOO1 20
#define OOO2 10
#include "finterpolate.i"
#undef OOO1
#undef OOO2
    break;
  case 22:
#define OOO1 22
#define OOO2 11
#include "finterpolate.i"
#undef OOO1
#undef OOO2
    break;
  case 24:
#define OOO1 24
#define OOO2 12
#include "finterpolate.i"
#undef OOO1
#undef OOO2
    break;
  case 26:
#define OOO1 26
#define OOO2 13
#include "finterpolate.i"
#undef OOO1
#undef OOO2
    break;
  case 28:
#define OOO1 28
#define OOO2 14
#include "finterpolate.i"
#undef OOO1
#undef OOO2
    break;
  case 30:
#define OOO1 30
#define OOO2 15
#include "finterpolate.i"
#undef OOO1
#undef OOO2
    break;
  case 32:
#define OOO1 32
#define OOO2 16
#include "finterpolate.i"
#undef OOO1
#undef OOO2
    break;
// If not hardcoded do general calculation
  default:
#define OOO1 order
#define OOO2 order2
#include "finterpolate.i"
#undef OOO1
#undef OOO2
    break;
  }

  MKL_free(ixins);
  MKL_free(iyins);
  MKL_free(fxins);
  MKL_free(fyins);
  MKL_free(ixin1s);
  MKL_free(iyin1s);
  MKL_free(fxin1s);
  MKL_free(fyin1s);
  MKL_free(helpf);
  MKL_free(xker);
  MKL_free(yker);

  return;
}


