<!DOCTYPE HTML>
<html>
<head>
<meta HTTP-EQUIV="Content-Type" content="text/html; charset=iso-8859-1">
<title>JSOC Export Data</title>

<script type="text/javascript" src="/tp/js/prototype.js"></script>
<script type="text/javascript" src="/tp/js/prototip.js"></script>
<link rel="stylesheet" type="text/css" href="/tp/css/prototip.css">

<style type='text/css'>
.data-cell {
  text-align:left;
  background-color:#FFF8DC;
  border-width:2px;
  border-color:#EBE9ED;
  border-style:inset;
}

body {
    font:16px Tahoma;
}

</style>

<script type="text/javascript">
function private_host_callback()
{
    var is_private = null;

    is_private = $('PrivateHostElement').innerHTML.length > 0;
    $('PrivateHostElement').store({ "is_private" : is_private });
}

function create_include_html_on_success(target_element)
{
    var on_success_fn = function(response)
    {
        var html_text = response.responseText;

        if (target_element !== null)
        {
            target_element.innerHTML = html_text;
        }
    };

    return on_success_fn;
}

function create_include_html_on_complete(callback_name)
{
    var on_complete_fn = function(response)
    {
        var callback = null;

        if (callback_name !== null)
        {
            callback = window[callback_name];
        }

        if (callback !== null)
        {
            callback();
        }
    };

    return on_complete_fn;
}

function include_html()
{
    var div_list = null;
    var div_index = null;
    var include_element = null;
    var file_resource = null;
    var target_element = null;
    var options = null;
    var resource = null;
    var get_callback = null;

    div_list = $$(".include-html");
    for (div_index = 0; div_index < div_list.length; div_index++)
    {
        include_element = div_list[div_index];
        file_resource = include_element.readAttribute('file-resource');
        target_element = $(include_element.readAttribute('target-element'));
        callback_name = include_element.readAttribute('callback');

        options =
        {
            method: "get",
            parameters: {},
            onSuccess: create_include_html_on_success(target_element),
            onFailure: function(response)
            {
                target_element.innerHTML = '';
            },
            on404: function(response)
            {
                target_element.innerHTML = '';
            },
            onComplete: create_include_html_on_complete(callback_name)
        };

        resource = "/_includes/" + file_resource;
        // resource = window.location.origin + "/" + file_resource;

        new Ajax.Request(resource, options);
    }
}
</script>

<script type="text/javascript">
function stringify_obj(obj)
{
    var keys = null;
    var values = null;
    var index = null;
    var attribute = null;
    var value = null;
    var response = null;

    if (obj === null && obj === undefined)
    {
        response = 'null';
    }
    else if (typeof(obj) === 'number' || typeof(obj) === 'string' || typeof(obj) === 'boolean')
    {
        response = obj.toString();
    }
    else if (Array.isArray(obj))
    {
        values = new Array();

        for (index = 0; index < obj.length; index++)
        {
            value = obj[index];
            values.push(stringify_obj(value));
        }

        response = '[ ' + values.join(',') + ' ]';
    }
    else
    {
        keys = Object.keys(obj);
        values = new Array();
        index = null;
        attribute = null;
        value = null;

        for (index = 0; index < keys.length; index++)
        {
            attribute = keys[index];
            value = obj[attribute];
            values.push('"' + attribute + '": ' + stringify_obj(value));
        }

        response = '{ ' + values.join(',') + ' }';
    }

    return response;
}

function stringify_obj_old(obj)
{
    var keys = Object.keys(obj);
    var values = new Array();
    var index = null;
    var attribute = null;
    var value = null;

    for (index = 0; index < keys.length; index++)
    {
        attribute = keys[index];
        value = obj[attribute];

        if (value !== null && value !== undefined)
        {
            if (typeof(value) === 'number' || typeof(value) === 'string' || typeof(value) === 'boolean' || Array.isArray(value))
            {
                values.push('"' + attribute + '": ' + JSON.stringify(value));
            }
            else
            {
                values.push('"' + attribute + '": ' + stringify_obj(value));
            }
        }
        else
        {
            values.push('"' + attribute + '": null');
        }
    }

    return '{' + values.join(',') + '}';
}
</script>

<script type="text/javascript">

// Set CGI-BIN and include targets

// Eventually this should be put into a common file loaded by all the html web pages. To do that
// we need to copy code from exportdata.html to here that sets the base directory that is used
// when loading files with the <script> tag. Then we need to put the common file in that
// base directory, and we need to read it here. But for now, just hard-code this needed map.
var INTERNAL_SERVER = 'hmidb';
var EXTERNAL_SERVER = 'hmidb2';
var INTERNAL_WEBSERVER = 'solarwebx';
var INTERNAL_WEBSERVER_PORT = '8080';
var EXTERNAL_WEBSERVER = 'solarweb2';
var EXTERNAL_WEBSERVER_PORT = '8080';
var STANFORD_DOMAIN = 'stanford.edu';

// EB states
var EB_STATE_DISABLED = 'disabled';
var EB_STATE_ENABLED = 'enabled';
var EB_STATE_SUBMIT_ENABLED = 'submit_enabled';
var EB_STATE_SUBMIT = 'submit';
var EB_STATE_CANCEL_ENABLED = 'cancel_enabled';
var EB_STATE_PATH = 'path';
var EB_STATE_CANCEL = 'cancel';
var EB_STATE_CANCELED = 'canceled';
var EB_STATE_TIMEOUT = 'timeout';

var KEYWORD_CTYPE1 = 'CTYPE1';
var KEYWORD_CTYPE2 = 'CTYPE2';
var KEYWORD_LVL_NUM = 'LVL_NUM';
var AIA_SCALE_CTYPE1 = 'HPLN-TAN';
var AIA_SCALE_CTYPE2 = 'HPLT-TAN';
var KEYWORD_SPEC = '*spec*';
var KEYWORD_ONLINE = '*online*';
var KEYWORD_SIZE = '*size*';
var KEYWORD_RECNUM = '*recnum*';
var AIA_NAMESPACE = 'aia';
var NA = 'na';
var AIA_SCALE_NAXES = 2;
var AIA_LEV1P5 = 'aia.lev1p5';

// export types
var EXP_METH_FULL = 'url';
var EXP_METH_QUICK = 'url_quick';
var EXP_METH_STREAMED = 'url_direct';
var EXP_METH_FULL_FTP = 'ftp';
var EXP_METH_FULL_TAR = 'url-tar';
var EXP_METH_FULL_FTP_TAR = 'ftp-tar';

// protocol types
var PROTOCOL_JPEG = 'jpeg';
var PROTOCOL_MPEG = 'mpeg';
var PROTOCOL_MP4 = 'mp4';

var serverMap = new Array();
serverMap[EXTERNAL_WEBSERVER] = EXTERNAL_SERVER;
serverMap[EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN] = EXTERNAL_SERVER;
serverMap[INTERNAL_WEBSERVER] = INTERNAL_SERVER;
serverMap[INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN] = INTERNAL_SERVER;

var EXPORT_PATH = '/export';
var PENDING_REQUEST_RESOURCE = 'pending-request';
var PENDING_REQUEST_PATH = [ EXPORT_PATH, PENDING_REQUEST_RESOURCE ].join('/')
var RECORD_SET_RESOURCE = 'record-set';
var RECORD_SET_PATH = [ EXPORT_PATH, RECORD_SET_RESOURCE ].join('/');
var SERIES_RESOURCE = 'series';
var SERIES_PATH = [ EXPORT_PATH, SERIES_RESOURCE ].join('/');
var PREMIUM_EXPORT_REQUEST_RESOURCE = 'new-premium-request';
var PREMIUM_EXPORT_REQUEST_PATH = [ EXPORT_PATH, PREMIUM_EXPORT_REQUEST_RESOURCE ].join('/');
var PREMIUM_EXPORT_REQUEST_FROM_FORM_RESOURCE = 'new-premium-request-from-form';
var PREMIUM_EXPORT_REQUEST_FROM_FORM_PATH = [ EXPORT_PATH, PREMIUM_EXPORT_REQUEST_FROM_FORM_RESOURCE ].join('/');
var MINI_EXPORT_REQUEST_RESOURCE = 'new-mini-request';
var MINI_EXPORT_REQUEST_PATH = [ EXPORT_PATH, MINI_EXPORT_REQUEST_RESOURCE ].join('/');
var MINI_EXPORT_REQUEST_FROM_FORM_RESOURCE = 'new-mini-request-from-form';
var MINI_EXPORT_REQUEST_FROM_FORM_PATH = [ EXPORT_PATH, MINI_EXPORT_REQUEST_FROM_FORM_RESOURCE ].join('/');
var STREAMED_EXPORT_REQUEST_RESOURCE = 'new-streamed-request';
var STREAMED_EXPORT_REQUEST_PATH = [ EXPORT_PATH, STREAMED_EXPORT_REQUEST_RESOURCE ].join('/');
var STREAMED_EXPORT_REQUEST_FROM_FORM_RESOURCE = 'new-streamed-request-from-form';
var STREAMED_EXPORT_REQUEST_FROM_FORM_PATH = [ EXPORT_PATH, STREAMED_EXPORT_REQUEST_FROM_FORM_RESOURCE ].join('/');
var RE_EXPORT_REQUEST_RESOURCE = '?';
var RE_EXPORT_REQUEST_PATH = [ EXPORT_PATH, RE_EXPORT_REQUEST_RESOURCE ].join('/');
var PENDING_REQUEST_STATUS_RESOURCE = 'pending-request-status';
var PENDING_REQUEST_STATUS_PATH = [ EXPORT_PATH, PENDING_REQUEST_STATUS_RESOURCE ].join('/');

var DRMS_EXPORT = 'drms-export.sh';
var LOOKDATA = "lookdata";

// manage-request operations
var MR_OPERATION_CHECK = 'check';
var MR_OPERATION_CANCEL = 'cancel';

// manage-requests status codes
var MR_STATUS_UNKNOWN = 0;
var MR_STATUS_NOT_PENDING = 'StatusCode.NOT_PENDING';
var MR_STATUS_PENDING = 'StatusCode.PENDING';
var MR_STATUS_REQUEST_CANCELED = 'StatusCode.REQUEST_CANCELED';

var HTML_REQUESTID_DESC = 'Enter this ID in RequestID (below) to obtain export status';

var HELP_LOCAL_NAME = 'jsoc_help';
</script>

<!-- Add functions for export processing (no more protocols js)  -->
<script type="text/javascript" src="/assets/js/processing.elements.js"></script>

<!-- Add list of seriesnames for which processing on export is not suportted -->
<script type="text/javascript" src="/assets/js/processing.exclusions.js"></script>

<!-- Add export email checking code. -->
<script type="text/javascript" src="/assets/js/user.registration.js"></script>

<style type="text/css">

#body { margin:0; padding:0; }
#header { position:relative; top:0; left:0; width:100%; background:#eee; }
#footer { position:fixed; bottom:0; left:0; width:100%; background:#eee; }
#ExportRecordSet { width:40em; font-size:100%; }
span.tip { background-color:blue;font-family:verdana;color:white;font-size:1em;font-weight:bold;}
.prototip { font:0.8em Arial, Helvetica, sans-serif; }
</style>

<script type="text/javascript">

// Protect page from accidental BACK button
var ON_BEFORE_UNLOAD_FXN = function()
{
    if ($('FileUploadFormID').retrieve('beforeunloadOverride', false))
    {
        $('FileUploadFormID').store({ 'beforeunloadOverride' : false })
        window.onbeforeunload = null;
    }

    if ($('FileUploadFormID').retrieve('beforeunloadEnabled', false))
    {
        // this message will never display - all browsers disallow this now;
        // return "Did you really mean to leave exportdata? Use CANCEL to stay here";
        window.onbeforeunload = function() { return 'this does not matter - never gets executed'; };
    }
};

var UPDATE_HTTP_REQUEST_COUNT = function()
{
    $("AjaxBusy").innerHTML = Ajax.activeRequestCount;

    if (Ajax.activeRequestCount == 0)
    {
        $("AjaxBusy").style.color = colorDarkGreen;
    }
    else
    {
        $("AjaxBusy").style.color = colorDarkRed;
    }
}

var MANAGE_REQUEST_ON_SUCCESS_INTERVAL = function(op, callback_fn)
{
    var success_fn = function(response)
    {
        var mr_response_obj = response.responseJSON;

        if (mr_response_obj !== null)
        {
            var status = mr_response_obj.drms_export_status;
            var state = $("ExportButton").retrieve('state', EB_STATE_DISABLED);
            var interval_fn_timer = $("ExportButton").retrieve('interval', null);
            var clear_interval_fn_timer = false;
            var interval_fn_timeout = $("ExportButton").retrieve('interval_timeout', null);
            var error = false;

            if (status.search(/errorcode/i) == 0)
            {
                // error calling MR - do nothing (don't change state)
                $("ExportButtonMsg").innerHTML = mr_response_obj.error_message;
                error = true;
            }
            else if (state == EB_STATE_TIMEOUT)
            {
                // do not do anything; set_eb_state_disabled() will take care of stopping the interval function
            }
            else if (op == MR_OPERATION_CHECK)
            {
                // action depends on state and status
                if (status == MR_STATUS_NOT_PENDING)
                {
                    if (state == EB_STATE_ENABLED)
                    {
                        state = EB_STATE_SUBMIT_ENABLED;
                    }
                    else if (state == EB_STATE_SUBMIT_ENABLED)
                    {
                        // no change
                        state = EB_STATE_SUBMIT_ENABLED;
                    }
                    else if (state == EB_STATE_SUBMIT)
                    {
                        state = EB_STATE_SUBMIT;
                    }
                    else if (state == EB_STATE_CANCEL_ENABLED)
                    {
                        state = EB_STATE_PATH;

                        // force update-request-ui to update request UI
                        $('ExportButton').store({ "ajax-state" : "post-click" });
                        GetStatus();
                    }
                    else if (state == EB_STATE_PATH)
                    {
                        // do nothing
                        state = EB_STATE_PATH;

                        // stop interval function
                        clear_interval_fn_timer = true;
                    }
                    else if (state == EB_STATE_CANCEL)
                    {
                        // stop interval function
                        clear_interval_fn_timer = true;

                        // successful cancelation (or failure to cancel, followed by natural completion);
                        // back to the original pre-check-for-parameters state
                        state = EB_STATE_CANCELED;
                    }
                    else
                    {
                        // error
                        $("ExportButtonMsg").innerHTML = 'bad export button state[1] ' + state;
                        error = true
                    }
                }
                else if (status == MR_STATUS_PENDING)
                {
                    if (state == EB_STATE_ENABLED)
                    {
                        // cancel short-cut taken
                        state = EB_STATE_CANCEL_ENABLED;
                        $('ExportButton').store({ "ajax-state" : "pre-click" });

                        if (interval_fn_timer === null)
                        {
                            // start-up interval
                            internal_fn = CHECK_FOR_PENDING_REQUEST(true);
                            interval_fn_timer = setInterval(internal_fn, 1000);
                            $("ExportButton").store('interval', interval_fn_timer);
                        }

                        // do not allow the pending-request check to last forever (EB is in EB_STATE_CANCEL_ENABLED); 86400000 ==> 1 day
                        // reset the timeout if it is already set
                        if (interval_fn_timeout !== null)
                        {
                            clearTimeout(interval_fn_timeout);
                        }

                        interval_fn_timeout = setTimeout(function () { $("ExportButton").store('state', EB_STATE_TIMEOUT); set_eb_state_disabled(true);}, 86400000);
                        $("ExportButton").store('interval_timeout', interval_fn_timeout);
                    }
                    else if (state == EB_STATE_SUBMIT_ENABLED)
                    {
                        // error - can't happen
                        $("ExportButtonMsg").innerHTML = 'bad export button state[2] ' + state;
                        error = true
                    }
                    else if (state == EB_STATE_SUBMIT)
                    {
                        state = EB_STATE_SUBMIT;
                    }
                    else if (state == EB_STATE_CANCEL_ENABLED)
                    {
                        // no change
                        state = EB_STATE_CANCEL_ENABLED;
                    }
                    else if (state == EB_STATE_PATH)
                    {
                        // error - can't happen
                        $("ExportButtonMsg").innerHTML = 'bad export button state[3] ' + state;
                        error = true
                    }
                    else if (state == EB_STATE_CANCEL)
                    {
                        // do nothing - wait for cancelation (or natural completion) to occur
                        state = EB_STATE_CANCEL;
                    }
                    else
                    {
                        // error
                        $("ExportButtonMsg").innerHTML = 'bad export button state[4] ' + state;
                        error = true
                    }
                }
                else
                {
                    // error
                    $("ExportButtonMsg").innerHTML = 'unexpected manage-request status ' + status;
                    error = true;
                }
            }
            else if (op == MR_OPERATION_CANCEL)
            {
                if (state != EB_STATE_CANCEL_ENABLED)
                {
                    $("ExportButtonMsg").innerHTML = 'bad export button state[5] ' + state;
                    error = true;
                }
                else if (status == MR_STATUS_REQUEST_CANCELED)
                {
                    $("ExportButtonMsg").innerHTML = 'unexpected manage-request status ' + status;
                    error = true;
                }
            }
            else
            {
                // bad operation
                $("ExportButtonMsg").innerHTML = 'bad manage-request operation ' + op;
                error = true;
            }

            if (error)
            {
                // stop interval function
                clear_interval_fn_timer = true;

                state = EB_STATE_DISABLED;
            }

            if (state == EB_STATE_DISABLED)
            {
                // either state WAS EB_STATE_CANCEL, or error; call special function to initialize states
                // back to the beginning
                set_eb_state_disabled(false);
            }
            else
            {
                if (interval_fn_timer !== null && clear_interval_fn_timer)
                {
                    clearInterval(interval_fn_timer);
                    $("ExportButton").store('interval', null);

                    if (interval_fn_timeout !== null)
                    {
                        clearTimeout(interval_fn_timeout);
                        $("ExportButton").store('interval_timeout', null);
                    }
                }

                $("ExportButton").store('state', state);
                update_export_buttons();
            }
        }

        if (callback_fn)
        {
            callback_fn();
        }
    }

    return success_fn;
}

// handles only a subset of all EB states since on-demand checks are used only in
// certain circumstances
var MANAGE_REQUEST_ON_SUCCESS_ON_DEMAND = function(callback_fn)
{
    var success_fn = function(response)
    {
        var mr_response_obj = response.responseJSON;

        if (mr_response_obj !== null)
        {
            var status = mr_response_obj.drms_export_status;
            var state = $("ExportButton").retrieve('state', EB_STATE_DISABLED);
            var error = false;

            if (status.search(/errorcode/i) == 0)
            {
                // error calling MR - do nothing (don't change state)
                $("ExportButtonMsg").innerHTML = mr_response_obj.error_message;
                error = true;
            }
            else if (state != EB_STATE_ENABLED && state != EB_STATE_DISABLED)
            {
                // for enabled, disabled state only
                $("ExportButtonMsg").innerHTML = 'unexpected export-button state ' + state.toString();
                error = true;
            }
            else
            {
                // action depends on status
                if (status == MR_STATUS_NOT_PENDING)
                {
                    if (state == EB_STATE_ENABLED)
                    {
                        state = EB_STATE_SUBMIT_ENABLED;
                        $('ExportButton').store({ "ajax-state" : "pre-click" });
                    }
                }
                else if (status == MR_STATUS_PENDING)
                {
                    if (state == EB_STATE_ENABLED)
                    {
                        state = EB_STATE_CANCEL_ENABLED;
                        $('ExportButton').store({ "ajax-state" : "pre-click" });
                    }
                    else if (state == EB_STATE_DISABLED)
                    {
                        // set the EB state to EB_STATE_CANCEL_ENABLED (the user has a pending export request)
                        state = EB_STATE_CANCEL_ENABLED;
                        $('ExportButton').store({ "ajax-state" : "pre-click" });
                    }
                    else
                    {
                        $("ExportButtonMsg").innerHTML = 'bad export button state ' + state;
                        error = true
                    }
                }
                else
                {
                    // unexpected status
                    $("ExportButtonMsg").innerHTML = 'unexpected manage-request status ' + status;
                    error = true;
                }
            }

            $("ExportButton").store('state', state)
            update_export_buttons();
        }

        if (callback_fn)
        {
            callback_fn();
        }
    }

    return success_fn;
}

var MANAGE_REQUEST_XHR = function(address, op, interval, callback_fn)
{
    // we have to deal with the db-server pass-through stuff
    var export_app_arguments = null;
    var options = null;
    var db_host = null;
    var on_success = null;
    var method = null;

    if ($('PrivateHostElement').retrieve('is_private', false))
    {
        db_host = INTERNAL_SERVER;
    }
    else
    {
        db_host = EXTERNAL_SERVER;
    }

    export_app_arguments = { "address" : address, "db-host" : db_host };

    if (interval === null || interval === undefined)
    {
        // do nothing on success; the caller does not want to check on results
        on_success = function()
        {
            if (callback_fn)
            {
                callback_fn();
            }
        };
    }
    else if (interval)
    {
        on_success = MANAGE_REQUEST_ON_SUCCESS_INTERVAL(op, callback_fn);
    }
    else
    {
        on_success = MANAGE_REQUEST_ON_SUCCESS_ON_DEMAND(callback_fn);
    }


    method = (op === MR_OPERATION_CHECK) ? 'get' : 'post';
    options =
    {
        method: method,
        onSuccess: on_success,
        onFailure: function(response)
        {
            var mr_response_obj = response.responseJSON;
            var error_msg = mr_response_obj.error_message;

            // true ==> do not allow the user to change email address (must reload to do that)
            set_eb_state_disabled(true);

            if (callback_fn !== null && callback_fn !== undefined)
            {
                callback_fn();
            }
        },
        on428: function(response)
        {
            var mr_response_obj = response.responseJSON;
            var error_msg = mr_response_obj.error_message;

            // true ==> do not allow the user to change email address (must reload to do that)
            set_eb_state_disabled(true);

            if (callback_fn !== null && callback_fn !== undefined)
            {
                callback_fn();
            }
        }
    };

    if (method === 'post')
    {
        options['postBody'] = JSON.stringify(export_app_arguments);
        options['contentType'] = 'application/json';
    }
    else
    {
        options['parameters'] = export_app_arguments;
    }
    new Ajax.Request(window.location.origin + PENDING_REQUEST_PATH, options);
}

// export button (EB) states:
// 1. DISABLED - the Check Params for Export button (CPE) has not yet been clicked; interval function (XHR) not running OR
//               failure of any kind anywhere in state graph OR CANCEL + IF "not pending"
// 2. ENABLED - CPE clicked, parameters ready, interval function (IF) running
// 3. SUBMIT_ENABLED - ENABLED + IF "not pending"
// 4. CANCEL_ENABLED - ENABLED + IF "pending"
// 5. CANCEL - SUBMIT_ENABLED + EB clicked
// 6. PATH - CANCEL_ENABLED + IF "not pending"
//
// EB labels
// 1. "not ready" - for DISABLED OR ENABLED
// 2. "submit" - for SUBMIT_ENABLED
// 3. "cancel" - for CANCEL_ENABLED
// 4. "wait" - for CANCEL
// 5. "get path" - for PATH
var CHECK_FOR_PENDING_REQUEST = function(interval)
{
    // the user has already clicked on the Check Params for Export button; the 'submit' button is currently disabled
    var manage_export_fn = function(callback_fn)
    {
        var address = $("ExportNotify").value;
        var op = MR_OPERATION_CHECK;
        var xhr = MANAGE_REQUEST_XHR;

        xhr(address, op, interval, callback_fn);
     }

     return manage_export_fn;
}

// states (the button label); destination states at arrow head
//   disabled: check params not clicked yet
//      not called
//   submit:
//      not called
//   cancel:
//      --> disabled
//   path:
//      not called
var CANCEL_PENDING_REQUEST = function(interval)
{
    var manage_export_fn = function(callback_fn)
    {
        var address = $("ExportNotify").value;
        var op = MR_OPERATION_CANCEL;
        var xhr = MANAGE_REQUEST_XHR;

        xhr(address, op, interval, callback_fn);
     }

     return manage_export_fn;
}

function OnEnterKey(evt,action)
  {
  var keynum;
  var keychar;
  if(window.event) // IE
    keynum = evt.keyCode;
  else if(evt.which) // Netscape/Firefox/Opera
    keynum = evt.which;
  if(keynum == 13)
    action();
  keychar = String.fromCharCode(keynum);
  return keychar;
  }

var previousSeries = "";
function NotifyProcessingCode(callback)
{
    // called when RecordSet is changed, after series info and record info have been downloaded and assimilated.
    // Set flags to alert processing or method options here.
    // variables here will usually be defined in exportdata.d/processing.js
    // or exportdata.d/export_request_form.html

    // series is determined asynchronously.
    var series = $('ExportRecordSet').retrieve('series', null);
    var previous_series = $('ExportRecordSet').retrieve('previous_series', null);

    if (series !== null)
    {
        if (series === previous_series)
        {
            SetProcessing(-1, callback); // Do not initialize all processing options to their defaults.
        }
        else
        {
            SetProcessing(-2, callback); // Init all processing options to their defaults.
        }

        $('ExportRecordSet').store({ "previous_series" : series })
    }
}

// Global vars
var Host = location.host;
var SeriesInfo;
var ExportProcessingOptions;
var TipsEnabled;
var TipsCreated = 0;
var args;
var state=0;

// Export processing globals.
var ExportProcessingArgsPoll = null;
var ExportProcessingOK = null;

// Protocol global vars
var ExportCompressValue = "";
var ProtocolOptionsSet = 0;

// Misc vars
var firstTimePrime;
var expURL;

// Colors
var colorNeutral = "#D4D0C8";
var colorPreset = "#D8D8D8";
var colorOptionSet = "#FFCC66";
var colorPink = "#FFD8D8";
var colorDarkPink = "#FFB0B0";
var colorRed = "#D88080";
var colorDarkRed = "#C00000";
var colorRealRed = "#FF0000";
var colorDarkishRed = "#FF8080";
var colorBrightOrange = '#F9441F';
var colorDarkBlue = "#0000B0";
var colorWhite = "#FFFFFF";
var colorBlack = "#000000";
var colorGreen = "#80FF80";
var colorDarkGreen = "#009000";
var colorYellow = "#FFF8DC";


// tester success

function initVars()
{
    Host = location.host;

    $('RequestIdPlace').innerHTML = '';
    $('ExportRecordSet').store({ "count" : null, "series" : null, "valid" : null });
    update_record_set_ui(true);
    $('ExportRecordLimit').value = 'none';
    $('ExportRecordLimit').store({ "limit" : null })
  TipsEnabled = 1;
  firstTimePrime = "";

    // initialize processing
    ProcessingInit();
    update_processing_ui(true);
    ExportProcessingOK = null;
    ExportProcessingArgsPoll = null;

  // Init protocols
  ProtocolOptionsSet = 0;


    update_protocol_ui(true);

    // Enable the reset button, now that the page has completed loaded.
    $("ResetPageButton").disabled = false;


  // if (state < 2)
  // Form init
    {
    $('StatusButton').store({ "ajax-state" : "pre-click" })
    $("ExportRequestor").value = "";
    $("ExportStatus").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $('ExportRecordSet').value = "";
    $("ExportCheckMsg").innerHTML = "";
    $("ExportCheckMsg").style.color = colorRealRed;
    // Processing
    $("ProcessRow").style.display="none";
    // Protocols
    $("ProtocolRow").style.display="none";
    $("ExportCompress").selectedIndex = 0;
    $("CompressRow").style.display="none";
    $("ProtocolImageOptions").style.display="none";

    $('ExportMethod').selectedIndex = 2;
    $('ExportFilenameFmt').value = "{seriesname}.{recnum:%lld}.{segment}";
    $('ExportFilenameFmt').store({ 'valid' : true });
    $("ExportButton").value = "Submit Export Request";
    $("ExportButtonMsg").innerHTML = "Please only click once for export request.";
    $("ExportButton").style.backgroundColor = colorRed;
    $("ExportButton").disabled = true;
    $("RecordSetRow").style.display="table-row";
    $("RecordCountRow").style.display="table-row";
    $("FilenameFmtRow").style.display="none";
    $('RequestorRow').style.display = 'table-row';
    $('NotifyRow').style.display = 'table-row';
    $('FileUploadCheckbox').checked = 0;
    $("ExportOpID").value = "exp_request";
    $("ReRequestID").value = "";
    $("ReExportDiv").style.display = "none";
    $("TarFileLocationRow").style.display = "none";
    $("KeywordFileLocationRow").style.display = "none";
    $("ShowQueryCheckbox").checked = 0;

    update_export_method_ui(true);
    }

    // removes all registration statuses
    email_initVars($("ExportNotify"), $("ExportRequestor"));

    set_eb_state_disabled(false);

    $('ExportButton').store({ "reset" : true });
    update_request_section_ui(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, false);

    $('StatusButton').store({ "reset" : true });
    update_status_section_ui(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);

    $('ExportButton').store({ "ajax-state" : "pre-click" });
    $('StatusButton').store({ "ajax-state" : "pre-click" });

    file_upload_on_init();
}

// tester success

function getargs()
{
    var exportargs = location.search;
    var args = null;

    exportargs = decodeURIComponent(exportargs);
    exportargs = exportargs.substr(1);
    exportargs = exportargs.replace(/\?/g,"QUESTIONMARK");
    args = exportargs.toQueryParams();

    if (args.ds === undefined)
    {
        args.ds = "";
    }

    args.ds = args.ds.replace(/QUESTIONMARK/g, '?');
    args.id = localStorage.getItem('request-id');

    email_getargs($('ExportNotify'), $('ExportRequestor'));

    return args;
}

function on_load_init_callback()
{
    // fix ImageSize options
    for (index = 0; index < $('ImageSize').options.length; index += 1)
    {
        $('ImageSize').options[index].value = $('ImageSize').options[index].value.trim().substr(4);
    }

    initVars(); // This call runs code that requires RecordSet to be set. However, that is not true
              // before it is set below [ $('ExportRecordSet').value = args.ds ]

    $('HeaderLink').href = window.location.origin;
    $('FooterLink').href = window.location.origin;

    args = getargs();

    if (args.ds)
    {
        $('ExportRecordSet').value = args.ds;
    }

    if (args.id !== null && args.id.length > 0)
    {
        $('RequestIdPlace').innerHTML = args.id;
        $('StatusRequestID').value = args.id;
    }

    if (args.limit)
    {
        $('ExportRecordLimit').value = args.limit;
        update_record_limit_ui(false);
    }

    if ($('ExportRecordSet').value.trim().length > 0)
    {
        update_record_set_ui(true);
    }

    CreateTips();
    $("TipsOnOffButton").value = "Turn Help Off";
    $('RSCountPlace').up().setStyle({ 'max-width': '22em', 'overflow-wrap': 'break-word', 'word-wrap': 'break-word', 'word-break': 'break-all' });

    // make a handler for the form-changed event; if the form changes, we want to set a flag that enables the beforeunload handler;
    // initially disable the beforeunload handler
    $('FileUploadFormID').observe('change', function(event) { $('FileUploadFormID').store({ 'beforeunloadEnabled': true }); });
    $('FileUploadFormID').store({ 'beforeunloadEnabled': false });

    // protect from back button
    setInterval(ON_BEFORE_UNLOAD_FXN, 500);

    // start periodic function to update active HTTP requests counter
    setInterval(UPDATE_HTTP_REQUEST_COUNT, 500);

    check_for_cancel_enabled_shortcut(function() { set_eb_state_disabled(false); enable_input(true); });

    window.focus();
}

function OnLoadInit()
{
    include_html();
}

function ReInitPage()
{
    OnLoadInit();
}

// tester success

function MainTips(tipstyle)
  {
    var wiki_page = null;

    if (TipsCreated == 0)
    {
        wiki_page = window.location.origin + '/jsocwiki/AllAboutJsocNames';

    new Tip('RecordFromFileHelp','Allows user to provide a RecordSet list in a file.  ' +
        'The file should contain recordSet specifiers in the format allowed by drms_open_records include files.  ' +
        'See ' + wiki_page + '.',tipstyle);
    new Tip('RecordSetHelp','RecordSet to be exported. May be imported on call and/or may be entered directly here. ' +
        'May be filled in by series select in Im_patch processing option.',tipstyle);
    new Tip('CallLookdataHelp','Start lookdata.html in a different tab/window with RecordSet given.  ' +
        'If a JSOC Lookdata window already exists, the first one will be replaced by this call.',tipstyle);
    new Tip('RecordLimitHelp','RecordSet record limit. Max number of records to export.  Modifies RecordSet. ' +
        'Value should be "none" or a number. Number > 0 counts from start of RecordSet.  Negative number counts ' +
        'from high end of RecordSet.  0 means no limit',tipstyle);
    new Tip('RecordCountHelp','RecordSet record count.  Update this to repeat export with new method, email, etc.  ' +
        'There is presently a limit to the memory space allocated for record queries which restricts AIA lev1 ' +
        'requests to about 15,000 records and HMI X_45s or X_720s data to about 32,000 records.  ' +
        'The limit depends on number of keywords in each record.  This limit will be eased in the future.',tipstyle);
    new Tip('MethodHelp','Handshake method to be used in the process of doing the export and to fetch the data files. ' +
        '"url-quick" is the fastest but can only be used if the data is online and will be exported "as-is". ' +
        '"url-direct" is has the constraints of url_quick with the limit of one file per request but it will ' +
        'automatically do the postprocessing specified in the "protocol" instruction. For "url_direct" the file ' +
        'is returned directly to your browser rather than returning to the export page.  If you have the ' +
        'set to load some fits reader program when the mime-ype "fits" is encountered you will see the image promptly. ' +
        '"url" will result in a temporary directory being created and the URL to that directory be returned to you after ' +
        'a handshake process using the RequestID provided. ' +
        '"ftp" is like "url" but the returned links will be to an ftp directory. ' +
        ' A "-tar" suffix will cause a tar of all files in the request to be included with the separate files. ' +
        'NOTE: do not use "-tar" unless you really need it since that will generate an extra copy of the data.',tipstyle);
    new Tip('FilenameFmtHelp','Filename format to be used in the process of doing the export.  ' +
        'The filename format is a template used to construct a filename for each segment of each record requested.  ' +
        'The template consists of literal characters and substitution tokens enclosed in "{}".  ' +
        'The special words: seriesname, recnum, and segment are replaced with the series_name, the record number, ' +
        'or the segment name.  The element {#} will generate an increasing number, ' +
        'with optional layout e.g. default is {#:%05d}. ' +
        'Any keyword in the record may also be used.  Optional layout may be provided after a ":".' +
        'Special format options are available for type TIME keywords: A leading "A" will strip "." and ":" from the time and ' +
        'a "D" will strip the "." and ":" but will insert "@" around the date components to allow easy scripts ' +
        'to move the exported files into date structured directory trees. ' +
        'It is wise to include enough of the "prime-keys" to make a unique filename.  ' +
        'The default format template is made from series structure.',tipstyle);
    new Tip('ProcessingHelp','Processing to be done to the data prior to export. ' +
        ' Select from drop-down list for details.',tipstyle);
    new Tip('ProtocolHelp','Data storage protocol for data files to be fetched.  ' +
        '<br>"Fits" causes the data to be converted to full fits files with header information filled from the DRMS records.  ' +
        '<br>"As-is" leaves the data as it is used inside the JSOC DRMS system, ' +
        'with the header metadata stored in the database rather than with the data file.  ' +
        '"As-is" is faster since the data does not need to be rewritten.  In as-is mode the header data is ' +
        'provided in a tab-delimited file named {RequestID}.keywords.txt. <br> The "jpeg" option will ' +
        ' yield  jpeg images of the data and the <br>"mpg" or "mp4" options will ' +
        ' yield a movie along with the jpeg images that make up the frames in the movie.<br> ' +
        'Default colortables and scaling for protocols making images are provided but may be altered.',tipstyle);
    new Tip('CompressHelp','Compression parameters to be used by the cfitsio library.  ' +
        'One comma separated string for each segment name in your export will be generated. ' +
        'Use "**NONE**" to indicate uncompressed FITS files desired. ' +
        'Note that e.g. AIA data can be more than 5 times larger if not compressed.  Do not request uncompressed ' +
        'exports for more than a few files.',tipstyle);
    new Tip('RequestorHelp','Optional place for your name, this will be used later when we have a way of saving your ' +
        'preferred export options.  This value will be saved in a local storage if allowed.',tipstyle);
    new Tip('NotifyHelp','Email address to be used to notify you when the export is complete and ready to be ' +
        'fetched using the RequestID. NOTE - an email address is required for exports from jsoc2.',tipstyle);
    new Tip('SendFileHelp','This action will submit the export request with the RecordSet specified in the upload file.',tipstyle);
    new Tip('CheckParamHelp','This button is required to verify all fields used to specify the export request ' +
        'have been filled in in a consistent way.  If all is OK, the Submit button will be enabled.  A new Check ' +
        'button press is required before each export request.',tipstyle);
    new Tip('SubmitHelp','This button does the actual export request submission.  After a submit request the button ' +
        'action is changed to a Status Request which can be used to get the response from JSOC.  For all but url-direct and ' +
        'url-quick methods a RequestID tag will be returned a few seconds after a submit request.  ' +
        'This tag will be used to identify ' +
        'your export request inside JSOC and may be used at a later time to request the processing status and to ' +
        'obtain a link to your data.',tipstyle);
    new Tip('FetchCheckboxHelp','When this box is checked, the URL string that will be sent to the JSOC jsoc_fetch ' +
        'command will be shown when the "Check Params for Export" button is pressed.  This string can be used to ' +
        'help you develop script driven exports and to see how exportdata functions.',tipstyle);
    }
  };

// tester success

</script>
<script type="text/javascript" src="/assets/js/tooltips.definitions.js"></script>
<script type="text/javascript">

function CreateTips()
  {
  var tipstyle =
    {
    style:'protoblue',
    hook:{target:'topRight',tip:'bottomLeft'},
    stem:'bottomLeft',
    closeButton:false,
    hideAfter:5,
    hideOn:'click',
    showOn:'click',
    border:3,
    radius:3,
    width:300,
    };

  MainTips(tipstyle);
  AddOnTips(tipstyle, Tip);
  TipsCreated = 1;
  $$("span.tip").each(function(showspan){showspan.show();});
  }

function HideTips()
  {
  $$("span.tip").each(function(hidespan){hidespan.hide();});
  Tips.hideAll();
  }

function ToggleHelp()
  {
  if (TipsEnabled)
    {
    HideTips();
    $("TipsOnOffButton").value = "Turn Help On";
    TipsEnabled = 0;
    }
  else
    {
    CreateTips();
    $("TipsOnOffButton").value = "Turn Help Off";
    TipsEnabled = 1;
    }
  }

// tester success
</script>
<script type="text/javascript">


// Check list of series for which processing options are not available
function CheckNoProcessingList()
{
    var series_index = null;
    var disable_processing = null;
    var series = $('ExportRecordSet').retrieve('series', null)

    disable_processing = false;
    for (series_index = 0; series_index < NoProcessingList.length; series_index++)
    {
        if (series === NoProcessingList[series_index])
        {
            disable_processing = true;
            break;
        }
    }

    $('ProcessingShowCheckbox').store({ "enabled" : !disable_processing});

    update_processing_ui(false);
}

// tester success
</script>
<script type="text/javascript">


function file_upload_on_init()
  {
  $('ExportRecordSet').value = "";
  $('FileUploadCheckbox').checked = 0;
  $("RSCountPlace").innerHTML = "";
  $("ExportButton").value = "Submit Export Request";
  $("AjaxExportRequestRow").style.display="table-row";
  $('FileUploadInfoRow').style.display="none";
  $("RecordSetRow").style.display="table-row";
  $("RecordCountRow").style.display="table-row";
  $("ExportOpID").value = "exp_request";
  }

// tester failure

// called when record set from file checkbox checked/unchecked
function FileUploadWanted()
{
    // value after user has checked/unchecked the box
    var box_checked = $('FileUploadCheckbox').checked;

    // dirty since last time the CP button was clicked
    set_eb_state_disabled(true);

    if (box_checked)
    {
        // box is now in checked state
        alert("effl 0");
        $('ExportRecordSet').value = '*file*';
        $('ExportRecordSet').store({ "valid" : true });
        $('RecordSetRow').style.display = 'none';
        $('RecordCountRow').style.display = 'none';
        $('ExportOpID').value = 'exp_request';
        $('FileUploadRow').style.display = 'table-row';
        $('FileUploadInfoRow').style.display = 'none';
        $('AjaxExportRequestRow').style.display = 'none';
    }
    else
    {
        // box is now in unchecked state
        alert("effl 1");
        $('FileUploadInfoRow').style.display='none';
        file_upload_on_init();
        $('FileUploadRow').style.display='none';
    }
}

// tester success
</script>
<script type="text/javascript">

function create_export_endpoint_arguments(method)
{
    var access = null;
    var export_package = null;
    var argument_argument_obj = null;
    var argument_namespace = null;
    var file_format = null;
    var file_format_args = null;
    var ignore_processing = null;
    var export_endpoint_arguments = null;

    if (method.indexOf('ftp') != -1)
    {
        access = 'ftp';
    }
    else
    {
        access = 'http';
    }

    export_package = {};
    if (method.indexOf('tar') != -1)
    {
        export_package = { "type" : "tar" };
    }
    else
    {
        export_package = { "type" : null };
    }

    argument_argument_obj = unserialize_arguments($('ExportProtocolHidden').value);
    argument_namespace = Object.keys(argument_argument_obj)[0];
    if (Object.keys(argument_argument_obj[argument_namespace]).length > 0)
    {
        file_format = argument_namespace.toLowerCase();

        // file_format_args are extra arguments for the protocol types of FITS, JPEG, MPEG, and MP4
        if (file_format != 'fits' && file_format != 'jpg' && file_format != 'mpg' && file_format != 'mp4')
        {
            // error
        }
        else
        {
            file_format_args = argument_argument_obj[argument_namespace];
        }
    }
    else
    {
        file_format = $('ExportProtocol').options[$('ExportProtocol').selectedIndex].value.toLowerCase();
    }

    if (method === EXP_METH_QUICK)
    {
       export_endpoint_arguments = { "file-name-format" : $('ExportFilenameFmt').value, "number-records" : get_max_records(), "specification" : $('ExportRecordSet').value };
    }
    else if (method == EXP_METH_STREAMED)
    {
        export_endpoint_arguments = { "file-name-format" : $('ExportFilenameFmt').value, "specification" : $('ExportRecordSet').value };
    }
    else
    {
        ignore_processing = !$('ExportProcessing').retrieve('apply_processing', false);

        export_endpoint_arguments = { "access" : access, "package" : export_package, "specification" : $('ExportRecordSet').value, "file-format" : file_format, "file-format-args" : file_format_args, "file-name-format" : $('ExportFilenameFmt').value, "number-records" : get_max_records(), "processing" : ignore_processing ? {} : $('ExportProcessing').procesing_obj };
    }

    return export_endpoint_arguments;
}

function MakeFileUploadRequest()
{
    var method = $('ExportMethod').options[$('ExportMethod').selectedIndex].value.toLowerCase();
    var db_host = null;
    var export_endpoint_arguments = null;
    var action = null;

    alert("make file upload");

    if (CheckExportParams() == 0)
    {
        return;
    }

    if ($('PrivateHostElement').retrieve('is_private', false))
    {
        db_host = INTERNAL_SERVER;
    }
    else
    {
        db_host = EXTERNAL_SERVER;
    }

    export_endpoint_arguments = create_export_endpoint_arguments(method);

    if (method === EXP_METH_QUICK)
    {
        action = window.location.origin + MINI_EXPORT_REQUEST_FROM_FORM_PATH;
    }
    else if (method == EXP_METH_STREAMED)
    {
        // error
    }
    else
    {
        action = window.location.origin + PREMIUM_EXPORT_REQUEST_FROM_FORM_PATH;
    }

    // $('FileUploadFormID').action = action;
    // $('FileUploadFormID').submit();

    $('EFormAddress').value = $('ExportNotify').value.trim();
    $('EFormDbHost').value = db_host;
    $('EFormArguments').value = JSON.stringify(export_endpoint_arguments);
    $('EFormRequestor').value = $('ExportRequestor').value.trim();

    alert('form data ' + $('EFormAddress').value + ' ' + $('EFormDbHost').value + ' ' + $('EFormArguments').value + ' ' + $('EFormRequestor').value);

    $('ExportFormElement').action = action;
    $('ExportFormElement').submit();
}

</script>
<script type="text/javascript">

// called when file-upload response has loaded into the FileUploadFrame iframe
function process_file_upload_response()
{
    var iframe_html = null;
    var response = null;

    iframe_html = window.frames[0].document.getElementsByTagName("body")[0].innerHTML;
    if (iframe_html.length > 0)
    {
        response = iframe_html.responseJSON;
        AssimilateSubmissionResponse(response);
    }
}

function file_upload_on_complete()
{
    // form-submission response has been completely processed, without error; the request might be processed
    // asynchronously, in which case the get-status code will finalize the remaining export UI; one file-upload
    // error, the file picker and submit button remain displayed
    var upload_response_element = window.frames[0].document.getElementsByTagName("body")[0];

    if ($('FileUploadCheckbox').checked && upload_response_element.innerHTML.length > 0)
    {
        //delete downloaded data
        upload_response_element.innerHTML = "";

        // hide file-upload file picker, submit button
        $('FileUploadRow').style.display = "none";

        // show the results of the file upload
        $('FileUploadInfoRow').style.display = "table-row";
    }
}

function CallLookdata()
  {
  var recset = $('ExportRecordSet').value;
    var record_count = $('ExportRecordSet').retrieve('count', null);
  var posbracket = recset.indexOf("[");
  var posRbracket = recset.lastIndexOf("]");
  var posCurlbracket = recset.indexOf("{");
  var firstbracket = posbracket>=0 ? posbracket : posCurlbracket;
  var seriesname = (firstbracket == -1 ? recset : recset.substring(0,firstbracket));
  var recfilt = (posbracket >=0 ? recset.substring(posbracket,posRbracket+1) : "");
  var lookdataargs="ds="+seriesname;

  if (recfilt.length > 0)
    {
        // This is the filter used to select a series in lookdata.html, step 1.
        lookdataargs += "&rs=" + recfilt
    }

    if (record_count !== null && record_count > 0)
    {
        lookdataargs += "&n=" + record_count.toString();
    }

  LookdataWindow=window.open("http://" + Host + "/ajax/" + LOOKDATA + ".html?" + encodeURIComponent(lookdataargs), "JSOC Lookdata");
  LookdataWindow.window.focus();
  }

// tester success
</script>
<script type="text/javascript">


var RSCountActiveMSg = "Getting count - wait...";

// Class
function WlSeriesInfo()
{
}

// onSuccess() function for ParseSpec()
// callback assimilates parsed-spec info
function CreateParseSpecOnSuccess(callback)
{
    var on_success_fn = function(response)
    {
        var gri_response_obj = response.responseJSON;
        var status = null;
        var error_message = null;

        if (gri_response_obj !== null)
        {
            status = gri_response_obj.drms_export_status;
            error_message = null;

            if (status.search(/errorcode/i) == 0)
            {
                error_message = 'failure parsing record-set specification: ' + stringify_obj(gri_response_obj.error_message);
            }

            // gri_response_obj contains parsed spec data; use it
            // callback closure
            if (callback !== null)
            {
                callback(error_message, gri_response_obj);
            }
        }
    };

    return on_success_fn;
}

</script>
<script type="text/javascript">

// parses record-set specification, but does not validate parts (could return a string which is a valid series name, but
// of a series that does not exist
// `processSpec` is function returned by CreateProcessParsedFn()
// callback - assimilate parse-spec info; args error_message, data - called from on_success
function ParseSpec(callback)
{
    var export_app_arguments = null;
    var db_host = null;
    var on_success = null;
    var options = null;
    var on_failure = null;

    if ($('PrivateHostElement').retrieve('is_private', false))
    {
        db_host = INTERNAL_SERVER;
    }
    else
    {
        db_host = EXTERNAL_SERVER;
    }

    export_app_arguments = { "specification" : $('ExportRecordSet').value, "db-host" : db_host, "parse-only" : true };

    on_success = CreateParseSpecOnSuccess(callback);

    on_failure = function(error_message)
    {
        $('RSCountPlace').innerHTML = error_message;
        set_eb_state_disabled(true);

        if (callback !== null)
        {
            callback(error_message, null);
        }
    };

    options =
    {
        method: 'get',
        onSuccess: on_success,
        onFailure: function(response)
        {
            var gri_response_obj = response.responseJSON;
            var error_message = 'failure parsing record-set specification: ' + stringify_obj(gri_response_obj.error_message);

            on_failure(error_message);
        },
        on428: function(response)
        {
            var gri_response_obj = response.responseJSON;
            var error_message = 'invalid arguments to record-set endpoint: ' + stringify_obj(gri_response_obj.error_message);

            on_failure(error_message);
        },
        onComplete: function()
        {
        }
    };

    options['parameters'] = export_app_arguments;

    new Ajax.Request(window.location.origin + RECORD_SET_PATH, options);
}

// tester success
</script>
<script type="text/javascript">


// callback is the code that enables/disables processing options
function CreateAssimilateRecordInfoFn(callback)
{
    var assimilate_record_info_fn = function(error_message, gri_response_obj)
    {
        var resolved_error_message = error_message;
        var status = null;
        var aiaScaleCompatibilityChecked = null;
        var disabled_state = null;
        var compatible = null;
        var online = null;
        var size = null;
        var index = null;
        var valIndex = null;
        var ctype1Checked = null;
        var ctype2Checked = null;
        var first_record_recnum = null;
        var last_record_recnum = null;

        $('ExportRecordSet').disabled = false;
        $('CountButton').disabled = false;

        if (resolved_error_message === null)
        {
            try
            {
                aiaScaleCompatibilityChecked = false;

                $('ExportRecordSet').store({ "count" : gri_response_obj.count, "valid" : true });
                $('RSCountPlace').innerHTML = gri_response_obj.count.toString();

                disabled_state = $('OptionAiaScale').retrieve('disabled_state', null);
                aiaScaleCompatibilityChecked = (disabled_state !== null);

                // check for compatibility with aia_scale processing

                // aia_scale compatibility has not yet been determined; check now
                // loop through all records, checking the keyword criteria; jsoc_info
                // does not provide hash-accessibility to keyword info, so must
                // loop through all keywords
                if (gri_response_obj.hasOwnProperty('keywords'))
                {
                    ctype1Checked = false;
                    ctype2Checked = false;

                    if (aiaScaleCompatibilityChecked)
                    {
                        ctype1Checked = true;
                        ctype2Checked = true;
                    }
                    else
                    {
                        compatible = true;
                    }

                    for (index = 0; index < gri_response_obj.keywords.length; index++)
                    {
                        // we are assured that the CTYPE keywords will be in the jsoc_info results,
                        // even if the series does not have those keywords; if a keyword
                        // does not exist in the series, jsoc_info prints 'Invalid Keylink'
                        // for the keyword value (as long as the keyword is specified in the keys argument
                        // to jsoc_info)
                        if (compatible && !ctype1Checked && gri_response_obj.keywords[index].name.strip().toLowerCase() == KEYWORD_CTYPE1.toLowerCase())
                        {
                            for (valIndex = 0; compatible && valIndex < gri_response_obj.keywords[index].values.length; valIndex++)
                            {
                                // loop over records
                                if (gri_response_obj.keywords[index].values[valIndex] != AIA_SCALE_CTYPE1)
                                {
                                    compatible = false;
                                    break;
                                }
                            }

                            ctype1Checked = true;
                        }

                        if (compatible && !ctype2Checked && gri_response_obj.keywords[index].name.strip().toLowerCase() == KEYWORD_CTYPE2.toLowerCase())
                        {
                            for (valIndex = 0; compatible && valIndex < gri_response_obj.keywords[index].values.length; valIndex++)
                            {
                                // loop over records
                                if (gri_response_obj.keywords[index].values[valIndex] != AIA_SCALE_CTYPE2)
                                {
                                    compatible = false;
                                    break;
                                }
                            }

                            ctype2Checked = true;
                        }

                        // check to see if all SUs are online
                        if (online === null && gri_response_obj.keywords[index].name.strip().toLowerCase() == KEYWORD_ONLINE.toLowerCase())
                        {
                            online = true;

                            for (valIndex = 0; valIndex < gri_response_obj.keywords[index].values.length; valIndex++)
                            {
                                // loop over records
                                if (gri_response_obj.keywords[index].values[valIndex].toLowerCase() != 'y')
                                {
                                    online = false;
                                    break;
                                }
                            }
                        }

                        if (size === null && gri_response_obj.keywords[index].name.strip().toLowerCase() == KEYWORD_SIZE.toLowerCase())
                        {
                            size = 0;

                            for (var valIndex = 0; valIndex < gri_response_obj.keywords[index].values.length; valIndex++)
                            {
                                // loop over records
                                size += gri_response_obj.keywords[index].values[valIndex];
                            }
                        }

                        // set fist/last recnum state
                        if (gri_response_obj.keywords[index].name.strip().toLowerCase() === KEYWORD_RECNUM.toLowerCase())
                        {
                            first_record_recnum = gri_response_obj.keywords[index].values[0];
                            last_record_recnum = gri_response_obj.keywords[index].values[gri_response_obj.keywords[index].values.length - 1];
                            $('ExportRecordSet').store({ "first_record_recnum" : first_record_recnum, "last_record_recnum" : last_record_recnum });
                        }
                    }
                }
                else if (!aiaScaleCompatibilityChecked)
                {
                    // no keyword information was returned by jsoc_info, so we cannot tell if this series;
                    // this happens if no rows were returned
                    compatible = false;
                }

                if (!aiaScaleCompatibilityChecked)
                {
                    // we definitively know whether or not aia_scale processing should be disabled
                    if (compatible)
                    {
                        $('OptionAiaScale').store({ 'disabled_state' : false });
                    }
                    else
                    {
                        $('OptionAiaScale').store({ 'disabled_state' : true });
                    }
                }

                if (online)
                {
                    $('ExportRecordSet').store({ 'allSUsOnline' : true });
                }
                else
                {
                    $('ExportRecordSet').store({ 'allSUsOnline' : false });
                }

                $('ExportRecordSet').store({ 'sizeSU' : size });

                if (!$('OptionAiaScale').retrieve('disabled_state', false))
                {
                    // this series' first segment has a 2D-image with a CTYPE1 value of 'HPLN-TAN' and a CTYPE2 value of 'HPLT-TAN' so
                    // it is compatible with aia_scale processing; the code to determine this is split between processSeriesSelection and
                    // processRSInfo

                    // this should remain disabled until all asynchronous processing completes
                    $('OptionAiaScaleLabel').innerHTML = 'aia_scale - Scale image to 0.6 arcsec/pixel';
                    $('OptionAiaScaleLabel').setStyle({ color: 'black' });

                    // the determination of which aia_scale proc to use was already determined; in processSeriesSelection()
                    // a check of the LVL_NUM keyword was performed; this keyword must be constant, since a series cannot be
                    // a mix of levels
                    if ($('ExportRecordSet').retrieve('is_aia_lev1', null) === null && $('ExportRecordSet').retrieve('is_aia', false))
                    {
                        if (gri_response_obj.hasOwnProperty('keywords'))
                        {
                            for (index = 0; index < gri_response_obj.keywords.length; index++)
                            {
                                // loop over keywords
                                if (gri_response_obj.keywords[index].name.strip().toLowerCase() == KEYWORD_LVL_NUM.toLowerCase())
                                {
                                    $('ExportRecordSet').store('is_aia_lev1', true);

                                    for (valIndex = 0; valIndex < gri_response_obj.keywords[index].values.length; valIndex++)
                                    {
                                        // loop over records (one value element per DRMS record)
                                        var lvlnumString = gri_response_obj.keywords[index].values[valIndex];
                                        var lvlnum = null;

                                        // the series has a LVL_NUM constant keyword
                                        // round so we can compare floats
                                        lvlnum = Math.floor(10 * (parseFloat(lvlnumString) + 0.02)); // level numbers should be much farther apart than 0.02

                                        if (lvlnum != 10)
                                        {
                                            /* this is NOT an aia lev1 series */
                                            $('ExportRecordSet').store('is_aia_lev1', false);
                                            break;
                                        }
                                    }

                                    break; // look only at the LVL_NUM keyword
                                }
                            }
                        }
                    }
                }
                else
                {
                    // not compatible with aia_scale processing

                    // this should remain disabled until all asynchronous processing completes
                    $('OptionAiaScaleLabel').innerHTML = 'aia_scale - Scale image to 0.6 arcsec/pixel (compatible with 2D dataseries with CTYPE1 == HPLN-TAN and CTYPE2 == HPLT-TAN only)'
                    $('OptionAiaScaleLabel').setStyle({ color: 'grey' });

                    // uncheck the aia_scale checkbox if it is currently checked
                    if ($('OptionAiaScale').checked)
                    {
                        $('OptionAiaScale').checked = false;
                    }
                }

                // if the user has specified the current record with [$], then replace [$] with the record-specification
                if ($('ExportRecordSet').retrieve('last_record', false) && gri_response_obj.hasOwnProperty('keywords'))
                {
                    for (index = 0; index < gri_response_obj.keywords.length; index++)
                    {
                        if (gri_response_obj.keywords[index].name.strip().toLowerCase() == '*spec*' && gri_response_obj.keywords[index].values.length == 1)
                        {
                            $('ExportRecordSet').value = gri_response_obj.keywords[index].values[0];
                            break;
                        }
                    }
                }
            }
            catch(error)
            {
                // do nothing; callback will enabled record-set entry/count button
            }
        }

        if (callback !== null)
        {
            $('ExportRecordSet').store({ "record_info_complete" : true });
            callback(resolved_error_message);
        }
    };

    return assimilate_record_info_fn;
}

</script>
<script type="text/javascript">

// callback is code that assimilates the gri_response_obj; it calls the code that enables/disables processing options
function CreateDownloadRecordInfoOnSuccess(callback)
{
    var on_success_fn = function(response)
    {
        var gri_response_obj = response.responseJSON;
        var error_message = null;
        var status = null;
        var aiaScaleCompatibilityChecked = null;
        var compatible = null;
        var online = null;
        var size = null;
        var index = null;
        var valIndex = null;

        if (gri_response_obj !== null)
        {
            status = gri_response_obj.drms_export_status;

            if (status.search(/errorcode/i) == 0)
            {
                error_message = 'failure getting record-set information: ' + stringify_obj(status.error_message);
                $('ExportRecordSet').store({ "count" : null, "valid" : false });
                $("RSCountPlace").innerHTML = error_message;
            }
        }

        if (callback !== null)
        {
            callback(error_message, gri_response_obj);
        }
    };

    return on_success_fn;
}

</script>
<script type="text/javascript">

// if errMsg, then do not call jsoc_info, but we still have to call the callback (which is processRecordCount)
// callback is code that assimilates the gri_response_obj; it calls the code that enables/disables processing options
function DownloadRecordInfo(callback)
{
    var export_app_arguments = null;
    var options = null;
    var db_host = null;
    var on_success = null;
    var on_failure = null;

    if ($('PrivateHostElement').retrieve('is_private', false))
    {
        db_host = INTERNAL_SERVER;
    }
    else
    {
        db_host = EXTERNAL_SERVER;
    }

    export_app_arguments = { "specification" : $('ExportRecordSet').value, "db-host" : db_host, "number-records" : get_max_records(), "keywords" : [ KEYWORD_CTYPE1 + ',' + KEYWORD_CTYPE2 + ',' + KEYWORD_LVL_NUM + ',' + KEYWORD_SPEC + ',' + KEYWORD_ONLINE + ',' + KEYWORD_SIZE + ',' + KEYWORD_RECNUM ] };

    on_success = CreateDownloadRecordInfoOnSuccess(callback);

    on_failure = function(error_message)
    {
        var callback = callback;

        $('ExportRecordSet').store({ "count" : null, "series" : null, "valid" : false });
        $('RSCountPlace').innerHTML = error_message;
        set_eb_state_disabled(true);

        if (callback)
        {
            callback(error_message);
        }
    };

    options =
    {
        method: 'get',
        onSuccess: on_success,
        onFailure: function(response)
        {
            var error_message = 'failure getting record-set information: ' + stringify_obj(response.responseJSON.error_message);

            return on_failure(error_message);
        },
        on428: function(response)
        {
            var error_message = 'invalid arguments to record-set endpoint: ' + stringify_obj(response.responseJSON.error_message);

            return on_failure(error_message);
        },
        onComplete: function(response)
        {
        }
    };

    $('RSCountPlace').innerHTML = RSCountActiveMSg;

    options['parameters'] = export_app_arguments;

    new Ajax.Request(window.location.origin + RECORD_SET_PATH, options);
}

// tester success
</script>
<script type="text/javascript">


function do_stream_export(event, form)
{
    // disable the beforeunload event handler
    window.onbeforeunload = null; $('FileUploadFormID').store({ 'beforeunloadOverride' : true });

    // HTTP POST
    try
    {
        form.submit()
    }
    catch(err)
    {
        alert('error ' + err);
    }
}

// called after the click on "Submit Export Request" button when url_direct is the selected export method
function CreateExportDownloadButton(err, callback)
{
    var db_host = null;
    var export_arguments = null;
    var export_endpoint_arguments = null;
    var errMsg = null;
    var form_element = null;
    var address_input = null;
    var db_host_input = null;
    var export_arguments_input = null;
    var requestor_input = null;
    var button_input = null;

    if (err && err.length > 0)
    {
        errMsg = err;
    }
    else
    {
        localStorage.removeItem('request-id');

        if ($('PrivateHostElement').retrieve('is_private', false))
        {
            db_host = INTERNAL_SERVER;
        }
        else
        {
            db_host = EXTERNAL_SERVER;
        }
        export_arguments = $('ExportRecordSet').retrieve('exportArgs', null);
        export_endpoint_arguments = { "specification" : export_arguments.specification, "file-name-format" : export_arguments.filenamefmt };

        // create POST form that returns an HTTP response that either opens a new tab/window or uses mime-type info
        // to open a FITS view like ds9
        form_element = new Element('form', { "id" : "se_form", "name" : "stream_export_form", "method" : "post", "action" : "", "target" : "_blank", "enctype" : "multipart/form-data" })
        address_input = new Element('input', { "id" : "se_form_address", "name" : "se-address", "type" : "hidden", "value" : export_arguments.address, "style" : "display:none" })
        db_host_input = new Element('input', { "id" : "se_form_db_host", "name" : "se-db-host", "type" : "hidden", "value" : db_host, "style" : "display:none" })
        export_arguments_input = new Element('input', { "id" : "se_form_export_arguments", "name" : "se-export-arguments", "type" : "hidden", "value" : JSON.stringify(export_endpoint_arguments), "style" : "display:none" })
        requestor_input = new Element('input', { "id" : "se_form_requestor", "name" : "se-requestor", "type" : "hidden", "value" : export_arguments.requestor, "style" : "display:none" })

        form_element.insert(address_input);
        form_element.insert(db_host_input);
        form_element.insert(export_arguments_input);
        form_element.insert(requestor_input);
        // form_element.insert(button_input);
        form_element.action = STREAMED_EXPORT_REQUEST_FROM_FORM_PATH;

        // create button in $('ExportLocation'); when clicked, JSON data are sent to STREAMED_EXPORT_REQUEST_FROM_FORM_PATH;
        // either a save-file dialog will display or, if the user has set-up their mime-type file association, the
        // file will display in a viewer like ds9
        button_input = new Element('input', { "class" : "button", "type" : "button", "value" : "stream export" })
        button_input.observe('click', function(event) { do_stream_export(event, form_element); });

        $('SubmitResponseDiv').insert(form_element);

        $('DataLocation').store({ "header" : "Download" });
        $('ExportLocation').store({ "button" : button_input });

        update_request_section_ui(null, null, null, null, $('ExportRecordSet').retrieve('sizeSU', null), null, null, null, null, null, null, null, null, null, null, true);
    }

    if (callback !== null)
    {
        callback(errMsg);
    }
}

// callback is code that enables/disables processing items
function CreateAssimilateSeriesInfoFn(callback)
{
    var assimilate_series_info_fn = function(error_message, gsi_response_obj)
    {
        // 'StatusCode.SUCCESS' is the only other possible status
        // successfully obtained series info
        var compatible = null;
        var series = $('ExportRecordSet').retrieve('series', null);
        var series_ns = $('ExportRecordSet').retrieve('series_ns', null);
        var keywordsObj = null;
        var resolved_error_message = error_message;

        if (resolved_error_message === null)
        {
            if (series === null || series_ns === null)
            {
                resolved_error_message = 'unable to retrieve series information; series not provided';
            }
            else
            {
                try
                {
                    for (var segment in gsi_response_obj[series.toLowerCase()].segments)
                    {
                        if (gsi_response_obj[series.toLowerCase()].segments.hasOwnProperty(segment))
                        {
                            if ((parseInt(gsi_response_obj[series.toLowerCase()].segments[segment]['segment-number']) == 0) &&
                                 (parseInt(gsi_response_obj[series.toLowerCase()].segments[segment]['number-axes']) != 2))
                            {
                                // we know that aia_scale should definitely be disabled; store that information now so we can skip
                                // the secondary check in processRSInfo
                                $('OptionAiaScale').store({ 'disabled_state' : true });
                                compatible = false;
                                break;
                            }
                        }
                    }

                    keywordsObj = gsi_response_obj[series.toLowerCase()].keywords;

                    if (compatible === null)
                    {
                        // compatibility not yet determined
                        if (!keywordsObj.hasOwnProperty(KEYWORD_CTYPE1.toLowerCase()) || !keywordsObj.hasOwnProperty(KEYWORD_CTYPE2.toLowerCase()))
                        {
                            compatible = false;
                        }
                        else
                        {
                            if ((keywordsObj[KEYWORD_CTYPE1.toLowerCase()]['constant-value'] != AIA_SCALE_CTYPE1 &&
                                 keywordsObj[KEYWORD_CTYPE1.toLowerCase()]['constant-value'] != NA) ||
                                (keywordsObj[KEYWORD_CTYPE2.toLowerCase()]['constant-value'] != AIA_SCALE_CTYPE2 &&
                                 keywordsObj[KEYWORD_CTYPE2.toLowerCase()]['constant-value'] != NA))
                            {
                                // we know that aia_scale should definitely be disabled; store that information now so we can skip
                                // the secondary check in
                                $('OptionAiaScale').store({ 'disabled_state' : true });
                                compatible = false;
                            }
                        }
                    }


                    // we can also determine compatibility with the MPT-selection check box
                    if (series_ns.toLowerCase() == AIA_NAMESPACE)
                    {
                        $('AiaScaleUseMptCheckbox').disabled = false;
                        $('AiaScaleUseMptCheckboxLabel').innerHTML = 'Use a master pointing table to scale images (instead of keyword values)&nbsp';
                        $('AiaScaleUseMptCheckboxLabel').setStyle({ color: 'black' });
                    }
                    else
                    {
                        $('AiaScaleUseMptCheckbox').disabled = true;
                        $('AiaScaleUseMptCheckboxLabel').innerHTML = 'Use a master pointing table to scale images (instead of keyword values - compatible with AIA series only)&nbsp';
                        $('AiaScaleUseMptCheckboxLabel').setStyle({ color: 'grey' });
                    }

                    // finally, if KEYWORD_LVL_NUM is constant in an AIA series, then set the aia_scale processing flag that determines
                    // which aia_scale proc is used
                    if (series_ns.toLowerCase() == AIA_NAMESPACE)
                    {
                        $('ExportRecordSet').store('is_aia', true);

                        if (keywordsObj.hasOwnProperty(KEYWORD_LVL_NUM.toLowerCase()))
                        {
                            var lvlnumString = keywordsObj[KEYWORD_LVL_NUM.toLowerCase()]['constant-value'];
                            var lvlnum = null;

                            if (lvlnumString != NA)
                            {
                                // the series has a LVL_NUM constant keyword
                                // round so we can compare floats
                                lvlnum = Math.floor(10 * (parseFloat(lvlnumString) + 0.02)); // level numbers should be much farther apart than 0.02

                                if (lvlnum == 10)
                                {
                                    /* this is an aia lev1 series */
                                    $('ExportRecordSet').store({ "is_aia_lev1" : true });
                                }
                            }
                        }
                    }

                    // cache series info
                    series_cache = $('ExportRecordSet').retrieve('series_cache', null);

                    if (series_cache !== null && series !== null && (series_cache[series.toLowerCase()] === undefined || series_cache[series.toLowerCase()] === null))
                    {
                        series_cache[series.toLowerCase()] = gsi_response_obj[series.toLowerCase()];
                    }

                    // GenerateFileFormatString does the following:
                    //    file format string, first segment, first time-prime key
                    GenerateFileFormatString(gsi_response_obj);

                    update_protocol_ui(false);
                }
                catch(error)
                {
                    // do nothing; callback will enable record-set entry/count button
                }
            }
        }

        if (callback !== null)
        {
            $('ExportRecordSet').store({ "series_info_complete" : true });
            callback(resolved_error_message);
        }
    }

    return assimilate_series_info_fn;
}


// callback is code that assimilates the gri_response_obj; it calls the code that enables/disables processing options
function CreateDownloadSeriesInfoOnSuccess(callback)
{
    var on_success_fn = function(response)
    {
        var gsi_response_obj = response.responseJSON;
        var error_message = null;
        var series = $('ExportRecordSet').retrieve('series', null);
        var series_ns = $('ExportRecordSet').retrieve('series_ns', null);
        var status = null;

        if (gsi_response_obj !== null)
        {
            status = gsi_response_obj.drms_export_status;

            if (status.search(/errorcode/i) == 0)
            {
                error_message = 'failure getting series information: ' + stringify_obj(gsi_response_obj.error_message);
                $('ExportRecordSet').store({ "count" : null, "series" : null, "series_ns" : null, "valid" : false});
                $('RSCountPlace').innerHTML = error_message;
            }
        }

        if (callback !== null)
        {
            callback(error_message, gsi_response_obj);
        }
    };

    return on_success_fn;
}

// callback is code that assimilates series info in gsi_response_obj; it calls the code that enables/disables processing options
function DownloadSeriesInfo(callback)
{
    var export_app_arguments = null;
    var options = null;
    var db_host = null;
    var on_success = null;
    var on_failure = null;

    if ($('PrivateHostElement').retrieve('is_private', false))
    {
        db_host = INTERNAL_SERVER;
    }
    else
    {
        db_host = EXTERNAL_SERVER;
    }

    export_app_arguments = { "series" : [ $('ExportRecordSet').retrieve('series', null) ], "db-host" : db_host, "links" : [] };

    on_success = CreateDownloadSeriesInfoOnSuccess(callback);

    on_failure = function(error_message)
    {

        $('ExportRecordSet').store({ "count" : null, "series" : null, "series_ns" : null, "valid" : false });
        $('RSCountPlace').innerHTML = error_message;
        set_eb_state_disabled(true);

        if (callback !== null)
        {
            callback(error_message);
        }
    };

    options =
    {
        method: 'get',
        onSuccess: on_success,
        onFailure: function(response)
        {
            var error_message = 'failure getting series information: ' + stringify_obj(response.responseJSON.error_message);

            on_failure(error_message);
        },
        on428: function(response)
        {
            var error_message = 'invalid arguments to series endpoint: ' + stringify_obj(response.responseJSON.error_message);

            on_failure(error_message);
        },
        onComplete: function(response)
        {
        }
    };

    options['parameters'] = export_app_arguments;

    new Ajax.Request(window.location.origin + SERIES_PATH, options);
}




// tester success
</script>
<script type="text/javascript">

// tester success
</script>
<script type="text/javascript">


// series is valid - it just means the specification has valid syntax); callback is generally processRecordCount
function CreateAssimilateParsedSpecFn()
{
    // called by onSuccess() of ParseSpec(), which is the function returned by CreateParseSpecOnSuccess()
    // extracts series name and checks for record-set filter
    var assimilate_parsed_spec_fn =
        function(error_message, data)
        {
            var enable_processing_options_fn = null;
            var assimilate_series_info_fn = null;
            var assimilate_record_info_fn = null;

            if (error_message)
            {
                $('ExportRecordSet').store({ "count" : null, "series" : null, "valid" : false });
                $('RSCountPlace').innerHTML = error_message;

                $('ExportRecordSet').disabled = false;
                $('CountButton').disabled = false;
                $('ExportRecordSet').store({ "series_info_complete" : true, "record_info_complete" : true });
            }
            else
            {
                try
                {
                    // since we've only parsed the record-set specification, but have not yet tried to count records
                    // we know we have valid series name, but we do not know if the series exists
                    var series = data.subsets[0].seriesname;
                    var seriesNs = data.subsets[0].seriesns;
                    var validSpec = data.subsets[0].spec;
                    var lastRecord = false;

                    if (!data.hasfilts && $('ExportRecordLimit').retrieve('limit', null) === null)
                    {
                        validSpec = series + '[$]' + (data.subsets[0].segments === null ? '' : data.subsets[0].segments);
                        lastRecord = true;
                    }
                    else if (data.hasfilts)
                    {
                        if (data.subsets[0].filter == '[$]')
                        {
                            lastRecord = true;
                        }
                    }

                    // store this determination for use later when determining the disabledState of processing steps
                    $('ExportRecordSet').store({ 'last_record' : lastRecord });
                    $('ExportRecordSet').value = validSpec;

                    // store parsed series name for this record set
                    $('ExportRecordSet').store({ "series" : series, "series_ns" : seriesNs })

                    // initialize series cache for this series
                    series_cache = $('ExportRecordSet').retrieve('series_cache', null);
                    if (series_cache === null)
                    {
                        series_cache = {};
                        $('ExportRecordSet').store({ 'series_cache' : series_cache });
                    }

                    if (series_cache[series.toLowerCase()] === undefined || series_cache[series.toLowerCase()] === null)
                    {
                        series_cache[series.toLowerCase()] = null; // to be filled in with series struct info after series endpoint has loaded
                    }

                    // use the parsed series name to call the jsocInfoCGI to get the series information;
                    // disable the aia_scale processing option if the series selected is not suitable for that
                    // processing option; NOTE: the series info might not be sufficient to make this determination;
                    // if this is the case, then we need to consult the actual record metadata to do so; check
                    // series info first since this is a simpler, quicker test;
                    //
                    // series suitable for the aia_scale processing option have these properties:
                    //   1. They are 2-D time series
                    //   2. CTYPE1 == 'HPLN-TAN'
                    //   3. CTYPE2 == 'HPLT-TAN'
                    //
                    // the RequestSeriesInfo callback needs to call RequestRSInfo with callback as the callback

                    // if we want the callback to return results quickly, then we need to skip running requestRSInfo() since
                    // that could be a slow asynchronous call;


                    // we only need to do this if the record count has not yet been obtained
                    // ART - as far as I can tell, there is no need to wait this long to get record count, and there
                    // is no processing to do after the count has been calculated - do this much earlier
                    // instead, this can be done at the same time RequestSeriesInfo() is called - we just need the
                    // record-set to be modified, if need be. And there should be no call back to call after the
                    // the number of records has been counted

                    // if we have skipped the requestRSInfo callback, then we need to do that later

                    enable_processing_options_fn = CreateEnableProcessingOptionsFn();

                    assimilate_record_info_fn = CreateAssimilateRecordInfoFn(enable_processing_options_fn);

                    // start record-info ajax (for record count, enable/disable processing items) and series-info ajax (for file format,
                    // first time-prime, series cache, first segment, enable/disable processing items) in parallel

                    // ajax callback is assimilate_record_info_fn, which calls the function that enables/disables processing items
                    // ART - GRRRR! assimilate_record_info_fn really needs to call RECORD_PATH again, for various keyword values
                    // for the first and last records, for processing initialization; we need the results of DownloadRecordInfo()
                    // so we can extract the recnums of the first/last records, and then use those to make a new record info download
                    // for the processing keywords for the first/last records
                    DownloadRecordInfo(assimilate_record_info_fn)

                    assimilate_series_info_fn = CreateAssimilateSeriesInfoFn(enable_processing_options_fn);

                    // ajax callback is assimilate_series_info_fn, which calls the function that enables/disables processing items
                    DownloadSeriesInfo(assimilate_series_info_fn);
                }
                catch(error)
                {
                    $('ExportRecordSet').disabled = false;
                    $('CountButton').disabled = false;
                    $('ExportRecordSet').store({ "series_info_complete" : true, "record_info_complete" : true });
                }
            }
        };

    return assimilate_parsed_spec_fn;
}

// Internal-DB pass-through.
// If the user is accessing the external website, the database source of the series information could be the internal database.
// External users have access to a sanctioned list of internal data series. So, we do not necessarily want to use the 'Host'
// variable to identify the jsoc_info CGI. If the user is accessing a sanctioned internal series, then we need to use the jsoc_info
// CGI hosted on jsoc2.stanford.edu, not the one on 'Host' (which is jsoc.stanford.edu).
// The callback is optional. Many functions require jsoc_info to have returned before they can continue.
//
// IF THE CALLBACK IS NOT null THEN IT MUST BE CALLED, EVEN ON ERROR; OTHERWISE, CERTAIN GLOBAL VARIABLES
// WILL NOT BE SET APPROPRIATELY

function GetCompatibleFormat(series, attributes, keywords)
{
    var format = null;
    var ipkey;
    var extPrime;
    var dataType;

    if (attributes && keywords)
    {
        format = series;

        for (ipkey = 0; ipkey < attributes.drmsprimekey.length; ipkey++)
        {
            // loop on prime keywords (remove _index from keyword name to HACKILY convert from internal name to external name)
            extPrime = attributes.drmsprimekey[ipkey].replace(/_index/i, '');
            dataType = keywords[extPrime.toLowerCase()]['data-type'].toLowerCase();

            if (dataType == 'time')
            {
                format = format + '.' + '{' + extPrime + ':A}';
            }
            else
            {
                format = format + '.' + '{' + extPrime + '}';
            }
        }

        format = format + '.' + '{segment}';
    }

    return format;
}

// tester success
</script>
<script type="text/javascript">

// load the series endpoint; the securedrms client caches the series information, so if
// the endpoint is loaded for a previous invocation, the response will be returned quickly;
// the series information is NOT cached in the javascript - that is something to consider
function GenerateFileFormatString(gsi_response_obj)
{
    if (gsi_response_obj !== null)
    {
        var series = $('ExportRecordSet').retrieve('series', null);
        var keywords = (new Hash(gsi_response_obj[series.toLowerCase()].keywords)).keys();
        var segments = (new Hash(gsi_response_obj[series.toLowerCase()].segments)).keys();
        var prime_key_length = gsi_response_obj[series.toLowerCase()].attributes.drmsprimekey.length;
        var number_keys = keywords.length;
        var format = null;
        var key_index = null;
        var seg_index = null;
        var member = null;
        var member_obj = null;
        var series_cache = null;
        var series = $('ExportRecordSet').retrieve('series', null);

        if (prime_key_length == 0)
        {
            format = series + '.{recnum:%lld}.{segment}';
        }
        else
        {
            format = series + '.';
            for (key_index = 0; key_index < prime_key_length; key_index += 1)
            {
                member = gsi_response_obj[series.toLowerCase()].attributes.drmsprimekey[key_index].replace(/_index/i, '');
                member_obj = gsi_response_obj[series.toLowerCase()].keywords[member.toLowerCase()];

                if (member_obj['data-type'].toLowerCase() === 'time')
                {
                    if ($('ExportRecordSet').retrieve('first_time_pkey', null) === null)
                    {
                        $('ExportRecordSet').store({ "first_time_pkey" : member })
                    }

                    format = format + '{' + member + ':A}.';
                }
                else
                {
                    format = format + '{' + member + '}.';
                }
            }

            format = format + '{segment}';
        }

        $('ExportFilenameFmt').value = format;
        $('ExportFilenameFmt').store('valid', true);

        for (seg_index = 0; seg_index < segments.length; seg_index += 1)
        {
            if (gsi_response_obj[series.toLowerCase()].segments[segments[seg_index].toLowerCase()].protocol.toLowerCase() === 'fits')
            {
                $('ExportRecordSet').store({ "first_fits_segment" : segments[seg_index] })
                break;
            }
        }
        var ix = 10;
    }

    var mm = 12;
}
// tester success
</script>
<script type="text/javascript">
function CreateDataTable(export_data, package)
{
    var count = export_data.length;
    var valuetable = null;
    var record_specification = null;
    var export_url = null;
    var file_name = null;

    valuetable = "<table id='ResultsTable' border='1'>";
    valuetable = valuetable + "<tr><td>File<\/td><td>Record<\/td><td>Filename<\/td><\/tr>";

    for (ifile = 0; ifile < count; ifile++)
    {
        record_specification = export_data[ifile][0];

        valuetable = valuetable + "<tr>";
        valuetable = valuetable + "<td>" + (ifile + 1) + "<\/td>";
        valuetable = valuetable + "<td>" + record_specification + "<\/td>";

        if (package !== null && package.hasOwnProperty('type') && package.type !== null && package.type.trim().toLowerCase() === 'tar')
        {
            file_name = export_data[ifile][1];
            valuetable = valuetable +  "<td>" + file_name + "<\/td><\/tr>";
        }
        else
        {
            export_url = export_data[ifile][1];
            file_name = export_url.substring(export_url.lastIndexOf('/') + 1);
            valuetable = valuetable + "<td>" + "<a href='" + export_url + "' target='_blank'>" + file_name + "<\/a>" + "<\/td>";
        }

        valuetable = valuetable + "<\/tr>";
    }

    valuetable = valuetable + "<\/table>";
    return valuetable;
}

function ExportNop()
  {
  }

function ExportRSChanged()
{
    $('ExportCheckButton').store({ "dirty" : true });

    $('ExportRecordSet').store({ "count" : null });

    // reset the wavelength used for the image options for this record-set
    $('ExportRecordSet').store({ "wavelength" : null });
    $("CountButton").style.backgroundColor = colorYellow;

    // processing code caches first and last record info
    $('ExportRecordSet').store({ "fl_record_info" : null });

    ExportNewRS(); // to fix operator not pressing enter or count
  }

</script>
<script type="text/javascript">

// called once after series info has been downloaded, and once after record info has been downloaded; after the second
// call, the series cache will have been initialized AND the number of records will have been determined
function CreateEnableProcessingOptionsFn()
{
    var enable_processing_options_fn = function(error_message)
    {
        var option_index;
        var processing_option_id;
        var disabled_state_rec_dep;
        var need_rs_info = false;
        var series_cache = null;
        var series = null;
        var number_records = null;
        var resolved_error_message = error_message;
        var series_info_complete = null;
        var record_info_complete = null;

        if (resolved_error_message === null)
        {
            series_cache = $('ExportRecordSet').retrieve('series_cache', null);
            series = $('ExportRecordSet').retrieve('series', null);
            number_records = $('ExportRecordSet').retrieve('count', null);

            series_info_complete = $('ExportRecordSet').retrieve('series_info_complete', false);
            record_info_complete = $('ExportRecordSet').retrieve('record_info_complete', false);

            // the following block is executed only after both series info and record info collection has been completed successfully
            if (series_cache !== null && series !== null && series_cache[series.toLowerCase()] !== undefined && series_cache[series.toLowerCase()] !== null && number_records !== null)
            {
                CheckNoProcessingList();
                // NotifyProcessingCode requires the first jsoc_info to have completed (the one started by SetRecordLimit()).
                // It also requires that SetProcessing() has completed its asynchronous running.
                NotifyProcessingCode(function () { $('ExportRecordSet').disabled = false; $('CountButton').disabled = false; });

                // check each export processing step's disabled_state (except for processing option 0 - that is no_op)
                for (option_index = 1; option_index < ExportProcessingOptions.length; option_index++)
                {
                    processing_option_id = ExportProcessingOptions[option_index].id;
                    disabled_state_rec_dep = $(processing_option_id).retrieve('disabled_state_rec_dep', false);

                    if (disabled_state_rec_dep)
                    {
                        // SET disabled state (if it is not set already - null means that true/false value has not yet been determined); the
                        // way we do this is to get rs info; if disabled_state_rec_dep, then whether the processing item is enabled depends
                        // on the record information
                        if ($(processing_option_id).retrieve('disabled_state', null) === null)
                        {
                            // ART - this is an error condition; we should have already determined disabled_state in CreateAssimilateRecordInfoFn() function;
                            // however, just assume that the option is disabled
                            $(processing_option_id).store({ "disabled_state" : true });
                        }
                    }
                }

                $('ProcessingCheckboxLabel').style.color = 'black';
                $('ProcessingCheckboxLabel').style['font-weight'] = 'normal';
                $('ProcessingWaitMessage').style.display = 'none';

                // we don't have to wait to enable 'enable processing' checkbox
                $('ProcessingCheckbox').disabled = false;
            }
            else
            {
                // if we somehow get here and both series and record info complete, we need to enable record-set entry/call button
                if (series_info_complete && record_info_complete)
                {
                    $('ExportRecordSet').disabled = false;
                    $('CountButton').disabled = false;
                }
            }
        }
        else
        {
            // something went wrong; uncheck any processing check boxes that are checked and hide the processing UI
            for (iProc = 0; iProc < ExportProcessingOptions.length; iProc++)
            {
                var ExpOpt = ExportProcessingOptions[iProc];

                $(ExpOpt.id).checked = false;
                if (ExpOpt.id != 'OptionNone' && ExpOpt.hasOwnProperty('rowid'))
                {
                    // the 'none' processing step has no processing UI html element
                    $(ExpOpt.rowid).style.display = "none";
                }
            }

            // Re-enable the RecordSet text box.
            $('ExportRecordSet').disabled = false;
            $('CountButton').disabled = false;
        }

        if (resolved_error_message !== null)
        {
            $('ProcessingWaitMessage').style.display = 'table-row';
            $('ProcessingWaitMessage').innerHTML = resolved_error_message;
        }

        update_export_buttons();
    };

    return enable_processing_options_fn;
}


</script>
<script type="text/javascript">

// Called when record-set changes, when user clicks on Recount button, when user clicks on enter key in RecordSet field;
function ExportNewRS()
{
    // This took forever to figure out. JS event handlers CAN interrupt each other at alert()s.
    // ExportRecordSet has both an onchange and an onclick handler that fire when you click on the Recount
    // button after you enter a record-set specification. As a result, ExportNewRS() is called twice.
    // IFF you have an alert anywhere between the checking for newRSRunning and the setting of
    // newRSRunning in ExportNewRS(), then the onchange handler
    // will be interrupted at the alert() statement, and the onclick handler will run.
    var old_set = null;
    var set_changed = true;

    // NO alert()!

    // disable elements that allow user to change record-set spec until current set is handled completely
    $('ExportRecordSet').disabled = true;
    $('CountButton').disabled = true;
    $('ExportRecordSet').store({ "series_info_complete" : false, "record_info_complete" : false });

    // figure out if the user actually changed the record-set specification
    old_set = $('ExportRecordSet').retrieve('old_set', null);
    if (old_set != null && old_set == $('ExportRecordSet').value)
    {
        set_changed = false;
    }
    else
    {
        // update old_set
        $('ExportRecordSet').store({ 'old_set' : $('ExportRecordSet').value });
    }

    if (set_changed)
    {
        $('OptionAiaScale').store({ 'disabled_state' : null }); // means aia_scale compatibility not determined yet; also
                                                                // means that $('OptionAiaScale') has a disabledState property;
                                                                // changing record-set invalidates the existing validation
    }

    // disable the 'Enable Processing' checkbox - will be enabled once the record-set has been examined for processing-step checkbox
    // disabled state
    $('ProcessingCheckbox').disabled = true;
    $('ProcessingCheckboxLabel').style.color = 'grey';

    // close the processing checkboxes
    $('ProcessingCheckbox').checked = false;
    update_processing_ui(false);

    // display a message notifying user that we are working on enabling processing options (must examine all records)
    $('ProcessingWaitMessage').style.color = colorBrightOrange;
    $('ProcessingWaitMessage').style['font-weight'] = 'bold';
    $('ProcessingWaitMessage').style.opacity = 1.0;
    $('ProcessingWaitMessage').innerHTML = 'Determining applicable processing steps...please wait...';
    $('ProcessingWaitMessage').style.display = 'table-row';

    // disable processing step checkboxes for now, since we are about to change the record-set, and some processing steps
    // need the record-set to be present
    for (iProc = 0; iProc < ExportProcessingOptions.length; iProc++)
    {
        var ExpOpt = ExportProcessingOptions[iProc];
        $(ExpOpt.id).disabled = true;
    }

    $("CountButton").style.backgroundColor = colorNeutral;

    // this is the text after RequestID in the upper section; we just changed the input parameters, so get rid of this
    $("RequestIdPlace").innerHTML = "";

    // remove requestid so that the CP and EB buttons and messages will get reset correctly
    $("StatusRequestID").value = "";

    // get rid of the results tables in the upper and lower sections
    $('ExportButton').store({"reset" : true });
    update_request_section_ui(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, false);

    $('StatusButton').store({ "reset" : true });
    update_status_section_ui(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);

    $('ExportButton').store({ "ajax-state" : "pre-click" });
    $('StatusButton').store({ "ajax-state" : "pre-click" });

    update_protocol_ui(false);

    // a change in RS plus a change in record limit causes a change in the number of records - starts jsoc_info asynchronously
    update_record_set_ui(false);

    set_eb_state_disabled(true);
}

</script>
<script type="text/javascript">

// respond to change in record-set value
function update_record_set_ui(reset)
{
    // reset - these attributes will be set by parse/series info/rs info processes
    $('ExportRecordSet').store({ "count" : null, "series" : null, "is_aia" : null, "is_aia_lev1" : null, "valid" : null });
    $('ExportFilenameFmt').store({ 'originalFormat' : null });

    if (reset)
    {
        set_eb_state_disabled(true);
    }
    else
    {
        // parse specification, then get series and record info in parallel
        // does these things:
        //  - makes spec valid
        //  - calculates last record
        //  - stores value of series in $('ExportRecordSet') series attribute
        //  - initializes series cache

        try
        {
            ParseSpec(CreateAssimilateParsedSpecFn()); // stores series in $('ExportRecordSet') 'series' attribute (value is an object with k-v for each series)
        }
        catch(error)
        {
            $('ExportRecordSet').disabled = false;
            $('CountButton').disabled = false;
            $('ExportRecordSet').store({ "series_info_complete" : true, "record_info_complete" : true });
        }
    }
}

// tester success
</script>
<script type="text/javascript">

function update_record_limit_ui(reset)
{
    var limit = null;

    if (reset)
    {
        set_eb_state_disabled(true);
    }

    limit = parseInt($('ExportRecordLimit').value);

    if (reset || limit == 0 || $('ExportRecordLimit').value.trim().toLowerCase() === 'none')
    {
        $('ExportRecordLimit').style.color = colorBlack;
        $('ExportRecordLimit').value = 'none';
        $('ExportRecordLimit').store('limit', null);
    }
    else if (isNaN(limit))
    {
        $('ExportRecordLimit').style.color = colorRed;
        $('ExportRecordLimit').value = 'none';
        $('ExportRecordLimit').store('limit', null);
        $('ExportCheckMsg').store('cp_message', 'Record Limit value must be an integer or the string `none`');
        update_export_buttons()
    }
    else
    {
        $('ExportRecordLimit').style.color = colorBlack;
        $('ExportRecordLimit').store('limit', limit);
    }
}

// onChange() of ExportRecordLimit; symbol is in html form, so do not change it
function SetRecordLimit()
{
    set_eb_state_disabled(true);
    return update_record_limit_ui(false)
}

// reset ==> called in response to RS change, so disabled state is clean
function update_export_method(reset)
{
    var valid = null;

    if (reset)
    {
        valid = ($('ExportMethod').options[2].value.trim().toLowerCase() === EXP_METH_FULL);
        $('ExportMethod').store({ "valid" : true });
        set_eb_state_disabled(true);
    }

    // there is nothing to modify in response to a user pull-down selection
    return valid;
}

function validate_export_method()
{
    var valid = null;
    var export_method_element = $('ExportMethod');
    var export_method = export_method_element.options[export_method_element.selectedIndex].value.trim().toLowerCase();

    valid = export_method_element.retrieve('valid', null);

    if (valid === null)
    {
        if (export_method === EXP_METHOD_STREAMED || export_method === EXP_METHOD_QUICK || export_method === EXP_METHOD_FULL || export_method === EXP_METHOD_FULL_FTP || export_method === EXP_METHOD_FULL_TAR || export_method === EXP_METHOD_FULL_FTP_TAR)
        {
            valid = true;
        }
        else
        {
            valid = false;
        }

        export_method_element.store({ "valid" : valid });

    }

    return valid;
}

// called only when the user changes the export method pulldown (so this in the onChange())
function SetExportMethod(by_whom)
{
    // byWhom = 0 for user click, else 1 (vestigial)

    set_eb_state_disabled(true);

    update_export_method_ui(false);
}

function disable_processing()
{
    var index = null;

    // hide processing altogether
    $('ProcessRow').style.display = 'none';

    // set processing checkbox to none/noop
    $(ExportProcessingOptions[0].id).checked = true;

    for (index = 1; index < ExportProcessingOptions.length; index++)
    {
        $(ExportProcessingOptions[index].id).checked = false;
        $(ExportProcessingOptions[index].rowid).style.display = 'none';
    }
}

function update_export_method_ui(reset)
{
    var method = $('ExportMethod').options[$('ExportMethod').selectedIndex].value.trim().toLowerCase();

    if (reset)
    {
        update_export_method(true);
    }
    else
    {
        update_export_method(false);
        $('ExportMethod').store({ "valid" : false });
        if (!validate_export_method())
        {
            update_export_method(true);
        }
    }

    if (method === EXP_METH_STREAMED)
    {
        disable_processing();

        // enable file-format selection, change file format to 'as-is'
        $('ProtocolRow').style.display = 'table-row';
        $('ExportProtocol').selectedIndex = 0;
        update_protocol_ui(false);

        // hide export status section - we will display a link only in the SubmitResponseDiv.ExportLocation span
        $('ExportDataDiv').hide()

        // hide file-name format pulldown
        $('FilenameFmtRow').style.display = 'none';
    }
    else if (method === EXP_METH_QUICK)
    {
        disable_processing();

        // hide file-format selection option
        $('ProtocolRow').style.display = 'none';
        $('ExportProtocol').selectedIndex = 0;
        update_protocol_ui(false);

        // hide file-name format pulldown
        $('FilenameFmtRow').style.display = 'none';
    }
    else if (method === EXP_METH_FULL || method === EXP_METH_FULL_FTP || method === EXP_METH_FULL_TAR || method === EXP_METH_FULL_FTP_TAR)
    {
        // enable processing UI
        $('ProcessRow').style.display = 'table-row';

        // enable file-format selection
        $('ProtocolRow').style.display = 'table-row';

        // show file-name format pulldown
        $('FilenameFmtRow').style.display = 'table-row';

        // show export status section
        $('ExportDataDiv').show();
    }
    else
    {
        alert("Please set Method to url_quick, url_direct,  url, or ftp");
    }
}

// called when file-name format changes (onChange())
function SetExportFilenameFmt()
{
    set_eb_state_disabled(true);
    return validate_filename_format();
}

function validate_filename_format()
{
    format_valid = null;

    format_valid = ($('ExportFilenameFmt').value.trim().length > 0);
    $('ExportFilenameFmt').store({ 'valid' : format_valid });
}

// onChange() for 2 checkboxes: ProcessingCheckbox and ProcessingCheckboxHide
//
function ProcessingEnabled(element)
{
    // the user cannot uncheck ether checkbox, so the checked attribute must be true
    if (element == $('ProcessingCheckbox'))
    {
        $('ProcessingCheckboxHide').checked = false;
    }
    else
    {
        $('ProcessingCheckbox').checked = false;
    }

    update_processing_ui(false);
}

function update_processing_ui(reset)
{
    var processing_is_enabled = $('ProcessingShowCheckbox').retrieve('enabled', false);
    var apply_processing = $('ProcessingCheckbox').checked;
    var series = null;
    var option_index = null;
    var processing_option_id = null;
    var processing_option_row_id = null;

    if (reset)
    {
        // processing availability not yet determined
        $('ProcessingWaitMessage').style.display = 'table-row';
        $('ProcessingWaitMessage').innerHTML = 'Applicable processing steps not yet determined';

        // hide show processing checkbox altogether
        $('ProcessingShowCheckbox').style.display = 'none';

        $('ProcessingShowCheckbox').checked = false;
        $('ProcessingCheckboxHide').checked = true;
    }
    else
    {

    }

    if (processing_is_enabled)
    {
        // hide the not-ready-for-processing message
        $('ProcessingWaitMessage').style.display = 'none';

        if (apply_processing)
        {
            // The user clicked on the show processing checkbox (ProcessingShowCheckbox)
            if ($('ExportRecordSet').value == "" || $('ExportRecordSet').value == "[$]")
            {
                $("ProcessingWaitMessage").style.display = "table-row";
                $('ProcessingCheckbox').checked = false;
                return;
            }

            // the Enable Processing checkbox element disappears...
            $('ProcessingShowCheckbox').style.display = 'none';

            // and gets replaced by the list of processing-step checkboxes, including no_op and hide checkboxes
            $('ExportProcessing').style.display = 'table-row';

            // enable the processing step checkboxes that should be enabled
            for (option_index = 0; option_index < ExportProcessingOptions.length; option_index++)
            {
                processing_option_id = ExportProcessingOptions[option_index].id;

                if ($(processing_option_id).checked && processing_option_id !== 'OptionNone')
                {
                    processing_option_row_id = ExportProcessingOptions[option_index].rowid;
                    $(processing_option_row_id).style.display = 'table-row';
                }

                // if disabled-state metadata do not exist, then set disabled to false (the second arg to retrieve() is the default)
                $(processing_option_id).disabled = $(processing_option_id).retrieve('disabled_state', false);
            }

            // restore processing options
            $('ExportProcessing').store({ "apply_processing" : true });
        }
        else
        {
            // ignore processing
            // the user clicked on the hide (processing) checkbox (ProcessingCheckboxHide);
            $('ProcessingShowCheckbox').style.display = 'table-row';
            $('ExportProcessing').style.display = 'none';

            // need to hide each processing step row too - there is no HTML element that contains all of them
            for (option_index = 1; option_index < ExportProcessingOptions.length; option_index++)
            {
                processing_option_row_id = ExportProcessingOptions[option_index].rowid;

                // if disabled-state metadata do not exist, then set disabled to false (the second arg to retrieve() is the default)
                $(processing_option_row_id).style.display = 'none';
            }

            // ignore current set of processing options (but do not unset them)
            $('ExportProcessing').store({ "apply_processing" : false });
        }
    }
    else
    {
        // processing is disabled
        $('ProcessingWaitMessage').style.display = 'table-row';

        series = $('ExportRecordSet').retrieve('series', null);

        if (series !== null)
        {
            $('ProcessingWaitMessage').innerHTML = 'Processing not available for series ' + series;
        }
        else
        {
            $('ProcessingWaitMessage').innerHTML = 'Applicable processing steps not yet determined';
        }

        // hide show processing checkbox altogether
        $('ProcessingShowCheckbox').style.display = 'none';
    }
}


var SizeRatio;

// Called when a processing-option checkbox has changed, or the record-set query has changed.
// Make the ExportProcessingArgs string (a |-separated list of processing steps).

var setProcessingRunning = false;
var setProcessingQueue = [];

function unserialize_arguments(serialized_arguments)
{
    var name_space = null;
    var separator_index = null;
    var pairs = null;
    var property = null;
    var value = null;
    var argument_obj = null;
    var index = null;
    var pair = null;

    argument_obj = {};

    // property name is substring before first ','
    separator_index = serialized_arguments.search(/,/i);
    if (separator_index > 0)
    {
        name_space = serialized_arguments.slice(0, separator_index);
        pairs = serialized_arguments.slice(separator_index + 1).split(",");

        argument_obj[name_space] = { "unnamed" : [] };

        for (index = 0; index < pairs.length; index += 1)
        {
            pair = pairs[index];
            separator_index = pair.search(/[=]/);
            if (separator_index > 0)
            {
                argument_obj[name_space][pair.slice(0, separator_index)] = pair.slice(separator_index + 1);
            }
            else
            {
                argument_obj[name_space]['unnamed'].push(pair);
            }
        }
    }
    else
    {
        argument_obj[serialized_arguments] = {};
    }

    return argument_obj;
}

function get_max_records()
{
    var max_records = null;

    max_records = $('ExportRecordLimit').retrieve('limit', null);
    if (max_records === null)
    {
        max_records = 0;
    }

    return max_records;
}

function runSetProcessing(intervalFn, spCallback)
{
    var max_records_str = null;

    // 0 if no procesing enabled (Enable Processing is not checked),  -1 if same seriesname, -2 if series has changed between export processing requests.
    // ichecked > 0 if the user clicks on/off a processing-step checkbox.
    if (setProcessingRunning)
    {
        // do not clear interval, this will continue to run until it is safe to run the code in the rest of the function
		return;
	}

    // No alerts in here.
	setProcessingRunning = true;

    ichecked = setProcessingQueue.shift()

	if (typeof ichecked == 'undefined')
	{
		// nothing to do; should not get here because each function instance handles one SetProcessing() call
		clearInterval(intervalFn);
		setProcessingRunning = false;
		return;
	}

    if (ichecked > 0)
    {
        $(ExportProcessingOptions[0].id).checked = false; // Disable the 'none' processing step.
    }

    ExportProcessingOK = null;

    var isok = 1;
    var nchecked = 0;
    var iProc = 0;
    var nProcs = ExportProcessingOptions.length;
    SizeRatio = 1.0;

    if ($(ExportProcessingOptions[0].id).checked) // no_op case must be first
    {
        // no_op - none processing checkbox is checked
        nchecked++;
        for (iProc=1; iProc<nProcs; iProc++)
        {
            var ExpOpt = ExportProcessingOptions[iProc];
            $(ExpOpt.id).checked = false;
            $(ExpOpt.rowid).style.display = 'none';

            if (ExpOpt.id != "OptionImPatch")
            {
                ExpOpt.Init(1);
            }
        }
    }
    else
    {
        // no_op - none is NOT checked
        for (iProc=1; iProc<nProcs; iProc++)
        {
            // ExportProcessingOptions is a list of all processing options. The command to perform
            // any given option is sent to jsoc_fetch only if ExportProcessingOptions[iProc].id.checked is true.
            // So, the order of the processing steps is the order they appear in ExportProcessingOptions,
            // which is determined in ProcessingInit() in processing.js.
            var ExpOpt = ExportProcessingOptions[iProc];

            if ($(ExpOpt.id).checked)
            {
                nchecked++;
                $(ExportProcessingOptions[0].id).checked = false; // Do not send the 'none' processing option to jsoc_fetch.

                if (ichecked == -2)
                {
                    // This is the on-load case, where we want to initialize all processing parameters to their defaults.
                    ExpOpt.Init(1);
                    $(ExpOpt.rowid).style.display="table-row";
                    isok = 0;

                    // We need to run the check function for each checked option since we changed the record-set; the
                    // Check() functions always run synchronously; they return the arguments to the processing program;

                    if (ExpOpt.hasOwnProperty('Check') && ExpOpt.Check && typeof ExpOpt.Check === 'function')
                    {
                        ExpOpt.paramsValid = null; // blow-away the cache so Check() can actually do the check and generate the command-line arguments.
                        args = ExpOpt.Check(true);

                        if (args == 'error')
                        {
                            // Error that requires the checkbox to be unchecked.
                            $(ExpOpt.id).checked = false;
                            $(ExpOpt.rowid).style.display = 'none';
                            nchecked--;
                        }
                    }
                }
                else
                {
                    $(ExpOpt.rowid).style.display="table-row";
                    // This is the case where we do not want to reset the processing parameters to the default.

                    // initialize Check() function globals when the user clicks on a processing option checkbox
                    // 0 --> do not reset page, initialization could be asynchronous, Check() can modify UI
                    ExpOpt.Init(0);
                }
            }
            else
            {
                $(ExpOpt.rowid).style.display="none";

                // keep existing argument values for ImPatch only (the other processing options have no way
                // of resetting them to default values, so we have to do that here if the user has unchecked
                // the option's checkbox
                if (ExpOpt.id != "OptionImPatch")
                {
                    ExpOpt.Init(1);
                }
            }
        }

        if (nchecked > 0)
        {
            // The Set() functions can run asynchronously. We have at least one Set() function that succeeded (which means
            // there could be AJAX running).
            ExportProcessingArgsPoll = setInterval(function(){ GetExportProcessingArguments(spCallback); }, 50);

            // Disable all processing-step checkboxes, until GetExportProcessingArguments() resolves.
            for (iProc = 0; iProc < nProcs; iProc++)
            {
                var ExpOpt = ExportProcessingOptions[iProc];
                $(ExpOpt.id).store({ 'disabled_state' : $(ExpOpt.id).disabled })
                $(ExpOpt.id).disabled = true;
            }
        }
    }

    // it is possible that the aia_scale box was unchecked; in this case, we must restore the original
    // filename format (but only if it indeed was changed to one compatible with aia.lev1p5)
    var originalFormat = $('ExportFilenameFmt').retrieve('originalFormat', null);
    if (originalFormat !== null)
    {
        // the originalFormat value data has been set, so the original format was changed to one compatible with aia.levp5;
        // restore the original if the aia_scale check box is no longer checked
        if ($('OptionAiaScale').checked == false)
        {
            $('ExportFilenameFmt').value = originalFormat;
            $('ExportFilenameFmt').store({ 'valid' : true });
        }

        // blow away the args-ready state so that Check() is run the next time the user checks the aia_scale checkbox
        ExportProcessingOptions[AiaScaleOption].paramsValid = null;
    }

    if (nchecked == 0)
    {
        $(ExportProcessingOptions[0].id).checked = true; // Set no-op processing step.

        // Hide the non-no-op steps.
        for (iProc=1; iProc<nProcs; iProc++)
        {
            var ExpOpt = ExportProcessingOptions[iProc];
            $(ExpOpt.rowid).style.display = "none";
        }
    }

  $("ExportSizeRatio").value = SizeRatio;

    clearInterval(intervalFn);

    if (ExportProcessingArgsPoll)
    {
        // We don't know if export processing is OK yet.
        ExportProcessingOK = false;
        // do not clear the setProcessingRunning flag
    }
    else
    {
        if (isok)
        {
            ExportProcessingOK = true;
        }
        else
        {
            ExportProcessingOK = false;
        }

        setProcessingRunning = false;

        if (spCallback)
        {
            spCallback();
        }
    }
}
// tester success
</script>
<script type="text/javascript">


// the processing.js code defines SetProcessing as the onChange function for the top-level processing checkboxes; this
// will change export parameters, so we must set the eb dirty flag
function SetProcessing(ichecked, spCallback)
{
  	var intervalFn;

    $('ExportCheckButton').store({ "dirty" : true });
    set_eb_state_disabled(true);

  	setProcessingQueue.push(ichecked)
  	intervalFn = setInterval(function(){ runSetProcessing(intervalFn, spCallback); }, 100);
}

// Cannot determine the arguments at the time that SetProcessing() is called because there might be
// asynchronous processes running (AJAX calls) that need to complete before the arguments can be
// finalized.

// Polling function
function GetExportProcessingArguments(spCallback)
{
    var ExpOpt = null;
    var args = null;
    var iProc = 0;
    var SizeRatio = 1.0;
    var argument_argument_obj = null;
    var argument_namespace = null;
    var processing_obj = null;
    var processing_argument_str = null;

    if (!ExportProcessingArgsReady())
    {
        // Wait till all the Set() procs for each processing step have completed their asynchronous processing.
        return;
    }

    processing_obj = {};
    processing_argument_str = 'n=' + get_max_records().toString();

    for (iProc = 1; iProc < ExportProcessingOptions.length; iProc++)
    {
        ExpOpt = ExportProcessingOptions[iProc];

        if ($(ExpOpt.id).checked)
        {
            args = ExportProcessingOptions[iProc].Check(true);

            if (args === null)
            {
                // a Set() function is pending; wait until it has completed
                return;
            }

            if (args == 'error')
            {
                // Error that requires the checkbox to be unchecked.
                $(ExpOpt.id).checked = false;
                $(ExpOpt.rowid).style.display = 'none';
                continue;
            }

            // At this point, we know for sure if there is an error with the export options chosen. If so,
            // ignore that processing step, and uncheck its checkbox.
            if (args.length > 0)
            {
                processing_argument_str += '|' + args;

                argument_argument_obj = unserialize_arguments(args);
                argument_namespace = Object.keys(argument_argument_obj)[0];
                processing_obj[argument_namespace] = argument_argument_obj[argument_namespace];

                if (processing_obj[argument_namespace]['unnamed'].length > 0)
                {
                    console.log('unexpected unnamed argument processing argument provided');
                }

                delete processing_obj[argument_namespace]['unnamed'];

                SizeRatio *= ExpOpt.Size;
            }
        }

    }

    $('ExportProcessing').store({ "processing_obj" : processing_obj });

    if (Object.keys(processing_obj).length == 0)
    {
        processing_argument_str += '|no_op';
    }

    $('ExportProcessing').store({ "processing_argument_str" : processing_argument_str });

    // Re-enable all processing-step checkboxes, until GetExportProcessingArguments() resolves.
    for (iProc = 0; iProc < ExportProcessingOptions.length; iProc++)
    {
        var ExpOpt = ExportProcessingOptions[iProc];

        $(ExpOpt.id).disabled = $(ExpOpt.id).retrieve('disabled_state', false);
    }

    $("ExportSizeRatio").value = SizeRatio;

    clearInterval(ExportProcessingArgsPoll);
    ExportProcessingArgsPoll = null;
    ExportProcessingOK = true; // This means that everything that is going to modify the export arguments has completed
                               // modifying said parameters. It does NOT mean that the parameter values are acceptable.

    setProcessingRunning = false;

    if (spCallback)
    {
        spCallback();
    }
}

// called when user changes protocol (export file format) pulldown (onChange())
function SetExportProtocol(byWhom)
{
    // byWhom is 'vestigial'
    set_eb_state_disabled(true);
    update_protocol_ui(false);
}

// respond to changes in the protocol options elements (only image options at this point)
function update_protocol_options_ui(reset)
{
    // reset validation on all protocol options (only image options at this point)
    $('ProtocolImageOptions').store({ "valid" : null });
    $('ExportProtocolHidden').store({ "valid" : null });

    if (reset)
    {
        update_protocol_options(true);
        update_hidden_protocol(true);

        // the above calls imply that validate_protocol_options() will set valid to true
        validate_protocol_options();
    }
    else
    {
        update_protocol_options(false);
        if (!validate_protocol_options())
        {
            alert('invalid image options');
            // current child data are invalid; fix by calling with reset flag
            update_protocol_options(true);
        }

        update_hidden_protocol(false);
        if (!validate_hidden_protocol())
        {
            update_hidden_protocol(true);
        }
    }
}

// called when the user modifies ImageCT
function ProtocolImageUserSet(opt)
{
    // `opt` is 'vestigial'
    $('ExportCheckButton').store({ "dirty" : true });
    update_protocol_options_ui(false);
}

// called when...
// 1. initializing image options with color-table metadata
// 2. the user has clicked on the reset-defaults button
// if the user modifies the ImageCT UI element, the result is a change to the
// text elements that appear to the right of the image-option elements;
// there is no `reset` argument since this function is called only when resetting
// the options UI
function reset_image_protocol_options(record_set_series, record_set_wavelength, color_table_metadata)
{
    // use the specified wavelength to choose an appropriate color table, and then
    // use the values from the color table to set the UI element values
    var series_wave = null;
    var series_wave_map = null;
    var metadata = null;
    var image_color_table_element = $('ImageCT');
    var image_min_element = $('ImageMin');
    var image_max_element = $('ImageMax');
    var scale = null;
    var image_scale_element = $('ImageScl');
    var index = null;

    series_wave = record_set_series.trim().toLowerCase() + ':' + record_set_wavelength.toString();

    if (color_table_metadata !== null && color_table_metadata.hasOwnProperty('series_wave_map') && color_table_metadata.series_wave_map !== null)
    {
        series_wave_map = color_table_metadata.series_wave_map;
    }

    if (series_wave_map !== null)
    {
        metadata = series_wave_map[series_wave];
    }

    if (metadata === undefined)
    {
        $('ImageSer').innerHTML = '[ no colortable located for ' + record_set_series + '; unless edited, min/max will be derived from data ]';
        $('ImageCT').selectedIndex = $('ImageCT').options.length - 1;
        $('ImageMin').value = 'NOT SPECIFIED';
        $('ImageMin').store({ "specified" : false });
        $('ImageMax').value = 'NOT SPECIFIED';
        $('ImageMax').store({ "specified" : false });

        if (color_table_metadata.scale_indexes['MINMAX'] === undefined)
        {
            $('ImageScl').selectedIndex = $('ImageScl').options.length - 1;
        }
        else
        {
            $('ImageScl').selectedIndex = color_table_metadata.scale_indexes['MINMAX'];
        }
    }
    else
    {
        $('ImageSer').innerHTML = metadata['series'];
        $('ImageCT').selectedIndex = color_table_metadata.color_table_indexes[metadata['ct']];
        $('ImageMin').value = metadata['min'];
        $('ImageMin').store({ "specified" : true });
        $('ImageMax').value = metadata['max'];
        $('ImageMax').store({ "specified" : true });
        $('ImageScl').selectedIndex = color_table_metadata.scale_indexes[metadata['scaling']];
    }

    $('ImageSize').selectedIndex = 2; // 512x512 image

    update_hidden_protocol(false);

    $('ProtocolImageOptions').store({ "initialized" : true });

    set_eb_state_disabled(true);
}

function validate_image_protocol_options(series, wavelength, color_table_metadata)
{
    var protocol = $('ExportProtocol').value.trim();
    var protocol_argument = null;
    var hidden_protocol = $('ExportProtocolHidden').value.trim();
    var image_ct = null;
    var image_scaling = null;
    var image_zoom = null; // 1, 4, 8, or 16
    var image_min = null; // number or not specified
    var image_max = null; // number or not specified
    var image_list = [];
    var protocol_list = [];
    var index = null;
    var valid = null;

    if ($('ImageCT').selectedIndex != -1)
    {
        image_ct = $('ImageCT').options[$('ImageCT').selectedIndex].value.trim(); // color table, or not specified
    }
    else
    {
        image_ct = $('ImageCT').value.trim();
    }

    if ($('ImageScl').selectedIndex != -1)
    {
        image_scaling = $('ImageScl').options[$('ImageScl').selectedIndex].value.trim();
    }
    else
    {
        image_scaling = $('ImageScl').value.trim();
    }

    if ($('ImageSize').selectedIndex != -1)
    {
        image_zoom = $('ImageSize').options[$('ImageSize').selectedIndex].value.trim();
    }
    else
    {
        image_zoom = $('ImageSize').value.trim();
    }

    valid = $('ProtocolImageOptions').retrieve('valid', null);

    if (valid === null)
    {
        image_zoom = parseInt(image_zoom);

        if ($('ImageMin').retrieve('specified', false))
        {
            image_min = parseFloat($('ImageMin').value.trim());
        }

        if ($('ImageMax').retrieve('specified', false))
        {
            image_max = parseFloat($('ImageMax').value.trim());
        }

        if (image_zoom !== 'NaN' && image_zoom > 0 && image_min !== 'NaN' && image_max !== 'NaN' && image_min < image_max)
        {
            valid = true;
        }
        else
        {
            valid = false;
        }

        $('ProtocolImageOptions').store({ "valid" : valid });
    }

    return valid;
}

// called only in response to a 'reset defaults' button click; resetting image protocols only
function ProtocolImageDefaults()
{
    var record_set_series = $('ExportRecordSet').retrieve('series', null);
    var record_set_wavelength = $('ExportRecordSet').retrieve('wavelength', null);
    var color_table_metadata = $('ImageCT').retrieve('metadata', null);

    reset_image_protocol_options(record_set_series, record_set_wavelength, color_table_metadata);

    set_eb_state_disabled(true);
}

// callback is reset_image_protocol_options
function initialize_image_protocol_options(update_options_callback)
{
    var color_table_metadata = $('ImageCT').retrieve('metadata', null);
    var metadata_loaded = (color_table_metadata !== null);
    var wavelength = $('ImageCT').retrieve('wavelength', null);
    var wavelength_extracted = (wavelength !== null);
    var extract_wavelength_fn = null;
    var load_color_table_metadata_fn = null;

    extract_wavelength_fn = function(color_table_metadata, update_options_callback)
    {
        var specification = $('ExportRecordSet').value.trim();
        var export_app_arguments = null;
        var options = null;
        var db_host = null;
        var on_failure = null;

        if ($('PrivateHostElement').retrieve('is_private', false))
        {
            db_host = INTERNAL_SERVER;
        }
        else
        {
            db_host = EXTERNAL_SERVER;
        }

        // uses internal DB - that is where the color table series are stored
        export_app_arguments = { "specification" : specification, "db-host" : db_host, "keywords" : [ "WAVELNTH" ], "number-records" : 1 };

        on_failure = function(error_message, color_table_metadata)
        {
            var record_set_series = $('ExportRecordSet').retrieve('series', null);
            var record_set_wavelength = $('ExportRecordSet').retrieve('wavelength', null);

            // unlike most error cases, do not set the EB state to disabled; we basically just ignore the filling-in-of image
            // parameters with a color-table
            update_options_callback(record_set_series, record_set_wavelength, color_table_metadata);
        };

        options =
        {
            method : 'get',
            onSuccess : function(response)
            {
                var gri_response_obj = response.responseJSON;
                var error_message = null;
                var status = null;
                var record_set_series = $('ExportRecordSet').retrieve('series', null);
                var record_set_wavelength = null;
                var color_table_element = $('ImageCT');
                var color_table_metadata = $('ImageCT').retrieve('metadata', null);

                if (gri_response_obj !== null)
                {
                    status = gri_response_obj.drms_export_status;
                    if (status.search(/errorcode/i) == 0)
                    {
                        error_message = 'failure obtaining record-set information: ' + stringify_obj(gri_response_obj.error_message);
                    }
                    else
                    {
                        record_set_wavelength = Math.round(gri_response_obj.keywords[0].values[0]);
                        $('ExportRecordSet').store({ "wavelength" : record_set_wavelength })
                        update_options_callback(record_set_series, record_set_wavelength, color_table_metadata);
                    }
                }
            },
            onFailure : function(response)
            {
                var error_message = 'failure getting record-set information: ' + stringify_obj(response.responseJSON.error_message);
                var color_table_metadata = $('ImageCT').retrieve('metadata', null);

                on_failure(error_message, color_table_metadata);
            },
            on428 : function(response)
            {
                var error_message = 'invalid arguments to record-set endpoint: ' + stringify_obj(response.responseJSON.error_message);
                var color_table_metadata = $('ImageCT').retrieve('metadata', null);

                on_failure(error_message, color_table_metadata);
            }
        };

        options['parameters'] = export_app_arguments;

        new Ajax.Request(window.location.origin + RECORD_SET_PATH, options);
    };

    load_color_table_metadata_fn = function(extract_wavelength_callback, update_options_callback)
    {
        var export_app_arguments = null;
        var options = null;
        var db_host = null;
        var on_failure = null;

        if ($('PrivateHostElement').retrieve('is_private', false))
        {
            db_host = INTERNAL_SERVER;
        }
        else
        {
            db_host = EXTERNAL_SERVER;
        }

        // uses internal DB - that is where the color table series are stored
        export_app_arguments = { "specification" : "jsoc.color_table_metadata[][]", "db-host" : db_host, "keywords" : [ "Inseries", "WAVELNTH", "CT_name", "scalemin", "scalemax", "scaling" ] };

        on_failure = function(callback)
        {
            var color_table_indexes = {};
            var scale_indexes = {};
            var color_table_metadata = null;

            $('ImageCT').options[0] = new Option('none');
            color_table_indexes['none'] = 0;

            $('ImageCT').options[scale_option_index] = new Option('none');
            scale_indexes['none'] = 0;

            color_table_metadata = { "color_table_indexes" : color_table_indexes, "scale_indexes" : scale_indexes, "keywords" : null, "color_table_map" : null, "series_wave_map" : null };
            $('ImageCT').store({ "metadata" : color_table_metadata });

            if (callback !== null)
            {
                callback($('ExportRecordSet'), null, null);
            }
        };

        options =
        {
            method: 'get',
            onSuccess: function(response)
            {
                var gri_response_obj = response.responseJSON;
                var error_message = null;
                var status = null;
                var number_color_tables = null;
                var color_table_element = $('ImageCT');
                var scale_element = $('ImageScl');
                var index = null;
                var series = null;
                var wavelength = null;
                var min = null;
                var max = null;
                var color_table = null;
                var color_table_indexes = {};
                var color_table_option_index = null;
                var scale = null;
                var scale_indexes = {};
                var scale_option_index = null;
                var keywords = null;
                var color_table_metadata = null;
                var color_table_map = null;
                var series_wave_map = null;

                if (gri_response_obj !== null)
                {
                    status = gri_response_obj.drms_export_status;

                    if (status.search(/errorcode/i) == 0)
                    {
                        color_table_option_index = 0;
                        scale_option_index = 0;
                        error_message = 'no color tables found';

                        color_table_element.options[0] = new Option('none');
                        color_table_indexes['none'] = color_table_option_index;
                        color_table_option_index += 1;

                        scale_element.options[scale_option_index] = new Option('none');
                        scale_indexes['none'] = scale_option_index;
                        scale_option_index += 1;
                    }
                    else
                    {
                        number_color_tables = gri_response_obj.count;

                        if (number_color_tables == 0)
                        {
                            color_table_option_index = 0;
                            scale_option_index = 0;

                            color_table_element.options[0] = new Option('none');
                            color_table_indexes['none'] = color_table_option_index;
                            color_table_option_index += 1;

                            scale_element.options[scale_option_index] = new Option('none');
                            scale_indexes['none'] = scale_option_index;
                            scale_option_index += 1;
                        }
                        else
                        {
                            keywords = gri_response_obj.keywords;
                            color_table_option_index = 0;
                            scale_option_index = 0;
                            color_table_map = {};
                            series_wave_map = {};

                            for (index = 0; index < number_color_tables; index += 1)
                            {
                                series = keywords[0].values[index].trim();
                                wavelength = keywords[1].values[index].trim();
                                color_table = keywords[2].values[index].trim();
                                min = keywords[3].values[index].trim();
                                max = keywords[4].values[index].trim();
                                scale = keywords[5].values[index].trim();

                                if (color_table_indexes[color_table] === undefined)
                                {
                                    color_table_element.options[color_table_option_index] = new Option(color_table);
                                    color_table_indexes[color_table] = color_table_option_index;

                                    // insert into mapping
                                    color_table_map[color_table] = { "series" : series, "ct" : color_table, "min" : min, "max" : max, "scaling" : scale };

                                    color_table_option_index += 1;
                                }

                                if (scale_indexes[scale] === undefined)
                                {
                                    scale_element.options[scale_option_index] = new Option(scale);
                                    scale_indexes[scale] = scale_option_index;

                                    scale_option_index += 1;
                                }

                                // insert into mapping
                                if (series_wave_map[series + ':' + wavelength] === undefined)
                                {
                                    series_wave_map[series + ':' + wavelength] = { "series": series, "wavelength" : wavelength, "ct" : color_table, "min" : min, "max" : max, "scaling" : scale};
                                }
                            }

                            // add grey as a default
                            color_table = 'grey.sao';
                            if (color_table_indexes[color_table] === undefined)
                            {
                                color_table_element.options[color_table_option_index] = new Option(color_table);
                                color_table_indexes[color_table] = color_table_option_index;
                                color_table_option_index += 1;
                            }
                        }
                    }

                    color_table_metadata = { "color_table_indexes" : color_table_indexes, "scale_indexes" : scale_indexes, "keywords" : keywords, "color_table_map" : color_table_map, "series_wave_map" : series_wave_map };
                    color_table_element.store({ 'metadata' : color_table_metadata });
                }

                // the select lists (pull-downs) are populated; now select options and fill-in other UI elements
                // must get the value of the wavelength of the series
                return extract_wavelength_callback(color_table_metadata, update_options_callback);
            },
            onFailure: function(response)
            {
                var error_message = 'failure obtaining record-set information: ' + stringify_obj(response.responseJSON.error_message);

                on_failure(update_options_callback);
            },
            on428: function(response)
            {
                var error_message = 'invalid arguments to record-set endpoint: ' + stringify_obj(response.responseJSON.error_message);

                on_failure(update_options_callback);
            }
        };

        options['parameters'] = export_app_arguments;

        new Ajax.Request(window.location.origin + RECORD_SET_PATH, options);
    };

    if (metadata_loaded)
    {
        // asynchronous
        if (!wavelength_extracted)
        {
            extract_wavelength_fn(color_table_metadata, update_options_callback);
        }
        else
        {
            update_options_callback($('ExportRecordSet').retrieve('series', null), wavelength, color_table_metadata);
        }
    }
    else
    {
        // asynchronous
        load_color_table_metadata_fn(extract_wavelength_fn, update_options_callback);
    }
}

// update the ExportProtocol UI elements and any stored data; do not touch the protocol-specific
// options or the hidden protocol string
// reset ==> called in response to an RS change, so the disabled state is clean
function update_protocol(reset)
{
    var protocol = $('ExportProtocol').options[$('ExportProtocol').selectedIndex].value.trim().toLowerCase();

    if (reset)
    {
        // fits
        $('ExportProtocol').selectedIndex = 1;
        set_eb_state_disabled(true);
    }
    else
    {
        if (protocol === 'jpeg' || protocol === 'mpeg' || protocol === 'mp4')
        {
            // if we have not initialized the color tables, do that now
            if (!$('ProtocolImageOptions').retrieve('initialized', false))
            {
                initialize_image_protocol_options(reset_image_protocol_options);
            }
        }
    }

    // there is nothing to modify in response to a user UI edit
}

// updates both the ProtocolImageOptions and ExportProtocolHidden elements
// reset ==> called in response to RS change, so disabled state is clean
function update_protocol_options(reset)
{
    var protocol = $('ExportProtocol').options[$('ExportProtocol').selectedIndex].value.trim().toLowerCase();
    var series = $('ExportRecordSet').retrieve('series', null);
    var color_table_element = $('ImageCT');
    var color_table_metadata = color_table_element.retrieve('metadata', null);
    var wavelength = color_table_element.retrieve('wavelength', null);
    var color_table = color_table_element.options[color_table_element.selectedIndex].value.trim();
    var color_table_map = null;
    var metadata = null;

    if (reset)
    {
        // now, we need to reset the options html elements (re-populate with defaults); and if the color tables
        // have not been loaded already, we need to do that first
        if (protocol === 'as-is')
        {
            // there are no as-is-specific options to reset; as-is does not make use of the hidden protocol string
        }
        else if (protocol === 'fits')
        {
            // there are no fits-specific options to reset
        }
        if (protocol === 'jpeg' || protocol === 'mpeg' || protocol === 'mp4')
        {
            // FULL reset - re-download color table metadata
            color_table_element.store({ "metadata" : null });
            $('ExportRecordSet').store({ "wavelength" : null });
            $('ProtocolImageOptions').store({ "initialized" : null });
        }
    }
    else
    {
        // update protocol-specific UI elements
        if (protocol === 'as-is')
        {
            // there are no as-is-specific options to update; as-is does not make use of the hidden protocol string
        }
        else if (protocol === 'fits')
        {
            // there are no fits-specific options to update
        }
        if (protocol === 'jpeg' || protocol === 'mpeg' || protocol === 'mp4')
        {
            if ($('ImageMin').value.trim().length > 0)
            {
                $('ImageMin').store({ "specified" : true });
            }
            else
            {
                $('ImageMin').store({ "specified" : false });
            }

            if ($('ImageMax').value.trim().length > 0)
            {
                $('ImageMax').store({ "specified" : true });
            }
            else
            {
                $('ImageMax').store({ "specified" : false });
            }

            if (color_table_metadata !== null && color_table_metadata.color_table_map !== null)
            {
                color_table_map = color_table_metadata.color_table_map;
                metadata = color_table_map[color_table];

                if (metadata !== null)
                {
                    $('ImageCTTxt').innerHTML = metadata['series'];
                    $('ImageMinTxt').innerHTML = metadata['min'];
                    $('ImageMaxTxt').innerHTML = metadata['max'];
                    $('ImageSclTxt').innerHTML = metadata['scaling'];
                }
            }
        }
    }
}

</script>
<script type="text/javascript">

// respond to a change in the protocol pull-down (e.g., FITS --> JPEG); not responding to change in protocol options
// reset ==> called in response to RS change, so disabled state is clean
function update_protocol_ui(reset)
{
    var compression_element = $('CompressRow');
    var protocol = $('ExportProtocol').options[$('ExportProtocol').selectedIndex].value.trim().toLowerCase();

    $('ExportProtocol').store({ "valid" : null });
    $('ExportProtocolHidden').store({ "valid" : null });

    if (reset)
    {
        update_protocol(true);
        update_hidden_protocol(true);
        validate_protocol();
    }
    else
    {
        update_protocol(false);
        if (!validate_protocol())
        {
            update_protocol(true);
        }

        update_hidden_protocol(false);
        if (!validate_hidden_protocol(false))
        {
            update_hidden_protocol(true);
        }
    }

    // always hidden now
    compression_element.style.display = 'none';
    if (protocol === 'as-is' || protocol === 'fits')
    {
        $('ProtocolImageOptions').style.display = 'none';
    }
    else
    {
        $('ProtocolImageOptions').style.display = 'table-row';
    }
}
// tester success
</script>
<script type="text/javascript">



// This function gets called when the Notify field gets modified [exportdata.html only] (onChange())
function SetExportNotify(clickedByUser)
{
    var address = $("ExportNotify").value.trim();;
    var requestor = $("ExportRequestor").value.trim();
    var snail_address = null; // no UI yet
    var doValidation = true;
    var valid = false;
    var registration_callback = function()
    {
        update_export_buttons();
        check_for_cancel_enabled_shortcut();
    };

    set_eb_state_disabled(true);

    // invalidate address
    $("ExportNotify").store('valid', null);
    $("RequestorMessage").innerHTML = "Provide an optional identifier."
    $("ExportCheckMsg").store('cp_message', null);
    $("ExportNotify").store('error_msg', null);

    if (doValidation)
    {
        valid = ValidateNotificationAddress($("ExportNotify"));
        if (valid)
        {
            $("ExportNotify").store('valid', true);

            // disable the CP button since we are actively checking on the address
            update_export_buttons();

            // check_for_cancel_enabled_shortcut() - see if we can go straight to EB_STATE_CANCEL_ENABLED if
            // the user already has a request pending
            // false --> do registration
            // ART
            // register_address(address.slice(0), requestor, snail_address, $("ExportNotify"), $("ExportCheckMsg"), update_export_buttons, registration_callback);

            check_registration(address, requestor, snail_address, $("ExportNotify"), $("ExportCheckMsg"), update_export_buttons, registration_callback);
        }
    }
}

// SetExportUser is called from change in either the Requester or Notify input text boxes.
// There is no call made to check the validity of the notification email address provided
// however. Instead, the user must click on the "Check Params for Export" button.
// [register_email.html only]
// onChange()
function SetExportUser(clickedByUser)
{
    var requestor = null;
    var address = null;
    var newAddress = null;
    var valid = false;

    $('ExportCheckButton').store({ "dirty" : true });

    // invalidate requestor
    $("ExportRequestor").store('valid', null);

    requestor = $("ExportRequestor").value.trim();
    address = $("ExportNotify").value.trim();

    valid = ValidateExportRequestor($("ExportRequestor"));
    if (valid)
    {
        // used to do spd stuff
    }
}

// this function is no longer called when the user changes the compression pulldown because
// the compression row is now hidden
function SetExportCompress()
{
    $('ExportCheckButton').store({ "dirty" : true });
    update_compression_ui(false);
}

// reset ==> called in response to RS change, so disabled state is clean
function update_compression_ui(reset)
{
    var compression_row_element = $('CompressRow');
    var compression_element = $('ExportCompress');

    if (reset)
    {
        // compression is now always hidden, and always set to Rice Compression
        compression_row_element.style.display = 'none';
        compression_element.selectedIndex = 0; // Rice Compression
        compression_element.store({ "valid" : true });

        set_eb_state_disabled(true);
    }
    else
    {
        update_compression(false);
        compression_element.store({ "valid" : null});
        if (!validate_compression())
        {
            update_compression(true);
        }

        // impacts hidden protocol string too
        update_hidden_protocol(false);

        // set valid to null - compression changed, which changes the hidden protocol string
        $('ExportProtocolHidden').store({ "valid" : null});
        if (!validate_protocol_options())
        {
            update_hidden_protocol(true);
        }
    }
}

// reset ==> called in response to RS change, so disabled state is clean
function update_compression(reset)
{
    var compression_element = $('ExportCompress');
    var valid = null;

    if (reset)
    {
        // Rice compression
        compression_element.selectedIndex = 0;
        compression_element.store({ 'valid' : true });

        set_eb_state_disabled(true);
    }

    // there is nothing to modify in response to a user UI edit
}

function validate_compression()
{
    var compression_element = $('ExportCompress');
    var compression = compression_element.options[compression_element.selectedIndex].value.trim().toLowerCase();
    var valid = null;

    valid = compression_element.retrieve('valid', null);
    if (valid === null)
    {
        if (compression.length == 0 || compression === '**none**' || compression === 'compress Rice')
        {
            valid = true;
        }
        else
        {
            valid = false;
        }

        compression_element.store({ 'valid' : valid });
    }

    return valid;
}

</script>
<script type="text/javascript">

// reset ==> called in response to RS change, so disabled state is clean
function update_hidden_protocol(reset)
{
    var protocol = $('ExportProtocol').options[$('ExportProtocol').selectedIndex].value.trim().toLowerCase();
    var hidden_protocol = null;
    var image_min = null;
    var image_max = null;
    var image_ct = null;
    var image_scaling = null;
    var image_zoom = null;
    var index = null;
    var series_info = null;
    var data_type = null;
    var compression_list = [];
    var segments = null;
    var image_list = [];

    if (reset)
    {
        $('ExportProtocolHidden').value = protocol;
        set_eb_state_disabled(true);
    }
    else
    {
        if (protocol === 'fits')
        {
            // force Rice compression, except for floating-point images
            series_info = get_current_series_info();

            if (series_info !== null)
            {
                segments = (new Hash(series_info.segments)).keys();

                for (index = 0; index < segments.length; index += 1)
                {
                    data_type = series_info.segments[segments[index]]['data-type'].toLowerCase();

                    if (data_type === 'float' || data_type === 'double')
                    {
                        compression_list.push('**NONE**');
                    }
                    else
                    {
                        compression_list.push('compress Rice');
                    }
                }

                if (compression_list.length > 0)
                {
                    $('ExportProtocolHidden').value = protocol + ',' + compression_list.join(',');
                }
                else
                {
                    $('ExportProtocolHidden').value = protocol;
                }

                set_eb_state_disabled(true);
            }
        }
        else if (protocol === 'as-is')
        {
            $('ExportProtocolHidden').value = protocol;
            set_eb_state_disabled(true);
        }
        else
        {
            if (protocol === 'mpeg')
            {
                hidden_protocol = 'mpg';
            }
            else if (protocol === 'mp4')
            {
                hidden_protocol === 'mp4';
            }
            else if (protocol === 'jpeg')
            {
                hidden_protocol = 'jpg';
            }

            if (hidden_protocol !== null)
            {
                if ($('ImageCT').selectedIndex != -1)
                {
                    image_ct = $('ImageCT').options[$('ImageCT').selectedIndex].value.trim(); // color table, or not specified
                }
                else
                {
                    image_ct = $('ImageCT').value.trim();
                }

                if ($('ImageScl').selectedIndex != -1)
                {
                    image_scaling = $('ImageScl').options[$('ImageScl').selectedIndex].value.trim(); // color table, or not specified
                }
                else
                {
                    image_scaling = $('ImageScl').value.trim();
                }

                if ($('ImageSize').selectedIndex != -1)
                {
                    image_zoom = $('ImageSize').options[$('ImageSize').selectedIndex].value.trim(); // color table, or not specified
                }
                else
                {
                    image_zoom = $('ImageSize').value.trim();
                }

                if ($('ImageMin').retrieve('specified', false))
                {
                    image_min = parseFloat($('ImageMin').value.trim());
                    image_list.push('min=' + image_min.toString());
                }

                if ($('ImageMax').retrieve('specified', false))
                {
                    image_max = parseFloat($('ImageMax').value.trim());
                    image_list.push('max=' + image_max.toString());
                }

                image_list.push('CT=' + image_ct);

                image_list.push('scaling=' + image_scaling);

                image_list.push('size=' + image_zoom.toString());

                $('ExportProtocolHidden').value = hidden_protocol;

                if (image_list.length > 0)
                {
                    $('ExportProtocolHidden').value = hidden_protocol + ',' + image_list.join(',');
                }
                else
                {
                    $('ExportProtocolHidden').value = hidden_protocol;
                }

                set_eb_state_disabled(true);
            }
        }
    }

    return $('ExportProtocolHidden').value;
}


</script>
<script type="text/javascript">

function validate_protocol()
{
    var protocol = $('ExportProtocol').options[$('ExportProtocol').selectedIndex].value.trim().toLowerCase();
    var valid = null;

    valid = $('ExportProtocol').retrieve('valid', null);

    if (valid === null)
    {
        if (protocol === 'as-is' || protocol === 'fits' || protocol === 'jpeg' || protocol === 'mpeg' || protocol === 'mp4')
        {
            valid = true;
        }
        else
        {
            valid = false;
        }

        $('ExportProtocol').store({ 'valid' : valid });
    }

    return valid;
}

</script>
<script type="text/javascript">

function validate_hidden_protocol()
{
    var hidden_protocol = null;
    var protocol_list = null;
    var protocol = null;
    var series_info = null;
    var data_type = null;
    var compression_list = null;
    var segments = null;
    var image_list = null;
    var image_ct = null;
    var image_scaling = null;
    var image_zoom = null;
    var protocol_argument = null;
    var index = null;
    var valid = null;

    valid = $('ExportProtocolHidden').retrieve('valid', null);

    if (valid === null)
    {
        hidden_protocol = $('ExportProtocolHidden').value.trim();
        protocol = $('ExportProtocol').options[$('ExportProtocol').selectedIndex].value.trim().toLowerCase();

        if (hidden_protocol.length == 0)
        {
            if (protocol === 'fits')
            {
                valid = false;
            }
            else if (protocol === 'jpeg' || protocol === 'mpeg' || protocol === 'mp4')
            {
                valid = false;
            }
            else
            {
                // should have 'as-is' at least
                valid = false;
            }
        }
        else
        {
            protocol_list = hidden_protocol.split(',');

            if (protocol === 'fits')
            {
                series_info = get_current_series_info();

                if (series_info === null)
                {
                    valid = false;
                }
                else
                {
                    compression_list = ['fits'];
                    segments = (new Hash(series_info.segments)).keys();

                    for (index = 0; index < segments.length; index += 1)
                    {
                        data_type = series_info.segments[segments[index]]['data-type'].trim().toLowerCase();

                        if (data_type === 'float' || data_type === 'double')
                        {
                            compression_list.push('**NONE**');
                        }
                        else
                        {
                            compression_list.push('compress Rice');
                        }
                    }

                    if (compression_list.length == protocol_list.length)
                    {
                        valid = true;
                        for (index = 0; index < protocol_list.length; index += 1)
                        {
                            if (compression_list[index].trim() != protocol_list[index].trim())
                            {
                                valid = false;
                                break;
                            }
                        }
                    }
                    else
                    {
                        valid = false;
                    }
                }
            }
            else if (protocol === 'jpeg' || protocol === 'mpeg' || protocol === 'mp4')
            {
                protocol_list.sort();
                image_list = [];

                if (protocol === 'mpeg')
                {
                    protocol_argument = 'mpg';
                }
                else if (protocol === 'mp4')
                {
                    protocol_argument = 'mp4';
                }
                else if (protocol === 'jpeg')
                {
                    protocol_argument = 'jpg';
                }

                if (protocol_argument !== null)
                {
                    image_list.push(protocol_argument);

                    if ($('ImageMin').retrieve('specified', false))
                    {
                        image_list.push('min=' + parseFloat($('ImageMin').value.trim()).toString());
                    }

                    if ($('ImageMax').retrieve('specified', false))
                    {
                        image_list.push('max=' + parseFloat($('ImageMax').value.trim()).toString());
                    }

                    if ($('ImageCT').selectedIndex != -1)
                    {
                        image_ct = $('ImageCT').options[$('ImageCT').selectedIndex].value.trim(); // color table, or not specified
                    }
                    else
                    {
                        image_ct = $('ImageCT').value.trim();
                    }

                    if ($('ImageScl').selectedIndex != -1)
                    {
                        image_scaling = $('ImageScl').options[$('ImageScl').selectedIndex].value.trim(); // color table, or not specified
                    }
                    else
                    {
                        image_scaling = $('ImageScl').value.trim();
                    }

                    if ($('ImageSize').selectedIndex != -1)
                    {
                        image_zoom = $('ImageSize').options[$('ImageSize').selectedIndex].value.trim(); // color table, or not specified
                    }
                    else
                    {
                        image_zoom = $('ImageSize').value.trim();
                    }


                    image_list.push('CT=' + image_ct);
                    image_list.push('scaling=' + image_scaling);
                    image_list.push('size=' + parseFloat(image_zoom).toString());

                    image_list.sort();
                }

                if (image_list.length == protocol_list.length)
                {
                    valid = true;
                    for (index = 0; index < protocol_list.length; index += 1)
                    {
                        if (image_list[index].trim() != protocol_list[index].trim())
                        {
                            valid = false;
                            break;
                        }
                    }
                }
                else
                {
                    valid = false;
                }
            }
            else
            {
                // should be no arguments (no comma-sep list after protocol); as-is used to have arguments, but they were never used
                if (hidden_protocol.indexOf(',') == -1)
                {
                    valid = true;
                }
                else
                {
                    valid = false;
                }
            }
        }

        $('ExportProtocolHidden').store({ "valid": valid });
    }

    return valid;
}

function validate_fits_protocol_options()
{
    return true;
}

function validate_as_is_protocol_options()
{
    return true;
}

function validate_protocol_options()
{
    var protocol = $('ExportProtocol').options[$('ExportProtocol').selectedIndex].value.trim().toLowerCase();
    var valid = null;

    if (protocol === 'fits')
    {
        valid = validate_fits_protocol_options();
    }
    else if (protocol === 'jpeg' || protocol === 'mpeg' || protocol === 'mp4')
    {
        valid = $('ProtocolImageOptions').retrieve('valid', null);
        if (valid === null)
        {
            valid = validate_image_protocol_options();
            $('ProtocolImageOptions').store({ "valid" : valid });
        }
    }
    else
    {
        valid = validate_as_is_protocol_options();
    }

    return valid;
}

function get_current_series_info()
{
    var record_set_element = $('ExportRecordSet');
    var series = record_set_element.retrieve('series', null);
    var series_cache = record_set_element.retrieve('series_cache', {});
    var info = null;

    if (series !== null && series_cache !== null)
    {
        info = series_cache[series.toLowerCase()];
    }

    return info;
}

function validate_fits_protocol_options()
{
    var series_info = null;
    var index = null;
    var data_type = null;
    var compression_list = [];
    var segments = null;

    series_info = get_current_series_info();

    if (series_info === null)
    {
        valid = false;
    }
    else
    {
        segments = (new Hash(series_info.segments)).keys();
        for (index = 0; index < segments.length; index += 1)
        {
            data_type = series_info.segments[segments[index]]['data-type'].trim().toLowerCase();

            if (data_type === 'float' || data_type === 'double')
            {
                compression_list.push('**NONE**');
            }
            else
            {
                compression_list.push('compress Rice');
            }
        }
    }

    if (compression_list.length > 0)
    {
        if (hidden_protocol.indexOf(compression_list.join(',')) == -1)
        {
            valid = false;
        }
        else
        {
            valid = true;
        }
    }
    else
    {
        // no segments
        valid = true;
    }

    return valid;
}

// Notify and Requestor checking is now in the email registration js script.

function ExportShowQuery()
{
    var args = null;
    var paramString = null;
    var ignore_processing = !$('ExportProcessing').retrieve('apply_processing', false);
    var processing_as_obj = null;

    if ($("ShowQueryCheckbox").checked)
    {
        args = $('ExportRecordSet').retrieve('exportArgs', null);

        if (ignore_processing)
        {
            processing_as_obj = new Hash(args);
            processing_as_obj.update({ "process" : 'n=' + get_max_records().toString() + '|no_op' });
            args = processing_as_obj.toObject();
        }

        if (args != null)
        {
            paramString = decodeURIComponent(Object.toQueryString(args));
            if (paramString)
            {
                $("ExportParameters").innerHTML = paramString.replace(/&/g,"&amp;");
            }
        }
    }
    else
    {
        $("ExportParameters").innerHTML = "";
    }
}
// tester success
</script>
<script type="text/javascript">


function disable_input()
{
    $("FileUploadCheckbox").disabled = true;
    $('ExportRecordSet').disabled = true;
    $('ExportRecordLimit').disabled = true;
    $("CountButton").disabled = true;
    $("ExportMethod").disabled = true;
    $('ExportFilenameFmt').disabled = true;
    $('ProcessingCheckbox').disabled = true;
    $('ExportProtocol').disabled = true;
    $("ExportNotify").disabled = true;
}

function enable_input(address_too)
{
    $("FileUploadCheckbox").disabled = false;
    $('ExportRecordSet').disabled = false;
    $('ExportRecordLimit').disabled = false;
    $("CountButton").disabled = false;
    $("ExportMethod").disabled = false;
    $('ExportFilenameFmt').disabled = false;
    $('ProcessingCheckbox').disabled = false;
    $('ExportProtocol').disabled = false;
    if (address_too)
    {
        $("ExportNotify").disabled = false;
    }
}

function set_eb_state_disabled(make_dirty)
{
    var state = null;
    var interval_fn_timer = null;
    var interval_fn_timeout = null;

    if (make_dirty)
    {
        // do not allow the user to change email address at this point (do that on reload)
        $("ExportCheckButton").store({ 'dirty' : true });
    }
    else
    {
        $("ExportCheckButton").store({ 'dirty' : false });
    }

    // the only acceptable states are EB_STATE_DISABLED, EB_STATE_SUBMIT_ENABLED, EB_STATE_PATH, EB_STATE_CANCEL
    state = $("ExportButton").retrieve('state', EB_STATE_DISABLED);

    if (state == EB_STATE_DISABLED)
    {

    }
    else if (state == EB_STATE_SUBMIT_ENABLED || state == EB_STATE_PATH || state == EB_STATE_CANCEL || state == EB_STATE_CANCELED || state == EB_STATE_TIMEOUT)
    {
        // EB_STATE_SUBMIT_ENABLED - user wants to change input instead of clicking on `submit`
        // EB_STATE_PATH - export request complete, time to reset for the next request
        // EB_STATE_CANCEL - user clicked on `cancel` button, and the export request was canceled
        // EB_STATE_CANCELED - user clicked on `continue` button, and the canceled export request was cleared
        // EB_STATE_TIMEOUT - the export button interval function ran for too long without user intervention,
        //                    (like clicking on the button)

        // clear interval
        interval_fn_timer = $("ExportButton").retrieve('interval', null);
        if (interval_fn_timer !== null)
        {
            clearInterval(interval_fn_timer);
            $("ExportButton").store('interval', null);
        }

        interval_fn_timeout = $("ExportButton").retrieve('interval_timeout', null);;
        if (interval_fn_timeout !== null)
        {
            clearTimeout(interval_fn_timeout);
            $("ExportButton").store('interval_timeout', null);
        }

        $("ExportButton").store('state', EB_STATE_DISABLED);
        // $("ExportCheckMsg").store({ 'cp_message' : '' });
        $("ExportCheckMsg").store('cp_message', null);
    }
    else
    {
        $("ExportCheckMsg").store({ 'cp_message' : 'Cannot change input while state is ' + state });
    }

    update_export_buttons();
}
// tester success
</script>
<script type="text/javascript">

function address_is_registered()
{
    var address = $('ExportNotify').value.trim();
    var addresses = $('ExportNotify').retrieve('addresses', {});
    var registration_status = null;

    if (addresses !== null && address.length > 0 && addresses.hasOwnProperty(address) && addresses[address].hasOwnProperty('registration_status'))
    {
        registration_status = addresses[address].registration_status;
    }

    return ((registration_status !== null && (typeof(registration_status) === 'boolean') && registration_status) ? true : false);
}

// update label, color, disabled
function update_export_buttons()
{
    var state = $("ExportButton").retrieve('state', EB_STATE_DISABLED);
    var check_message = $("ExportCheckMsg").retrieve('cp_message', null);
    var addresses = $("ExportNotify").retrieve('addresses', {});
    var address = $("ExportNotify").value.trim();
    var address_valid = null;
    var requestor = $("ExportRequestor").value.trim();
    var requestor_valid = null;
    var error_msg = $("ExportNotify").retrieve('error_msg', null);
    var registration_status = null;
    var checking_registration = null;
    var registration_pending = null;
    var address_registered = null;
    var eb_dirty = $("ExportCheckButton").retrieve('dirty', false); // dirty == false ==> page was reset
    var button_label = null;
    var button_message = null;
    var disabled_check_button_color = null;

    button_label = $('ExportButton').retrieve('label', null);
    button_message = $('ExportButtonMsg').retrieve('message', null);

    if (state == EB_STATE_DISABLED)
    {
        $('ExportButton').store({ "ajax-state" : "pre-click"});

        if (addresses !== null && address.length > 0 && Object.prototype.hasOwnProperty.call(addresses, address) && Object.prototype.hasOwnProperty.call(addresses[address], 'registration_status'))
        {
            registration_status = addresses[address].registration_status;
        }

        if (address.length > 0)
        {
            // after ValidateNotificationAddress(), `valid` element attribute is always set
            address_valid = ($("ExportNotify").retrieve('valid', null) === null) ? ValidateNotificationAddress($("ExportNotify")) : $("ExportNotify").retrieve('valid', false);
        }

        if (requestor.length > 0)
        {
            // after ValidateExportRequestor(), `valid` element attribute is always set
            requestor_valid = ($("ExportRequestor").retrieve('valid', null) === null) ? ValidateExportRequestor($("ExportRequestor")) : $("ExportRequestor").retrieve('valid', false);
        }

        if (address.length > 0 && !address_valid)
        {
            check_message = error_msg;
        }
        else if (requestor.length > 0 && !requestor_valid)
        {
            check_message = requestor_error_msg;
        }

        checking_registration = (registration_status == 'checking') ? true : false
        registration_pending = (registration_status == 'registering' || registration_status == 'pending') ? true : false;
        address_registered = (registration_status !== null && (typeof(registration_status) === 'boolean') && registration_status) ? true : false;

        if ($("ExportCheckButton").retrieve('on_demand', null))
        {
            // on_demand pending-request check happening
            // auto-checking for pending-request to allow user to cancel it before entering a new record-set
            disabled_check_button_color = colorYellow;

            $("ExportCheckMsg").style.color = colorRealRed;
            $("ExportNotify").disabled = true;
            $("ExportRequestor").disabled = true;

            if (check_message === null)
            {
                check_message = 'Checking for pending request...';
            }
            $("ExportCheckMsg").innerHTML = check_message;
        }
        else
        {
            // no on-demand registration check happening; a user-requested export could be happening, or no address registration/check
            // happening at all (could have completed already, or there never has been one)
            $("ExportCheckButton").style.backgroundColor = colorPreset;
            $("ExportCheckButton").value = address_registered ? 'check parameters' : 'register address';

            if (!address_valid && address.length > 0)
            {
                disabled_check_button_color = colorPreset;
                $("ExportNotify").disabled = false;
            }
            else if (!requestor_valid && requestor.length > 0)
            {
                disabled_check_button_color = colorPreset;
                $("ExportRequestor").disabled = false;
            }
            else if ((registration_status !== null && (typeof(registration_status) != 'boolean')) || (error_msg !== null && error_msg.length > 0))
            {
                // an error other than invalid address or requestor syntax
                disabled_check_button_color = colorPreset;
                $("ExportNotify").disabled = true;
                $("ExportRequestor").disabled = true;

                if (!registration_pending && !checking_registration)
                {
                    $("ExportNotify").disabled = false;
                    $("ExportNotifyMsg").innerHTML = "REGISTRATION FAILURE";
                }
            }
            else
            {
                // no error
                if (registration_pending || checking_registration)
                {
                    disabled_check_button_color = colorYellow;
                    $("ExportNotify").disabled = true;
                    $("ExportRequestor").disabled = true;
                    $("ExportNotifyMsg").style.color = colorDarkBlue;

                    if (registration_pending)
                    {
                        $("ExportNotifyMsg").innerHTML = "registering...";
                    }
                    else
                    {
                        $("ExportNotifyMsg").innerHTML = "checking...";
                    }
                }
                else
                {
                    if ($('ExportRecordSet').value.length == 0 || $('ExportRecordSet').retrieve('count', null) === null)
                    {
                        disabled_check_button_color = colorPreset;
                    }
                    else
                    {
                        disabled_check_button_color = null;
                    }

                    if (address_registered)
                    {
                        $("ExportNotify").disabled = true;
                        $("ExportRequestor").disabled = true;
                    }
                    else
                    {
                      $("ExportNotify").disabled = false;
                      $("ExportRequestor").disabled = false;
                    }
                }
            }

            if (disabled_check_button_color !== null)
            {
                $('ExportCheckButton').disabled = true;
                $('ExportCheckButton').style.value = disabled_check_button_color === colorYellow ? 'wait...' : (address_registered ? 'check parameters' : 'register address');
                $('ExportCheckButton').style.color = null;
                $('ExportCheckButton').style.backgroundColor = disabled_check_button_color;
            }
            else
            {
                $('ExportCheckButton').disabled = false;
                $('ExportCheckButton').style.value = address_registered ? 'check parameters' : 'register address';
                $('ExportCheckButton').style.backgroundColor = colorDarkGreen;
                $('ExportCheckButton').style.color = colorWhite;
            }

            $("ExportCheckMsg").style.color = colorRealRed;
            if (check_message === null)
            {
                if (!address_registered)
                {
                    if (address.length == 0)
                    {
                        check_message = 'Please enter an email address in the Notify text box';
                    }
                    else
                    {
                        check_message = 'Click to register email address';
                    }
                }
                else if ($('ExportRecordSet').value.length == 0)
                {
                    check_message = 'Please enter a record-set specification';
                }
                else
                {
                    check_message = 'Click to check export parameters and continue';
                }
            }
            $("ExportCheckMsg").innerHTML = check_message;
        }

        $('ExportButton').style.color = null;
        $('ExportButton').style.backgroundColor = colorPreset;
        $('ExportButton').value = 'submit';
        $('ExportButton').disabled = true;
        $('ExportButtonMsg').style.color = colorBlack;

        if ($('RequestIdPlace').innerHTML.length == 0)
        {
            $("ExportButtonMsg").innerHTML = 'Click on "check parameters" first';
        }
        else
        {
            // still finishing a previous export request
            $("ExportButtonMsg").style.color = colorRealRed;
            $("ExportButtonMsg").innerHTML = "Fetch data from the URLs below before starting a new request";
        }

        // check for registration complete
        if (registration_status !== null)
        {
            if (typeof(registration_status) == 'boolean')
            {
                if (registration_status)
                {
                    $("ExportNotifyMsg").style.color = colorDarkGreen;
                    $("ExportNotifyMsg").innerHTML = "REGISTERED";
                    $("ExportNotify").disabled = true;
                    $("ExportRequestor").disabled = true;
                }
                else
                {
                    $("ExportNotifyMsg").style.color = colorDarkRed;
                    $("ExportNotifyMsg").innerHTML = "UNREGISTERED";
                    $("ExportNotify").disabled = false;
                    $("ExportRequestor").disabled = false;
                }
            }
            else if (registration_pending)
            {
                $("ExportNotifyMsg").style.color = colorDarkBlue;
                $("ExportNotify").disabled = true;
                $("ExportRequestor").disabled = true;
                $("ExportNotifyMsg").innerHTML = "registering...";
            }
        }

        enable_input(!eb_dirty && !address_registered);
    }
    else if (state == EB_STATE_ENABLED)
    {
        $('ExportCheckButton').style.backgroundColor = colorPreset;
        $('ExportCheckButton').style.color = null;
        $('ExportCheckButton').disabled = true;

        $('ExportCheckMsg').style.color = colorBlack;
        if (check_message === null)
        {
            check_message = '';
        }
        $('ExportCheckMsg').innerHTML = check_message;

        $('ExportButton').value = 'wait...';
        $('ExportButtonMsg').innerHTML = '';

        // the user has already selected all the export parameters; don't allow them to change them
        disable_input();
    }
    else if (state == EB_STATE_SUBMIT_ENABLED)
    {
        $('ExportButton').style.backgroundColor = colorDarkGreen;
        $('ExportButton').style.color = colorWhite;
        $('ExportButton').value = 'submit';
        $('ExportButton').disabled = false;
        $("ExportButtonMsg").style.color = colorRealRed;
        $("ExportButtonMsg").innerHTML = 'Click to submit export request (or modify input to cancel submission)';

        // allow the user to change the record set (but not the email address)
        enable_input();
    }
    else if (state == EB_STATE_SUBMIT)
    {
        if ($('ExportButton').retrieve('error', false))
        {
            $('ExportButton').value = (button_label !== null) ? button_label : 'submit';
            $('ExportButton').style.backgroundColor = colorPreset;

            $('ExportButtonMsg').innerHTML = (button_message !== null) ? button_message : 'Failure initiating export request';
        }
        else
        {
            $('ExportButton').value = (button_label !== null) ? button_label : 'wait...';
            $('ExportButton').style.backgroundColor = colorYellow;
            $('ExportButtonMsg').innerHTML = (button_message !== null) ? button_message : '';
        }

        $('ExportButton').style.color = null;
        $('ExportButton').disabled = true;

        disable_input();
    }
    else if (state == EB_STATE_CANCEL_ENABLED)
    {
        $('ExportButton').style.backgroundColor = colorGreen;

        if ($('ExportButton').retrieve('error', false))
        {
            $('ExportButton').value = (button_label !== null) ? button_label : 'submit';
            $('ExportButton').style.backgroundColor = colorPreset;
            $('ExportButton').style.color = null;
            $('ExportButton').disabled = true;

            $('ExportButtonMsg').innerHTML = (button_message !== null) ? button_message : 'Failure initiating export request';
        }
        else
        {
            $('ExportButton').value = (button_label !== null) ? button_label : 'cancel';
            $('ExportButton').style.backgroundColor = colorDarkGreen;
            $('ExportButton').style.color = colorWhite;
            $('ExportButton').disabled = false;

            $('ExportButtonMsg').innerHTML = (button_message !== null) ? button_message : 'Click to cancel pending export';
        }

        $("ExportButtonMsg").style.color = colorRealRed;

        disable_input();
    }
    else if (state == EB_STATE_PATH)
    {
        if ($('ExportButton').retrieve('error', false))
        {
            $('ExportButton').value = (button_label !== null) ? button_label : 'submit';
            $('ExportButton').style.backgroundColor = colorPreset;
            $('ExportButton').style.color = null;
            $('ExportButton').disabled = true;

            $('ExportButtonMsg').innerHTML = (button_message !== null) ? button_message : 'Failure exporting data';
        }
        else
        {
            $('ExportButton').value = (button_label !== null) ? button_label : 'new export';
            $('ExportButton').style.backgroundColor = colorDarkGreen;
            $('ExportButton').style.color = colorWhite;
            $('ExportButton').disabled = false;

            $('ExportButtonMsg').innerHTML = (button_message !== null) ? button_message : 'Export is complete; click to initiate new export';
        }

        disable_input();
    }
    else if (state == EB_STATE_CANCEL)
    {
        // user clicked cancel
        if ($('ExportButton').retrieve('error', false))
        {
            $('ExportButton').value = (button_label !== null) ? button_label : 'cancel';
            $('ExportButton').style.backgroundColor = colorPreset;
            $('ExportButton').style.color = null;

            $('ExportButtonMsg').innerHTML = (button_message !== null) ? button_message : 'Failure canceling export';
        }
        else
        {
            $('ExportButton').value = (button_label !== null) ? button_label : 'wait...';
            $('ExportButton').style.backgroundColor = colorYellow;

            $('ExportButtonMsg').innerHTML = (button_message !== null) ? button_message : 'cancelling export';
        }

        $('ExportButton').disabled = true;

        disable_input();
    }
    else if (state == EB_STATE_CANCELED)
    {
        // export was successfully canceled
        $('ExportButton').value = (button_label !== null) ? button_label : 'new export';
        $('ExportButton').style.backgroundColor = colorDarkGreen;
        $('ExportButton').style.color = colorWhite;
        $('ExportButton').disabled = false;

        if ($('ExportButton').retrieve('error', false))
        {
            $('ExportButtonMsg').innerHTML = (button_message !== null) ? button_message : 'Unable to proceed';
        }
        else
        {
            $('ExportButtonMsg').innerHTML = (button_message !== null) ? button_message : 'Export request canceled; click to continue';
        }
    }
}

// tester success
</script>
<script type="text/javascript">

// returns boolean now
function is_ok_to_submit(element, attribute)
{
    var return_messages = false;
    var is_ok = true;
    var address = null;
    var message = null;
    var protocol = null;

    if (element && element !== undefined && attribute && attribute !== undefined)
    {
        return_messages = true;
    }

    if (!NotificationAddressRegistered($('ExportNotify')))
    {
        address = $('ExportNotify').value.trim();
        if (address.length > 0)
        {
            message = 'Email address ' + address + ' is not registered';
        }
        else
        {
            message = 'Please enter email address';
        }

        is_ok = false;
    }

    if (is_ok)
    {
        if (!$('ExportRecordSet').retrieve('valid', false))
        {
            message = 'Please enter valid record-set specification';
            is_ok = false;
        }
    }

    if (is_ok)
    {
        if (!$('ExportMethod').retrieve('valid', false))
        {
            message = 'Please select export method';
            is_ok = false;
        }
    }

    if (is_ok)
    {
        if (!$('ExportFilenameFmt').retrieve('valid', false))
        {
            message = 'Please enter file-name format string';
            is_ok = false;
        }
    }

    if (is_ok)
    {
        if (!$('ExportProtocol').retrieve('valid', false))
        {
            message = 'Please select export protocol';
            is_ok = false;
        }
    }

    if (is_ok)
    {
        if (!$('ExportProtocolHidden').retrieve('valid', false))
        {
            message = 'Internal error: hidden protocol string not set';
            is_ok = false;
        }
    }

    if (is_ok)
    {
        if ($('ProcessingCheckbox').checked && (!ExportProcessingOK || !ProcessingOK()))
        {
            message = 'Processing details not correct, fix and retry export request';
            is_ok = false;
        }
    }

    if (return_messages)
    {
        element.store(attribute, message);
    }

    return is_ok;
}

function check_for_cancel_enabled_shortcut(callback)
{
    // this is an asyncrhonous check, so we need to have the CP button "wait..." while the check occurs
    // and then call this function back after completion; on_demand attribute:
    //   null/false --> no on_demand check occurring
    //   true --> on_demand check in progress
    if ($("ExportNotify").value.trim().length > 0 && !$("ExportCheckButton").retrieve('on_demand', null))
    {
        // not currently checking pending-user status (on_demand check); and
        // not making an interval check either since the CP button is disabled while that is occuring
        $("ExportCheckButton").store({ 'on_demand' : true });
        update_export_buttons();

        // most likely the email check is already done at this point, but if not, then ...
        // 1. if the email XHR has already begun, then the callback will be repeatedly called
        //    until resolution and caching of the registation status in $("ExportNotify").retrieve('addresses', {});
        // 2. if the email XHR has not already begun (not likely), then it will be started and then the
        //    callback will be executed as in 1.
        //
        // either way, call NotificationAddressRegistered() in the callback until we get an answer, at which point
        // we can then branch to code that either:
        // 1. sets the EB state to EB_STATE_CANCEL_ENABLED (if the email is registered and there is a pending update); we
        //    need to always check the record-set spec - if it is present, then do not change the EB state
        // 2. do not change EB state (the email is not registered - the user will see a message asking them to register one)

        // check for registered email address, then pending user request

        var check_registered_callback_fn = function()
        {
            var address = $("ExportNotify").value.trim();
            var addresses = null;
            var registration_status = null;
            var registered = null;
            var error_msg = null;

            if (!$("ExportCheckButton").retrieve('on_demand', null))
            {
                // we are done, but the callback is still being called by the email-check code
                update_export_buttons();

                // need to enable status button if a registered email address exists
                update_status_section_ui(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
                return;
            }

            // email address is valid, but is it registered?
            addresses = $("ExportNotify").retrieve('addresses', {});

            if (addresses && addresses.hasOwnProperty(address))
            {
                registration_status = addresses[address].registration_status;
                if (typeof(registration_status) === 'string')
                {
                    if (registration_status == 'registering' || registration_status == 'pending')
                    {
                        registered = null;
                    }
                    else if (registration_status == 'timed_out_server')
                    {
                        // registration process timeout (not timeout due to no response from AJAX call)
                        registered = false;
                        error_msg = $("ExportNotify").retrieve('error_msg', null);
                        $("ExportCheckMsg").store('cp_message', error_msg);
                    }
                    else if (registration_status == 'timed_out_client')
                    {
                        // registration process timeout (client did not respond to email in time)
                        registered = false;
                        error_msg = $("ExportNotify").retrieve('error_msg', null);
                        $("ExportCheckMsg").store('cp_message', error_msg);
                    }
                    else if (registration_status == 'error')
                    {
                        registered = false;
                        error_msg = $("ExportNotify").retrieve('error_msg', null);
                        $("ExportCheckMsg").store('cp_message', error_msg);
                    }
                    else
                    {
                        registered = false;
                        $("ExportCheckMsg").store('cp_message', 'Invalid registration status ' + registration_status);
                    }
                }
                else if (typeof(registration_status) === 'boolean')
                {
                    $("ExportCheckMsg").store('cp_message', null);
                    $("ExportNotify").store('error_msg', null);
                    registered = registration_status;
                }
                else
                {
                    registered = false;
                }
            }
            else
            {
                // unless there is some error, eventually addresses will be set
                registered = null;
            }

            update_export_buttons();
            // need to enable status button if a registered email address exists
            update_status_section_ui(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);

            if (registered !== null)
            {
                // we have an answer (email-registration check is no longer pending)
                if (registered)
                {
                    // now we can check for pending request (on_demand - not interval)
                    var check_pending_fn = CHECK_FOR_PENDING_REQUEST(false);

                    // finally, if the user has a pending request, then we can set up the
                    // normal interval function, starting with EB state EB_STATE_CANCEL_ENABLED
                    var update_state_callback_fn = function()
                    {
                        var state = null;
                        var internal_fn = null;
                        var interval_fn_timer = null;
                        var interval_fn_timeout = null;

                        // we're done performing an on_demand for a pending request
                        $("ExportCheckButton").store({ 'on_demand' : false });

                        state = $("ExportButton").retrieve('state', EB_STATE_DISABLED);;

                        // set-up interval function only if there was in fact a pending request
                        // (which is indicated by the EB state)
                        if (state == EB_STATE_CANCEL_ENABLED)
                        {
                            interval_fn_timer = $("ExportButton").retrieve('interval', null);
                            if (interval_fn_timer === null)
                            {
                                internal_fn = CHECK_FOR_PENDING_REQUEST(true);
                                interval_fn_timer = setInterval(internal_fn, 1000);
                                $("ExportButton").store('interval', interval_fn_timer);
                            }

                            // do not allow the pending-request check to last forever (EB is in EB_STATE_CANCEL_ENABLED)
                            if (interval_fn_timeout !== null)
                            {
                                clearTimeout(interval_fn_timeout);
                            }

                            if (interval_fn_timer !== null)
                            {
                                interval_fn_timeout = setTimeout(function () { $("ExportButton").store('state', EB_STATE_TIMEOUT); set_eb_state_disabled(true);}, 10000);
                                $("ExportButton").store('interval_timeout', interval_fn_timeout);
                            }
                        }
                        else
                        {
                            // tell user to provide record-set specification; this is the normal
                            // behavior that the CP function performs
                        }

                        update_export_buttons();
                        if (callback !== null)
                        {
                            callback();
                        }
                    };

                    check_pending_fn(update_state_callback_fn);
                }
                else
                {
                    // we're done - the user is not registered, or an error occurred, so we can't check for a pending request
                    $("ExportCheckButton").store({ 'on_demand' : false });
                    update_export_buttons();
                }
            }

            if (callback !== null)
            {
                callback();
            }
        };

        update_export_buttons();
        startEmailCheck($("ExportNotify"), $("ExportRequestor"), $("ExportCheckMsg"), update_export_buttons, check_registered_callback_fn);
    }
}

// tester success
</script>
<script type="text/javascript">


// This function is called when the user clicks on the "Check Params for Export"
// button.
// A lot of the calls in this function are asynchronous.
function CheckExportButtonOnClickAction()
{
    var isOK = null;
    var record_count = null;
    var file_upload = null;

    record_count = $('ExportRecordSet').retrieve('count', null);
    file_upload = $('ExportRecordSet').retrieve('file_upload', false);

    // complete the SetProcessing part of this check
    // If there was an error in the processing options, then ExportProcessingOK is not true.
    // ProcessingOK() is synchronous.
    $("ExportCheckMsg").store({ "cp_message" : null });

    // first deal with missing record-set specification; this is allowed if there is an email address provided
    if ($('ExportRecordSet').value.trim().length == 0 && $("ExportNotify").value.trim().length > 0)
    {
        // let's check for an existing request and allow the user to cancel it if one exists;
        check_for_cancel_enabled_shortcut();
        update_export_buttons();
        return 0; // there is no record-set, so the export parameters are incomplete
    }

    if (!file_upload)
    {
        if (record_count === null)
        {
            // deal with bad record-set specification
            $("ExportCheckMsg").store({ "cp_message" : "Still counting records; wait a second then retry" });
            update_export_buttons();
            return 0;
        }
    }

    // we've dealt with record-set specification (and possibly email address registration); now deal with the rest;
    // use is_ok_to_submit() to get an error message to display in the CP button message

    // This is an asynchronous call, so we need to put the following "isOK" check into a
    // callback function. Return isOK == 0 since we do not know if it is OK to do an export
    // at this point.

    // this may or may not be an asynchronous call; $("ExportNotify").retrieve('valid', false) will either synchronously
    // return the acceptability of the notification address, or it will be updated when the asynchronous call completes;
    // if this is an asynchronous call, then $("ExportNotify").retrieve('valid', false) below will indicate that
    // the notification address is not acceptable, and the user will need to click on "Check Params for Export"
    // again
    if ($("ExportNotify").value.trim().length > 0)
    {
        update_export_buttons();
        startEmailCheck($("ExportNotify"), $("ExportRequestor"), $("ExportCheckMsg"), update_export_buttons, null);

    }

    // notificationAddressOK may be in the process of being updated asynchronously, in which case notificationAddressOK == false
    isOK = is_ok_to_submit($("ExportCheckMsg"), 'cp_message');
    update_export_buttons();

    if (isOK)
    {
        var args = {};
        var check_pending_fn = null;

        if ($("ExportMethod").options[$("ExportMethod").selectedIndex].value == 'url_direct')
        {
            // if export method == 'url_quick':
            //   1. make sure all SUs are online (use results of jsoc_info call used when the record-set was selected)
            //   2. determine if we want to stream a tar file (if num fits files > 1) or fits file (if num fits files == 1)
            //   3. call exportCGI, which calls drms-export-to-stdout with the arguments determined in #2,
            //      opening a pipe to receive results
            //   4. stream an HTTP header back to the export user
            //   5. stream the file (tar or fits)
            if ($('ExportRecordSet').retrieve('count', null) > 1)
            {
                $("ExportCheckMsg").store({ "cp_message" : "url_direct can only be used if exporting a single FITS file" });
                isOK = false;
            }
            else
            {
                if ($('ExportRecordSet').retrieve('allSUsOnline', false))
                {
                    args.address = $('ExportNotify').value;
                    args.specification = $('ExportRecordSet').value;
                    args.filenamefmt = $('ExportFilenameFmt').value;
                    args.requestor = $("ExportRequestor").value;
                }
            }
        }
        else
        {
            args.op = $("ExportOpID").value;
            args.ds = $('ExportRecordSet').value;
            args.sizeratio = $("ExportSizeRatio").value;
            args.process = $('ExportProcessing').retrieve('processing_argument_str', '');
            args.requestor = $("ExportRequestor").value;
            args.notify = $("ExportNotify").value;
            args.method = $('ExportMethod').options[$('ExportMethod').selectedIndex].value.trim();
            args.filenamefmt = $('ExportFilenameFmt').value;
            args.format = "json";
            args.protocol = $('ExportProtocolHidden').value;
            args.processing = $('ExportProcessing').retrieve('processing_obj', {});
        }

        $('ExportRecordSet').store({ "exportArgs" : args });
        $('ExportCheckMsg').store({ "cp_message" : "OK to submit export request" });
        update_export_buttons();
        ExportShowQuery();

        $("ExportButton").store('state', EB_STATE_ENABLED);
        update_export_buttons();

        // on-demand (check once, not in intervals); presents the user with an enabled 'submit'/'cancel' button
        // (it will be 'submit' because the call to check_for_cancel_enabled_shortcut() will have set the state
        // to 'cancel' if a request was pending and execution will never have gotten here).
        check_pending_fn = CHECK_FOR_PENDING_REQUEST(false);
        check_pending_fn();
    }
    else
    {

        $('ExportRecordSet').store({ 'exportArgs' : null });
    }

    if (isOK)
    {
        $("ExportCheckButton").store({ 'dirty' : false });
    }

    return isOK;
}

// called when user clicks on CPE button
function CheckExportParams()
{
    var addresses = $("ExportNotify").retrieve('addresses', {});
    var address = $("ExportNotify").value.trim();
    var requestor = $("ExportRequestor").value.trim();
    var snail_address = null; // no UI yet
    var registration_status = null;
    var address_registered = null;

    if (addresses !== null && address.length > 0 && Object.prototype.hasOwnProperty.call(addresses, address) && Object.prototype.hasOwnProperty.call(addresses[address], 'registration_status'))
    {
        registration_status = addresses[address].registration_status;
    }

    address_registered = (registration_status !== null && (typeof(registration_status) === 'boolean') && registration_status) ? true : false;
    if (address_registered)
    {
        // Up till now, SetProcessing() gets called whenever a processing option checkbox gets clicked.
        // But SetProcessing() does not get called when the user changes processing option values. Call it
        // now with -1 (which means the record-set spec has not changed).
        SetProcessing(-1, CheckExportButtonOnClickAction);  // asynchronous - can't do the rest until this asynchronous call completes.
    }
    else
    {
        // register the email address
        var registration_callback = function()
        {
            update_export_buttons();
            check_for_cancel_enabled_shortcut();
        };

        // we have to reset the registration status for this address; we previously checked its status which sets
        // the status to `false`; if we call register_address() without first resetting it, then we get the cached
        // value of `false` returned and the registration code is bypassed
        addresses[address].registration_status = null;
        register_address(address, requestor, snail_address, $("ExportNotify"), $("ExportCheckMsg"), update_export_buttons, registration_callback);
    }
}

function cancel_export()
{
    var address = $("ExportNotify").value.trim();
    var cancel_pending_fn = null;
    var internal_fn = null;
    var interval_fn_timer = null;
    var interval_fn_timeout = null;

    if (address !== null && address.length > 0)
    {
        $("StatusRequestID").value = ''; // remove export request ID from RequestID in lower section
        $("RequestIdPlace").innerHTML = ''; // remove export request ID from RequestID in upper section

        cancel_pending_fn = CANCEL_PENDING_REQUEST();

        // null -> do nothing on success; let interval function handle the resulting state changes
        cancel_pending_fn(null);

        interval_fn_timer = $("ExportButton").retrieve('interval', null);
        if (interval_fn_timer === null)
        {
            // start-up interval
            internal_fn = CHECK_FOR_PENDING_REQUEST(true);
            interval_fn_timer = setInterval(internal_fn, 1000);
            $("ExportButton").store('interval', interval_fn_timer);

            // do not allow the pending-request check to last forever (EB is in EB_STATE_CANCEL)
            interval_fn_timeout = setTimeout(function () { $("ExportButton").store('state', EB_STATE_TIMEOUT); set_eb_state_disabled(true);}, 30000);
            $("ExportButton").store('interval_timeout', interval_fn_timeout);
        }
    }
}

// tester succeeded
</script>
<script type="text/javascript">

// this is the code executed when the user clicks on the ExportButton button
function ExportButtonOnClickAction()
{
    // if the use was able to click this button, then it was OK to submit an export request
    var EB_state = $('ExportButton').retrieve('state', EB_STATE_DISABLED);
    var internal_fn = null;
    var interval_fn_timer = null;
    var interval_fn_timeout = null;

    if (EB_state === EB_STATE_SUBMIT_ENABLED)
    {
        EB_state = EB_STATE_SUBMIT;
        $('ExportButton').store('state', EB_state);
        // update_export_buttons();
        update_request_section_ui(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, false);

        // call jsoc_fetch now
    }
    else if (EB_state === EB_STATE_CANCEL_ENABLED)
    {
        EB_state = EB_STATE_CANCEL;
        $('ExportButton').store('state', EB_state);
        update_export_buttons();

        // start up interval function (so we know when export request has been completely processed)
        interval_fn_timer = $("ExportButton").retrieve('interval', null);
        if (interval_fn_timer === null)
        {
            // start-up interval
            internal_fn = CHECK_FOR_PENDING_REQUEST(true);
            interval_fn_timer = setInterval(internal_fn, 1000);
            $('ExportButton').store('interval', interval_fn_timer);
        }

        // set or reset timeout timer
        interval_fn_timeout = $('ExportButton').retrieve('interval_timeout', null);
        if (interval_fn_timeout !== null)
        {
            // do not allow the pending-request check to last forever (EB is in EB_STATE_CANCEL); next state is EB_STATE_CANCELED
            // which should happen relatively quickly
              clearTimeout(interval_fn_timeout);
        }

        if (interval_fn_timer !== null)
        {
            interval_fn_timeout = setTimeout(function () { $('ExportButton').store('state', EB_STATE_TIMEOUT); set_eb_state_disabled(true);}, 15000);
            $('ExportButton').store('interval_timeout', interval_fn_timeout);
        }

        // this state transition is handled by calling manage-request, not jsoc_fetch (the code below
        // is all about jsoc_fetch); run this:
        // manage-request.py address=<foo>@<bar> operation=cancel
        // if this call fails for any reason, no worries, the export simply is not canceled, and
        // we get stuck in the EB_STATE_CANCEL state until it completes by natural causes
        cancel_export();

        // do not continue onto calling jsoc_fetch
        return;
    }
    else if (EB_state === EB_STATE_CANCELED)
    {
        set_eb_state_disabled(true);

        // do not continue onto calling jsoc_fetch
        return;
    }
    else if (EB_state === EB_STATE_PATH)
    {
        // need to use the PENDING_REQUEST_STATUS_PATH endpoint and AssimilateInquiryResponse()
        // as the onSuccess() - we update just the upper/request section's status ui
        // GetStatus();
        // set state to disabled (for new export)
        set_eb_state_disabled(true);
        $('ExportButton').store({ "ajax-state" : "post-click" });
        update_request_section_ui(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, false);
        $('ExportButton').store({ "ajax-state" : "pre-click" });
        return;
    }
    else
    {
        $('ExportButton').store({ "error" : true });
        $('ExportButtonMsg').store({ "message" : "unexpected-export button state" });
        update_request_section_ui(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, false);

        set_eb_state_disabled(true);
        // do not continue onto calling jsoc_fetch
        return;
    }

    if ($('ExportMethod').options[$('ExportMethod').selectedIndex].value === EXP_METH_STREAMED)
    {
        // no need to process a full export request via jsoc_fetch
        if ($('ExportRecordSet').retrieve('count', null) > 1)
        {
            $("ExportLocation").innerHTML =  '<b>Multiple files were requested - use the url_direct export method to request a single file only.<\/b><p>';
        }
        else
        {
            CreateExportDownloadButton(null, null);
        }

        return;
    }

    var doFetchReqFn = function()
    {
        var export_app_arguments = null;
        var options = null;
        var db_host = null;
        var export_endpoint = null;
        var export_arguments = null;
        var ignore_processing = null;
        var export_endpoint_arguments = null;
        var on_failure = null;

        var access = null;
        var export_package = null;
        var file_format = null;
        var file_format_args = null;
        var method = null;

        if ($('PrivateHostElement').retrieve('is_private', false))
        {
            db_host = INTERNAL_SERVER;
        }
        else
        {
            db_host = EXTERNAL_SERVER;
        }

        // arguments from URL form
        export_arguments = $('ExportRecordSet').retrieve('exportArgs', null);
        method = $('ExportMethod').options[$('ExportMethod').selectedIndex].value.trim();

        // the export method dictates the type of export (in the flask app);
        //   'url_quick' ==> mini
        //   'url_direct' ==> streamed (handled in a different part of the js)
        //    everything else ==> premium
        if (method.toLowerCase() == EXP_METH_QUICK)
        {
            export_endpoint = MINI_EXPORT_REQUEST_PATH;

            export_endpoint_arguments = { "specification" : export_arguments.ds, "file-name-format" : export_arguments.filenamefmt, "number-records" : get_max_records() };
        }
        else if (method.toLowerCase() == EXP_METH_STREAMED)
        {
            // error
            $('ExportButtonMsg').innerHTML = "streamed exports are handled with by a different button";
            $('ExportButton').value = 'FAILURE ...';
            $('ExportButton').style.backgroundColor = colorDarkPink;
            set_eb_state_disabled(true);
        }
        else
        {
            export_endpoint = PREMIUM_EXPORT_REQUEST_PATH;

            if ($('ExportMethod').options[$('ExportMethod').selectedIndex].value.trim().toLowerCase().indexOf('ftp') == 0)
            {
                access = 'ftp';
            }
            else
            {
                access = 'http';
            }

            export_package = {};
            if ($('ExportMethod').options[$('ExportMethod').selectedIndex].value.trim().toLowerCase().indexOf('tar') != -1)
            {
                export_package = { "type" : "tar" };
            }
            else
            {
                export_package = { "type" : null };
            }

            argument_argument_obj = unserialize_arguments(export_arguments.protocol);
            argument_namespace = Object.keys(argument_argument_obj)[0];

            if (Object.keys(argument_argument_obj[argument_namespace]).length > 0)
            {
                file_format = argument_namespace.toLowerCase();

                // file_format_args are extra arguments for the protocol types of JPEG, MPEG, MP4, and FITS (compression strings are
                // arguments)
                // extra args exist - for some reason the saved string != the displayed string
                if (file_format === 'jpg' || file_format === 'mpg' || file_format === 'mp4' || file_format === 'fits')
                {
                    if (argument_argument_obj[argument_namespace]['unnamed'].length > 0)
                    {
                        file_format += ',' + argument_argument_obj[argument_namespace]['unnamed'].join(',');
                    }

                    file_format_args = argument_argument_obj[argument_namespace];
                    delete file_format_args['unnamed'];
                }
                else
                {
                    // error
                }
            }
            else
            {
                file_format = export_arguments.protocol.toLowerCase();
            }

            ignore_processing = !$('ExportProcessing').retrieve('apply_processing', false);

            // no longer a need to provide size ratio to back-end; jsoc_fetch will calculate it using the processing
            // steps as input
            export_endpoint_arguments = { "access" : access, "package" : export_package, "specification" : export_arguments.ds, "file-format" : file_format, "file-format-args" : file_format_args, "file-name-format" : export_arguments.filenamefmt, "number-records" : get_max_records(), "processing" : ignore_processing ? {} : export_arguments.processing };
        }

        if (export_endpoint !== null)
        {
            export_app_arguments = { "address" : export_arguments.notify, "db-host" : db_host, "export-arguments" : JSON.stringify(export_endpoint_arguments), "requestor" : export_arguments.requestor };

            options =
            {
                method: 'post',
                onSuccess: function(response)
                {
                    var ir_response_obj = response.responseJSON;

                    $('ExportButton').store({ "ajax-state" : "post-click" });

                    if (ir_response_obj !== null)
                    {
                        AssimilateSubmissionResponse(ir_response_obj);
                    }
                },
                onFailure: function(response)
                {
                    var error_message = 'failure initiating export: ' + stringify_obj(response.responseJSON.error_message);

                    $('ExportButton').store({ "ajax-state" : "post-click" });

                    AssimilateSubmissionResponse({ "error_message" : error_message });
                },
                on428: function(response)
                {
                    var error_message = 'invalid arguments to ' + export_endpoint + ' endpoint: '+ stringify_obj(response.responseJSON.error_message);

                    $('ExportButton').store({ "ajax-state" : "post-click" });

                    AssimilateSubmissionResponse({ "error_message" : error_message });
                },
                onComplete: function(response)
                {
                }
            };

            $('ExportButton').store({ "ajax-state" : "ajax-running" });
            update_request_section_ui(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, false);

            options['postBody'] = JSON.stringify(export_app_arguments);
            options['contentType'] = 'application/json';

            new Ajax.Request(window.location.origin + export_endpoint, options);
        }
    }

    // Just call the function. It will determine if it should use the internal or external version of the CGI.
    doFetchReqFn();
}

// tester success
</script>
<script type="text/javascript">

// the name of the function in the html; this simply calls a function with a function name that denotes it is called
// when a button gets clicked
function GetExport()
{
    return ExportButtonOnClickAction();
}

function ExportOrigin(requestID)
{
    var retVal = [];

    if ($('PrivateHostElement').retrieve('is_private', false))
    {
        retVal.push('intServer');
    }
    else
    {
        retVal.push('extServer');
    }

    if (requestID)
    {
        if (retVal[0] == 'invalidServer')
        {
            // can't determine if request ID is valid or not
            retVal.push('invalidRequestID');
        }
        else
        {
            if ($("StatusRequestID").value.search("_IN") != -1)
            {
                // an internal request ID
                if (retVal[0] == 'extServer' && $("StatusRequestID").value.search("_X") == -1 ||
                    retVal[0] == 'intServer' && $("StatusRequestID").value.search("_X") != -1)
                {
                    // the external server can process internal request IDs, but only if there is an '_X_IN' in the ID
                    retVal.push('invalidRequestID');
                }
                else
                {
                    retVal.push('intRequestID');
                }
            }
            else
            {
                // an external request ID
                if (retVal[0] == 'intServer')
                {
                    // the internal server cannot process external request IDs
                    retVal.push('invalidRequestID');
                }
                else
                {
                    retVal.push('extRequestID');
                }
            }
        }
    }

    return retVal;
}
// tester success
</script>
<script type="text/javascript">


function GetReExport()
{
    // disabled at the moment - the ReExportDiv UI is disabled
    var export_app_arguments = null;
    var options = null;
    var origin = null;
    var db_host = null;
    var export_endpoint = null;
    var export_arguments = null;
    var export_endpoint_arguments = null;

    origin = ExportOrigin(null);

    if ($('PrivateHostElement').retrieve('is_private', false))
    {
        db_host = INTERNAL_SERVER;
    }
    else
    {
        db_host = EXTERNAL_SERVER;
    }

    if (origin[1] == 'invalidRequestID')
    {
        if (origin[0] == 'extServer')
        {
            alert('The request ID ' +  $("StatusRequestID").value + ' is accessible from http://' + INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN +' only. Please use a request ID generated by a request made on the http://' + EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN +' webserver (which has a format of JSOC_YYYYMMDD_NNN or JSOC_YYYYMMDD_NNN_X_IN).');
            return;
        }
        else if (origin[0] == 'intServer')
        {
            alert('The request ID ' +  $("StatusRequestID").value + ' is accessible from http://' + EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + ' only. Please use a request ID generated by a request made on the http://' + INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + ' webserver (which has a format of JSOC_YYYYMMDD_NNN_IN).');
            return;
        }
        else
        {
            return;
        }
    }

    // endpoint is not implemented; the original code is in the exp_repeat branch of jsoc_fetch.c
    export_arguments = null;

    $("ExportStatus").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("ExportLocation").innerHTML = "";
    $("ReExportButtonMsg").innerHTML = "Export request submitted, please wait...";
    $("ReExportButton").value = "Processing ...";
    $("ReExportButton").style.backgroundColor = colorPink;

    options =
    {
        method: 'post',
        onSuccess: function(response)
        {
            var ir_response_obj = response.responseJSON;

            if (ir_response_obj !== null)
            {
                AssimilateSubmissionResponse(ir_response_obj);
            }
        },
        onFailure: function(response)
        {
            var error_message = "failuring re-exporting data: " + stringify_obj(response.responseJSON.error_message);

            AssimilateSubmissionResponse({ "error_message" : error_message });
        },
        on428: function(response)
        {
            var error_message = "invalid arguments to re-export endpoint: " + stringify_obj(response.responseJSON.error_message);

            AssimilateSubmissionResponse({ "error_message" : error_message });
        },
        onComplete: function(response)
        {
        }
    };

    options['postBody'] = JSON.stringify(export_app_arguments);
    options['contentType'] = 'application/json';

    new Ajax.Request(window.location.origin + RE_EXPORT_REQUEST_PATH, options);
}

// tester success
</script>
<script type="text/javascript">

// called after ajax complete, so export button is in post-click state (called only in response to
// export-button click); sets export-button state to pre-click upon return
function AssimilateSubmissionResponse(ir_response_obj)
{
    var endpoint_status = null;
    var endpoint_status_wordy = null;
    var request_id = null;
    var payload_size = null;
    var seconds_elapsed = null;
    var sums_directory = null;
    var number_records = null;
    var number_files = null;
    var access = null;
    var data_package = null;
    var file_format = null;
    var keywords_file = null;
    var export_data = null;
    var contact = null;
    var error_message = null;
    var interval_fn_timer = null;
    var interval_fn_timeout = null;
    var eb_state = null;

    if (ir_response_obj !== null)
    {
        endpoint_status = ir_response_obj.drms_export_status;
        endpoint_status_wordy = ir_response_obj.drms_export_status_description;

        if (ir_response_obj.hasOwnProperty('request_id'))
        {
            request_id = ir_response_obj.request_id;
        }

        if (ir_response_obj.hasOwnProperty('mb_exported') && ir_response_obj.mb_exported !== null)
        {
            payload_size = ir_response_obj.mb_exported.toString();
        }

        if (ir_response_obj.hasOwnProperty('wait') && ir_response_obj.wait !== null && ir_response_obj.wait.length > 0)
        {
            seconds_elapsed = ir_response_obj.wait.toString();
        }

        if (ir_response_obj.hasOwnProperty('sums_directory'))
        {
            sums_directory = ir_response_obj.sums_directory;
        }

        if (ir_response_obj.hasOwnProperty('number_records') && ir_response_obj.number_records !== null)
        {
            number_records = ir_response_obj.number_records.toString();
        }

        if (ir_response_obj.hasOwnProperty('number_files') && ir_response_obj.number_files !== null)
        {
            number_files = ir_response_obj.number_files.toString();
        }

        if (ir_response_obj.hasOwnProperty('access'))
        {
            access = ir_response_obj.access;
        }

        if (ir_response_obj.hasOwnProperty('package'))
        {
            data_package = ir_response_obj.package;
        }

        if (ir_response_obj.hasOwnProperty('file_format'))
        {
            file_format = ir_response_obj.file_format;
        }

        if (ir_response_obj.hasOwnProperty('keywords_file'))
        {
            keywords_file = ir_response_obj.keywords_file;
        }

        if (ir_response_obj.hasOwnProperty('export_data'))
        {
            export_data = ir_response_obj.export_data;
        }

        if (ir_response_obj.hasOwnProperty('error_message'))
        {
            error_message = 'failure initiating export: ' + stringify_obj(ir_response_obj.error_message);
        }

        if (ir_response_obj.hasOwnProperty('contact'))
        {
            contact = ir_response_obj.contact;
        }
    }
    else
    {
        error_message = 'failure initiating export';
        endpoint_status = 'ErrorCode.REQUEST_FATAL_ERROR';
    }

    if (endpoint_status === 'ErrorCode.REQUEST_SEGMENT_OFFLINE')
    {
        update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact, false);

        set_eb_state_disabled(true);
    }
    else if (endpoint_status === 'ErrorCode.REQUEST_TOO_MANY')
    {
        update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact, false);

        set_eb_state_disabled(true);
    }
    else if (endpoint_status === 'StatusCode.REQUEST_NOT_QUEUED')
    {
        // request has not been inserted into jsoc.export_new - cannot happen when clicking export submit since
        // that click will ensure the export is inserted into jsoc.export_new, or there will be an export failure
        error_message = 'unexpected endpoint status ' + endpoint_status;
        endpoint_status = 'ErrorCode.REQUEST_FATAL_ERROR';

        set_eb_state_disabled(true);
    }
    else if (endpoint_status == 'ErrorCode.REQUEST_NOT_ONLINE')
    {
        // can only happen for re-export
        update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact, false);

        set_eb_state_disabled(true);
    }
    else if (endpoint_status == 'ErrorCode.REQUEST_FATAL_ERROR')
    {
        update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact, false);

        set_eb_state_disabled(true);
    }
    else if (endpoint_status == 'ErrorCode.REQUEST_TOO_LARGE')
    {
        update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact, false);

        set_eb_state_disabled(true);
    }
    else if (endpoint_status === 'StatusCode.REQUEST_QUEUED' || endpoint_status === 'StatusCode.REQUEST_QUEUED_DEBUG' || endpoint_status === 'StatusCode.REQUEST_PROCESSING')
    {
        update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact, false);

        // fill in the request id in $('StatusRequestID') - passing in a request ID will effect this
        update_status_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);

        // we now know that the JSOC has seen the export request; before jsoc_fetch returns, it inserts a row
        // into export_pending_reqs, which means the user has a pending request; jsoc_fetch sets status to 2
        // when starting a new request (not 1, which is what the status check will return)

        // it is safe to change state to cancel_enabled
        if ($('ExportButton').retrieve('state', EB_STATE_DISABLED) === EB_STATE_SUBMIT)
        {
            $('ExportButton').store('state', EB_STATE_CANCEL_ENABLED);
            update_export_buttons();

            interval_fn_timer = $('ExportButton').retrieve('interval', null);
            if (interval_fn_timer === null)
            {
                // start-up interval
                internal_fn = CHECK_FOR_PENDING_REQUEST(true);
                interval_fn_timer = setInterval(internal_fn, 1000);
                $('ExportButton').store('interval', interval_fn_timer);
            }

            // do not allow the pending-request check to last forever (EB is in EB_STATE_CANCEL_ENABLED); export processing
            // could take a while so set a 1 day timeout (86400000)
            interval_fn_timeout = $("ExportButton").retrieve('interval_timeout', null);
            if (interval_fn_timeout !== null)
            {
                clearTimeout(interval_fn_timeout);
            }

            if (interval_fn_timer !== null)
            {
                interval_fn_timeout = setTimeout(function () { $('ExportButton').store('state', EB_STATE_TIMEOUT); set_eb_state_disabled(true);}, 86400000);
                $('ExportButton').store('interval_timeout', interval_fn_timeout);
            }
        }
        else
        {
            // error
            console.log('unexpected eb state 1');
        }

        localStorage.setItem('request-id', request_id);

        if ($('FileUploadCheckbox').checked)
        {
            $('FileUploadInfo').innerHTML = 'file upload done; ' + number_records + ' records requested';
        }

        // file upload processing occuring asynchronously; file_upload_on_complete() will be a no-op if no file-upload is occurring
        file_upload_on_complete();
    }
    else if (endpoint_status === 'StatusCode.REQUEST_COMPLETE')
    {
        // two cases: 1. url_quick format and all online as-is; there should be no request ID; 2. url (premium) and initiate_request sent an exp
        // status request, and got a StatusCode.REQUEST_COMPLETE response

        localStorage.removeItem('request-id');

        eb_state = $('ExportButton').retrieve('state', EB_STATE_DISABLED);

        // the user has clicked on the "get path" EB button; we need to changed back to disabled state
        if (eb_state === EB_STATE_PATH)
        {
            // if the user has clicked on the "get path" EB button; we need to changed back to disabled state; status
            // could be StatusCode.REQUEST_COMPLETE, but the eb state was not path - this happens when
            // for a request that serviced without starting a new export

            // before we change the state to disabled, we need to ensure that the interval function is no longer running
            // (due to a race condition, it may still be running (interval sets to EB_STATE_PATH, then this code here
            // runs, which changes state to EB_STATE_DISABLED before interval function has a chance to clear itself))
            set_eb_state_disabled(true);
        }
        else if (eb_state === EB_STATE_SUBMIT)
        {
            // request was satified synchronously
            $('ExportButton').store({ "state" : EB_STATE_PATH });
        }
        else
        {
            console.log('unexpected eb state 2' + eb_state.toString())
        }

        update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact, false);

        // fill in the request ID in the status section
        update_status_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);

        if ($('FileUploadCheckbox').checked)
        {
            $('FileUploadInfo').innerHTML = 'file upload done; ' + number_records + ' records requested';
        }

        // file_upload_on_complete() will be a no-op if no file-upload is occurring
        file_upload_on_complete();
    }
    else if (endpoint_status.search(/errorcode/i) == 0)
    {
        // by setting `error`, this will cause update_export_buttons() to display FAILURE... for the export button
        error_message = 'unexpected endpoint error ' + endpoint_status;
        endpoint_status = 'ErrorCode.REQUEST_FATAL_ERROR';

        update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact, false);

        set_eb_state_disabled(true);
    }
    else
    {
        // unknown status
        error_message = 'unexpected endpoint status ' + endpoint_status;
        endpoint_status = 'ErrorCode.REQUEST_FATAL_ERROR';

        update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact, false);

        set_eb_state_disabled(true);
    }

    $('ExportButton').store({ "ajax-state" : "pre-click" });
}
// tester success
</script>
<script type="text/javascript">


function ClearStatus()
{
    $('StatusButton').store({ "reset" : true });
    update_status_section_ui(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
}

</script>
<script type="text/javascript">

// update the UI of the upper/request sectioni
// cannot be the case that both buttons have been clicked simultaneously (they would stomp on each other)
// both button clicks affect all UI elements
function update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keyword_fiile, export_data, contact, is_streamed)
{
    // update the UI at the bottom of the uppper/request section; there is a table with three columns (the first column is a header - RequestID, Status, Data Location):
    // first column:
    //   row 3, column 1 - $('DataLocation'), the header is 'Download' (for streamed exports); row is visible only for streamed export results
    //   row 4, column 1 $('')
    // second column:
    //   row 1, column 2 - $('RequestIdPlace'), the requestID for an export that was initiated successfully
    //   row 2, column 2 - $('ExportStatus'), information like if the export is being processed, data are ready for download, the size of data exported, error
    //   messages if the data could not be exported
    //   row 3, column 2 - $('ExportLocation'), used only for url_direct/streamed export result; row is visible only for streamed export results
    // third column:
    //   row 1, column 3 - $('RequestIDDesc'), instructions how to get export status updates (in the lower/status section)
    //   none - only two columns for the 'Status' row
    //   none - only two columns for the 'Data Location' row
    var reset = null;
    var export_button_click = null;
    var export_button_error = null;
    var status_button_click = null;
    var status_button_error = null;
    var request_id_resolved = null;
    var request_id_instructions = null;
    var export_status = null;
    var url_table = null;

    reset = $('ExportButton').retrieve('reset', false);

    if ($('ExportButton').retrieve('ajax-state', 'pre-click') !== 'pre-click')
    {
        export_button_click = true;
        if (endpoint_status !== null && endpoint_status.search(/errorcode/i) == 0)
        {
            export_button_error = true;
        }
        else
        {
            export_button_error = false;
        }
    }

    if ($('StatusButton').retrieve('ajax-state', 'pre-click') !== 'pre-click')
    {
        status_button_click = true;

        if (endpoint_status !== null && endpoint_status.search(/errorcode/i) == 0)
        {
            status_button_error = true;
        }
        else
        {
            status_button_error = false;
        }
    }
    else
    {
        status_button_click = false;
    }

    if (reset)
    {
        $('DataLocation').innerHTML = 'Data Location';
    }
    else
    {
        if ($('ExportMethod').options[$('ExportMethod').selectedIndex].value.trim().toLowerCase() === EXP_METH_STREAMED)
        {
            $('DataLocation').innerHTML = 'Download';
        }
        else
        {
            $('DataLocation').innerHTML = 'Data Location';
        }
    }

    // row 1, column 2
    if (reset)
    {
        request_id_resolved = '';
    }
    else
    {
        if (is_streamed)
        {
            request_id_resolved = 'NA';
        }
        else
        {
            if (request_id !== null && request_id.length > 0)
            {
                request_id_resolved = request_id;
            }
            else if (endpoint_status === 'StatusCode.REQUEST_COMPLETE')
            {
                // no request id plus a complete request means that the request was satisfied without creating an entry in jsoc.export; this happens
                // when method is 'url-quick'; it does NOT happen under any other circumstance, not even if format is 'as-is'
                request_id_resolved = 'N/A';
            }
            else
            {
                request_id_resolved = '';
            }
        }
    }

    $('RequestIdPlace').innerHTML = request_id_resolved;

    // row 1, column 3
    if (reset)
    {
        request_id_instructions = '';
    }
    else
    {
        if (is_streamed)
        {
            request_id_instructions = '';
        }
        else
        {
            // since both an export click and a status click modify $('RequestIDDesc'), we do not need to differentiate
            if (request_id_resolved === request_id && (endpoint_status === 'StatusCode.REQUEST_COMPLETE' || endpoint_status === 'StatusCode.REQUEST_PROCESSING' || endpoint_status === 'StatusCode.REQUEST_QUEUED' || endpoint_status === 'StatusCode.REQUEST_QUEUED_DEBUG'))
            {
                request_id_instructions = HTML_REQUESTID_DESC;
            }

            // either ajax is running, or pre-click
            if (request_id_resolved === null || request_id_resolved.length == 0)
            {
                if ((export_button_click && $('ExportButton').retrieve('ajax-state', 'pre-click') === 'ajax-running') || (status_button_click && $('StatusButton').retrieve('ajax-state', 'pre-click') === 'ajax-running'))
                {
                    request_id_instructions = 'obtaining request ID';
                }
                else
                {
                    if ((export_button_click && export_button_error) || (status_button_click && status_button_error))
                    {
                        request_id_instructions = 'error obtaining request ID';
                    }
                    else
                    {
                       request_id_instructions = '';
                    }
                }
            }
        }
    }

    $('RequestIDDesc').innerHTML = request_id_instructions;

    // row 2, column 2
    if (reset)
    {
        export_status = '';
    }
    else
    {
        if (is_streamed)
        {
            if (payload_size !== null)
            {
                export_status = 'Download size = ' + (Math.round(10 * payload_size/1024/1024) / 10).toString() + ' MB';
            }
        }
        else
        {
            // since both an export click and a status click modify $('ExportStatus'), we do not need to differentiate; if ajax is still
            // running, then much of the following will be skipped over (export_status === null)
            export_status = $('ExportStatus').retrieve('message', null);
            if (export_status === null || export_status.length == 0)
            {
                if (endpoint_status === 'StatusCode.REQUEST_COMPLETE')
                {
                    export_status = 'complete, size ' + payload_size + ' MB';
                }
                else if (endpoint_status === 'StatusCode.REQUEST_PROCESSING' || endpoint_status === 'StatusCode.REQUEST_QUEUED' || endpoint_status === 'StatusCode.REQUEST_QUEUED_DEBUG' || endpoint_status === 'StatusCode.REQUEST_NOT_QUEUED')
                {
                    if (seconds_elapsed !== null && seconds_elapsed.length > 0)
                    {
                        export_status = 'in progress; payload size, ' + payload_size + ' MB; seconds since request initiated, ' + seconds_elapsed;
                    }
                    else
                    {
                        export_status = 'in progress; payload size, ' + payload_size + ' MB';
                    }
                }
                else if (endpoint_status === 'ErrorCode.REQUEST_TOO_LARGE')
                {
                    export_status = 'denied (payload too large); size, ' + payload_size + ' MB, contact, ' + contact;
                }
                else if (endpoint_status === 'ErrorCode.REQUEST_FATAL_ERROR')
                {
                    if (error_message !== null && error_message.length > 0)
                    {
                        export_status =  'failed; ' + error_message;
                    }
                }
                else if (endpoint_status === 'ErrorCode.REQUEST_NOT_ONLINE')
                {
                    export_status = 'timed out; export no longer online';
                }
                else if (endpoint_status === 'ErrorCode.REQUEST_TOO_MANY')
                {
                    if (error_message !== null && error_message.length > 0)
                    {
                        export_status =  'denied (too many requests); ' + error_message;
                    }
                }
            }

            if (export_status === null || export_status.length == 0)
            {
                export_status = endpoint_status_wordy;
            }

            // either ajax is running, or pre-click
            if (export_status === null || export_status.length == 0)
            {
                if ((export_button_click && $('ExportButton').retrieve('ajax-state', 'pre-click') === 'ajax-running') || (status_button_click && $('StatusButton').retrieve('ajax-state', 'pre-click') === 'ajax-running'))
                {
                    export_status = 'obtaining status';
                }
                else
                {
                    if ((export_button_click && export_button_error) || (status_button_click && status_button_error))
                    {
                        export_status = 'error obtaining status';
                    }
                    else
                    {
                        export_status = '';
                    }
                }
            }
        }
    }

    $('ExportStatus').innerHTML = export_status;

    // row 3, column 2 - data location base URL
    // only an export button click should create the url table in the upper/request section
    if (reset)
    {
        $('DataLocation').innerHTML = '';
        $('ExportLocation').innerHTML = '';
        $('StreamedLinkRow').style.display = 'none';
    }
    else
    {
        if (is_streamed)
        {
            $('DataLocation').innerHTML = $('DataLocation').retrieve('header', '');
            $('ExportLocation').insert($('ExportLocation').retrieve('button', ''));
            $('StreamedLinkRow').style.display = 'table-row';

        }
        else
        {
            $('DataLocation').innerHTML = '';
            $('ExportLocation').innerHTML = '';
            $('StreamedLinkRow').style.display = 'none';
        }
    }

    // row 4, column 1 - url table
    if (reset)
    {
        $('RequestUrlTable').innerHTML = '';
    }
    else
    {
        if (export_button_click)
        {
            if (export_data !== null)
            {
                $('RequestUrlTable').innerHTML = CreateDataTable(export_data, data_package) + '<br>';
            }
            else
            {
                $('RequestUrlTable').innerHTML = '';
            }
        }
    }

    // export buttons
    $('ExportButton').store({ "error" : false, "label" : null });
    $('ExportButtonMsg').store({ "message" : null });
    if (endpoint_status === 'StatusCode.REQUEST_COMPLETE')
    {
        if (export_button_click)
        {
        }
    }
    else if (endpoint_status === 'StatusCode.REQUEST_PROCESSING' || endpoint_status === 'StatusCode.REQUEST_QUEUED' || endpoint_status === 'StatusCode.REQUEST_QUEUED_DEBUG')
    {
        if (export_button_click)
        {
        }
    }
    else if (endpoint_status === 'ErrorCode.REQUEST_TOO_LARGE')
    {
        if (export_button_click)
        {
            $('ExportButton').store({ "error" : true, "label" : "too large" });
            $('ExportButtonMsg').store({ "message" : "JSOC intervention required (" + endpoint_status_wordy + "); payload size = " + payload_size + " MB, " + number_files + " files generated, contact: " + contact });
        }
    }
    else if (endpoint_status === 'ErrorCode.REQUEST_FATAL_ERROR')
    {
        if (export_button_click)
        {
            $('ExportButton').store({ "error" : true, "label" : "bad export" });
            $('ExportButtonMsg').store({ "message" : error_message });
        }
    }
    else if (endpoint_status === 'ErrorCode.REQUEST_NOT_ONLINE')
    {
        $('ExportButton').store({ "error" : true, "label" : "timeout" });
        $('ExportButtonMsg').store({ "message" : error_message });
    }
    else if (endpoint_status === 'ErrorCode.REQUEST_TOO_MANY')
    {
        if (export_button_click)
        {
            $('ExportButton').store({ "error" : true, "label" : "too many" });
            $('ExportButtonMsg').store({ "message" : error_message });

        }
    }

    update_export_buttons();

    if (reset)
    {
        $('ExportButton').store({ "reset" : false });
    }
}

</script>
<script type="text/javascript">

// update the UI of the lower/status section
// can be called from after export button click (when the user clicks 'get path'):
function update_status_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact)
{
    // the lower status section is a table with 4 columns, but there is no real table structure in the display; there
    // are essentially 5 rows, followed by a table of export urls:
    //   row 1 (4 columns) - header 'RequestID' [const], request ID text box, description (This is the ID tag for your export request) [const],
    //     status string (success, export status error code string, blank)
    //   row 2 (3 columns) - request button, instructions for button (please only click once for status request), another random description
    //     (List formats are index.html, index.json, and index.txt; export script file is JSOC_20211103_932.drmsrun) - when rendered, this
    //     text appears to be in row 3 and looks like a third column
    //   row 3 (2 columns) - clear-request button, instructions for button (clear old status request ID)
    //   row 4 (2 columns) - header 'Status', status string (data ready, size = 14 MB)
    //   row 5 (2 columns) - header 'Data Location', base url
    //   row 6 (2 columns) - header 'Tar File Location', url [can be hidden]
    //   row 7 (2 columns) - header 'Keyword File Location', url [can be hidden]
    //   row 8 (n x 3 table) - file number, record, url
    var reset = null;
    var export_button_click = null;
    var export_button_error = null;
    var status_button_click = null;
    var status_button_error = null;
    var button_color = null;
    var button_label = null;
    var button_disabled = null;
    var request_id_resolved = null;
    var link_element = null;

    reset = $('StatusButton').retrieve('reset', false);

    if ($('ExportButton').retrieve('ajax-state', 'pre-click') !== 'pre-click')
    {
        export_button_click = true;
        export_button_error = $('ExportButton').retrieve('error', false);
    }
    else
    {
        export_button_click = false;
    }

    if (!export_button_click && $('StatusButton').retrieve('ajax-state', 'pre-click') !== 'pre-click')
    {
        // can be called by export-button code; if so, then status-button ajax state will be 'running' if
        // get-status endpoint running
        status_button_click = true;
        status_button_error = $('StatusButton').retrieve('error', false);
    }
    else
    {
        status_button_click = false;
    }

    // affected by both export and status button clicks
    // row 1, col 2
    if (reset)
    {
        request_id_resolved = '';
    }
    else
    {
        if (request_id !== null && request_id.length > 0)
        {
            request_id_resolved = request_id;
        }
        else if (endpoint_status === 'StatusCode.REQUEST_COMPLETE')
        {
            // no request id plus a complete request means that the request was satisfied without creating an entry in jsoc.export; this happens
            // when method is 'url-quick'; it does NOT happen under any other circumstance, not even if format is 'as-is'
            request_id_resolved = 'N/A';
        }
        else
        {
            request_id_resolved = '';
        }
    }

    $('StatusRequestID').value = request_id_resolved;
    $('StatusRequestID').style.backgroundColor = colorYellow;

    // row 1, col 4 - affected by status button click only
    if (reset)
    {
        $('StatusValue').innerHTML = '';
    }
    else
    {
        if (status_button_click)
        {
            message = $('StatusValue').retrieve('message', null);
            if (message === null || message.length == 0)
            {
                if (endpoint_status !== null)
                {
                    message = endpoint_status;
                }
            }

            if (message === null || message.length == 0)
            {
                if (status_button_error)
                {
                    message = 'error';
                }
                else
                {
                    message = '';
                }
            }

            $('StatusValue').innerHTML = message;
        }
    }

    // row 2, col 1 (button label, color) - affected by status button click only
    if (reset)
    {
        $('StatusButton').value = 'get status';
        $('StatusButton').style.color = null;
        $('StatusButton').style.backgroundColor = colorPreset;
        $('StatusButton').disabled = true;
    }
    else
    {
        // need to enable (registered email address) / disable (no registered email address)
        if (address_is_registered() && $('StatusRequestID').value.trim().length > 0)
        {
            $('StatusButton').disabled = false;
            $('StatusButton').style.color = colorWhite;
            $('StatusButton').style.backgroundColor = colorDarkGreen;
        }
        else
        {
            $('StatusButton').disabled = true;
            $('StatusButton').style.color = null;
            $('StatusButton').style.backgroundColor = colorPreset;
            $('StatusButton').disabled = true;
        }

        if (status_button_click)
        {
            button_label = $('StatusButton').retrieve('label', null);
            button_color = $('StatusButton').retrieve('color', null);

            if ($('StatusButton').retrieve('ajax-state', 'pre-click') === 'ajax-running')
            {
                if (button_label === null || button_label.length == 0)
                {
                    button_label = 'wait...';
                }

                if (button_color === null || button_color.length == 0)
                {
                    button_color = colorYellow;
                }

                button_disabled = true;
            }
            else
            {
                if ($('StatusButton').retrieve('error', false))
                {
                    if (button_label === null || button_label.length == 0)
                    {
                        button_label = 'get status';
                    }

                    if (button_color === null || button_color.length == 0)
                    {
                        button_color = null;
                    }

                    button_disabled = true;
                }
                else
                {
                    if (button_label === null || button_label.length == 0)
                    {
                        button_label = 'get status';
                    }

                    if (button_color === null || button_color.length == 0)
                    {
                        button_color = colorDarkGreen;
                    }

                    button_disabled = false;
                }
            }

            $('StatusButton').value = button_label;
            $('StatusButton').style.color = button_disabled ? null : colorWhite;
            $('StatusButton').style.backgroundColor = button_color;
            $('StatusButton').disabled = button_disabled;
        }
    }

    // row 2, col 2 (message to the right of button) - affected by both export and status button clicks
    if (reset)
    {
        if ($('ExportNotify').retrieve('valid', false) && $('StatusRequestID').value.trim().length > 0)
        {
            message = 'Click for export status.';
        }
        else
        {
            message = 'Enter export ID (RequestID) and registered email address (Notify).'
        }

        $('StatusButtonMsg').style.color = colorBlack;
        $('StatusButtonMsg').store({ "message" : null, "error" : null });
        $('StatusButtonMsg').innerHTML = message;
    }
    else
    {
        if (status_button_click)
        {
            message = $('StatusButtonMsg').retrieve('message', null);
            if (message === null || message.length == 0)
            {
                // depends on the disposition of the response
                if (endpoint_status === 'StatusCode.REQUEST_COMPLETE')
                {
                    message = 'Click to display status.';
                    $('StatusButtonMsg').style.color = colorBlack;
                }
                else if (endpoint_status === 'StatusCode.REQUEST_PROCESSING' || endpoint_status === 'StatusCode.REQUEST_QUEUED' || endpoint_status === 'StatusCode.REQUEST_QUEUED_DEBUG')
                {
                    message = 'processing...';
                    $('StatusButtonMsg').style.color = colorRealRed;
                }
                else if (endpoint_status === 'ErrorCode.REQUEST_FATAL_ERROR')
                {
                    if (error_message !== null && error_message.length > 0)
                    {
                        message =  error_message;
                        $('StatusButtonMsg').style.color = colorRealRed;
                    }
                }
                else if (endpoint_status === 'ErrorCoce.REQUEST_NOT_ONLINE')
                {
                    message = 'timed out; export no longer online';
                    $('StatusButtonMsg').style.color = colorRealRed;
                }
            }

            if (message === null || message.length == 0)
            {
                if (endpoint_status_wordy !== null && endpoint_status_wordy.length > 0)
                {
                    message = endpoint_status_wordy;
                    $('StatusButtonMsg').style.color = colorRealRed;
                }
            }

            if (message === null || message.length == 0)
            {
                if ((status_button_click && $('StatusButton').retrieve('ajax-state', 'pre-click') === 'ajax-running') || (export_button_click && $('ExportButton').retrieve('ajax-state', 'pre-click') === 'ajax-running'))
                {
                    message = 'processing...';
                    $('StatusButtonMsg').style.color = colorRealRed;
                }
                else
                {
                    if ((export_button_click && export_button_error) || (status_button_click && status_button_error))
                    {
                        message = 'error';
                        $('StatusButtonMsg').style.color = colorRealRed;
                    }
                    else
                    {
                        if ($('ExportNotify').retrieve('valid', false) && $('StatusRequestID').value.trim().length > 0)
                        {
                            message = 'Click for export status.';
                        }
                        else
                        {
                            message = 'Enter export ID (RequestID) and registered email address (Notify)'
                        }

                        $('StatusButtonMsg').style.color = colorBlack;
                    }
                }
            }

            $('StatusButtonMsg').innerHTML = message;
        }
    }

    // row 2, col 3 (more info, 'List formats...') - affected by status click only
    if (reset)
    {
       $('StatusOther').innerHTML = '';
    }
    else
    {
        if (status_button_click)
        {
            message = $('StatusOther').retrieve('message', null);
            if (message === null || message.length == 0)
            {
                // depends on the disposition of the response
                if (endpoint_status === 'StatusCode.REQUEST_COMPLETE')
                {
                    message = 'Summary-file formats are html (index.html), json (index.json), and text (index.txt).<br>The export script is ' + request_id + '.drmsrun.';
                }
                else if (endpoint_status === 'StatusCode.REQUEST_PROCESSING' || endpoint_status === 'StatusCode.REQUEST_QUEUED' || endpoint_status === 'StatusCode.REQUEST_QUEUED_DEBUG')
                {
                    message = '';
                }
                else if (endpoint_status === 'ErrorCode.REQUEST_FATAL_ERROR')
                {
                    if (error_message !== null && error_message.length > 0)
                    {
                        message = error_message;
                    }
                }
                else if (endpoint_status === 'ErrorCoce.REQUEST_NOT_ONLINE')
                {
                    message = 'export is no longer online'
                }
            }

            if (message === null || message.length == 0)
            {
                if (endpoint_status_wordy !== null && endpoint_status_wordy.length > 0)
                {
                    message = endpoint_status_wordy;
                }
            }

            if (message === null || message.length == 0)
            {
                if (status_button_error)
                {
                    message = 'error';
                }
                else
                {
                    message = '';
                }
            }

            $('StatusOther').innerHTML = message;
        }
    }

    // row 3, col 1 - clear button
    if (reset)
    {
        $('ClearButton').value = 'clear status';
        $('ClearButton').style.color = null;
        $('ClearButton').style.backgroundColor = colorPreset;
        $('ClearButton').disabled = true;
    }
    else
    {
        if ($('StatusStatus').innerHTML.length == 0)
        {
            $('ClearButton').value = 'clear status';
            $('ClearButton').style.color = null;
            $('ClearButton').style.backgroundColor = colorPreset;
            $('ClearButton').disabled = true;
        }
        else
        {
            $('ClearButton').value = 'clear status';
            $('ClearButton').style.color = colorWhite;
            $('ClearButton').style.backgroundColor = colorDarkGreen;
            $('ClearButton').disabled = false;
        }
    }

    // row 4, col 2 (yet again more disposition info, data ready, etc.) - affeced by status click only
    if (reset)
    {
        $('StatusStatus').innerHTML = '';
    }
    else
    {
        if (status_button_click)
        {
            message = $('StatusStatus').retrieve('message', null);
            if (message === null || message.length == 0)
            {
                // depends on the disposition of the response
                if (endpoint_status === 'StatusCode.REQUEST_COMPLETE')
                {
                    message = 'data ready, size ' + payload_size + ' MB';
                }
                else if (endpoint_status === 'StatusCode.REQUEST_PROCESSING' || endpoint_status === 'StatusCode.REQUEST_QUEUED' || endpoint_status === 'StatusCode.REQUEST_QUEUED_DEBUG')
                {
                    message = 'processing export; estimated size, ' + payload_size + ' MB';
                    if (seconds_elapsed !== null && seconds_elapsed.length > 0)
                    {
                        message = 'processing export; payload size, ' + payload_size + ' MB; seconds since request initiated, ' + seconds_elapsed;
                    }
                    else
                    {
                        message = 'processing export; payload size, ' + payload_size + ' MB';
                    }
                }
                else if (endpoint_status === 'ErrorCode.REQUEST_FATAL_ERROR')
                {
                    if (error_message !== null && error_message.length > 0)
                    {
                        message =  error_message;
                    }
                }
                else if (endpoint_status === 'ErrorCode.REQUEST_NOT_ONLINE')
                {
                    message = 'timed out; export no longer online';
                }
            }

            if (message === null || message.length == 0)
            {
                if (endpoint_status_wordy !== null && endpoint_status_wordy.length > 0)
                {
                    message = endpoint_status_wordy;
                }
            }

            if (message === null || message.length == 0)
            {
                if ($('StatusButton').retrieve('error', false))
                {
                    message = 'error';
                }
                else
                {
                    message = '';
                }
            }

            $('StatusStatus').innerHTML = message;

            // dependency between StatusStatus and the clear button
            if ($('StatusStatus').innerHTML.length == 0)
            {
                $('ClearButton').value = 'clear status';
                $('ClearButton').style.color = null;
                $('ClearButton').style.backgroundColor = colorPreset;
                $('ClearButton').disabled = true;
            }
            else
            {
                $('ClearButton').value = 'clear status';
                $('ClearButton').style.color = colorWhite;
                $('ClearButton').style.backgroundColor = colorDarkGreen;
                $('ClearButton').disabled = false;
            }
        }
    }

    // row 5, col 2 (base url of export) - affected by status click only
    if (reset)
    {
        $('StatusLocation').innerHTML = '';
        $('StatusLocation').style.backgroundColor = colorYellow;
        $('StatusLocation').disabled = true;
    }
    else
    {
        if (status_button_click)
        {
            if (sums_directory !== null && sums_directory.length > 0)
            {
                if (access !== null && access.toLowerCase() === 'ftp')
                {
                    data_base_url = "ftp://pail.stanford.edu/export" + sums_directory + "/";
                }
                else
                {
                    data_base_url = window.location.origin + '/' + sums_directory + '/';
                }

                link_element = "<a href='" + data_base_url + "' target='_blank'>" + data_base_url + "<\/a>";
            }

            if (link_element === null)
            {
                link_element = '';
            }

            $('StatusLocation').innerHTML = link_element;
        }
    }

    // row 6, col 2 - affected by status click only
    if (reset)
    {
        $('TarFileLocation').innerHTML = '';
        $('TarFileLocationRow').style.display = 'none';
    }
    else
    {
        if (status_button_click)
        {
            // row 6, col 2
            if (data_package !== null && data_package.type !== null && data_package.type.toLowerCase() === 'tar')
            {

                $('TarFileLocation').innerHTML = "<a href='" + data_package.file_name + "'>" + data_package.file_name + "<\/a>";
                $('TarFileLocationRow').style.display = 'table-row';
            }
            else
            {
                $('TarFileLocation').innerHTML = '';
                $('TarFileLocationRow').style.display = 'none';
            }
        }
    }

    // row 7, col 2 - affected by status click only
    if (reset)
    {
        $('KeywordFileLocation').innerHTML = '';
        $('KeywordFileLocationRow').style.display = 'none';
    }
    else
    {
        if (status_button_click)
        {
            // row 7, col 2
            if (file_format !== null && file_format.toLowerCase() == 'as-is' && keywords_file !== null && keywords_file.length > 0)
            {
                $('KeywordFileLocation').innerHTML = "<a href='" + keywords_file + "' target='_blank'>" + keywords_file + "<\/a>";
                $('KeywordFileLocationRow').style.display = 'table-row';
            }
            else
            {
                $('KeywordFileLocation').innerHTML = '';
                $('KeywordFileLocationRow').style.display = 'none';
            }
        }
    }

    // row 8 (table of urls)
    if (reset)
    {
        $('StatusDataLocation').innerHTML = '';
    }
    else
    {
        if (status_button_click)
        {
            // only an status button click should create the url table in the lower/status section
            if (export_data !== null)
            {
                $('StatusDataLocation').innerHTML = CreateDataTable(export_data, data_package) + '<br>';
            }
            else
            {
                $('StatusDataLocation').innerHTML = '';
            }
        }
    }

    // re-export
    if (endpoint_status === 'ErrorCode.REQUEST_NOT_ONLINE')
    {
        $('ReRequestID').value = request_id_resolved;
        $('ReExportDiv').style.display = 'block';
    }
    else
    {
        $('ReRequestID').value = '';
        $('ReExportDiv').style.display = 'none';
    }

    // export buttons
    $('ExportButton').store({ "error" : false, "label" : null });
    $('ExportButtonMsg').store({ "message" : null });
    if (endpoint_status === 'StatusCode.REQUEST_COMPLETE')
    {
        if (export_button_click)
        {
        }
    }
    else if (endpoint_status === 'StatusCode.REQUEST_PROCESSING' || endpoint_status === 'StatusCode.REQUEST_QUEUED' || endpoint_status === 'StatusCode.REQUEST_QUEUED_DEBUG')
    {
        if (export_button_click)
        {
        }
    }
    else if (endpoint_status === 'ErrorCode.REQUEST_FATAL_ERROR')
    {
        if (export_button_click)
        {
            $('ExportButton').store({ "error" : true, "label" : "bad export" });
            $('ExportButtonMsg').store({ "message" : error_message });
        }
    }
    else if (endpoint_status === 'ErrorCode.REQUEST_NOT_ONLINE')
    {
        // status-button click also modifies export button label and message too
        $('ExportButton').store({ "error" : true, "label" : "timeout" });
        $('ExportButtonMsg').store({ "message" : error_message });
    }

    update_export_buttons();

    if (reset)
    {
        $('StatusButton').store({ "reset" : false });
    }
}
// tester success
</script>
<script type="text/javascript">

// called after ajax call complete, so export/status button will be in post-click state;
// can be called after export-button click (EB_STATE_PATH), or status-button click
function AssimilateInquiryResponse(mr_response_obj)
{
    var endpoint_status = null;
    var endpoint_status_wordy = null;
    var request_id = null;
    var payload_size = null;
    var seconds_elapsed = null;
    var sums_directory = null;
    var number_records = null;
    var number_files = null;
    var access = null;
    var data_package = null;
    var file_format = null;
    var keywords_file = null;
    var export_data = null;
    var contact = null;
    var error_message = null;
    var interval_fn_timer = null;
    var interval_fn_timeout = null;
    var export_button_click = null;

    if (mr_response_obj !== null)
    {
        endpoint_status = mr_response_obj.drms_export_status;
        endpoint_status_wordy = mr_response_obj.drms_export_status_description;

        if (mr_response_obj.hasOwnProperty('request_id'))
        {
            request_id = mr_response_obj.request_id;
        }

        if (mr_response_obj.hasOwnProperty('mb_exported') && mr_response_obj.mb_exported !== null)
        {
            payload_size = mr_response_obj.mb_exported.toString();
        }

        if (mr_response_obj.hasOwnProperty('wait') && mr_response_obj.wait !== null)
        {
            seconds_elapsed = mr_response_obj.wait.toString();
        }

        if (mr_response_obj.hasOwnProperty('sums_directory'))
        {
            sums_directory = mr_response_obj.sums_directory;
        }

        if (mr_response_obj.hasOwnProperty('number_records') && mr_response_obj.number_records !== null)
        {
            number_records = mr_response_obj.number_records.toString();
        }

        if (mr_response_obj.hasOwnProperty('number_files') && mr_response_obj.number_files !== null)
        {
            number_files = mr_response_obj.number_files.toString();
        }

        if (mr_response_obj.hasOwnProperty('access'))
        {
            access = mr_response_obj.access;
        }

        if (mr_response_obj.hasOwnProperty('package'))
        {
            data_package = mr_response_obj.package;
        }

        if (mr_response_obj.hasOwnProperty('file_format'))
        {
            file_format = mr_response_obj.file_format;
        }

        if (mr_response_obj.hasOwnProperty('keywords_file'))
        {
            keywords_file = mr_response_obj.keywords_file;
        }

        if (mr_response_obj.hasOwnProperty('export_data'))
        {
            export_data = mr_response_obj.export_data;
        }

        if (mr_response_obj.hasOwnProperty('error_message') && mr_response_obj.error_message !== null && mr_response_obj.error_message.length > 0)
        {
            error_message = stringify_obj(mr_response_obj.error_message);
        }

        if (mr_response_obj.hasOwnProperty('contact'))
        {
            contact = mr_response_obj.contact;
        }
    }
    else
    {
        error_message = 'failure obtaining export status';
        endpoint_status = 'ErrorCode.REQUEST_FATAL_ERROR';
    }

    if ($('ExportButton').retrieve('ajax-state', 'pre-click') === 'post-click')
    {
        export_button_click = true;
    }
    else
    {
        // assume this was a lower/status click by default
        export_button_click = false;
    }

    if (endpoint_status === 'ErrorCode.REQUEST_NOT_ONLINE')
    {
        // error - maybe the user really waited a week to get status on an export
        if (export_button_click)
        {
            update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact, false);
        }
        else
        {
            // clear out info from the request section - passing a null request id will do that
            update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, null, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact, false);

            update_status_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);
        }

        set_eb_state_disabled(true);
    }
    else if (endpoint_status === 'ErrorCode.REQUEST_FATAL_ERROR')
    {
        if (export_button_click)
        {
            update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact, false);
        }
        else
        {
            update_status_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);
        }

        set_eb_state_disabled(true);
    }
    else if (endpoint_status === 'StatusCode.REQUEST_PROCESSING' || endpoint_status === 'StatusCode.REQUEST_QUEUED' || endpoint_status === 'StatusCode.REQUEST_QUEUED_DEBUG')
    {
        if (export_button_click)
        {
            // updates $('StatusRequestID') too since request_id is not null
            update_status_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);

            update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact, false);
            localStorage.setItem('request-id', request_id);

            file_upload_on_complete();
        }
        else
        {
            update_status_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);
        }
    }
    else if (endpoint_status === 'StatusCode.REQUEST_COMPLETE')
    {
        if (export_button_click)
        {
            localStorage.removeItem('request-id');

            eb_state = $('ExportButton').retrieve('state', EB_STATE_DISABLED);
            // export-button click changes EB state (but status-button click does not) back to disabled
            if (eb_state === EB_STATE_PATH)
            {
                // before we change the state to disabled, we need to ensure that the interval function is no longer running
                // (due to a race condition, it may still be running (interval sets to EB_STATE_PATH, then this code here
                // runs, which changes state to EB_STATE_DISABLED before interval function has a chance to clear itself))

                // do not change to disabled EB state
                // set_eb_state_disabled(false);
            }
            else
            {
                // error
                console.log('unexpected eb state 3');
            }

           update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact, false);
        }
        else
        {
            update_status_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);
        }

        file_upload_on_complete();
    }
    else if (endpoint_status.search(/errorcode/i) == 0)
    {
        // error
        if (export_button_click)
        {
            update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact, false);
        }
        else
        {
            update_status_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);
        }

        set_eb_state_disabled(true);
    }
    else
    {
        // some other status code (not expected, like TOO_MANY or NOT_QUEUED)
        error_message = 'unexpected endpoint status ' + endpoint_status;
        endpoint_status = 'ErrorCode.REQUEST_FATAL_ERROR';

        if (export_button_click)
        {
            update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact, false);
        }
        else
        {
            update_status_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);
        }

        set_eb_state_disabled(true);
    }

    if (export_button_click)
    {
        $('ExportButton').store({ "ajax-state" : "pre-click" });
    }
    else
    {
        $('StatusButton').store({ "ajax-state" : "pre-click" });
    }
}

// tester success
</script>
<script type="text/javascript">


function GetStatus()
{
    var export_app_arguments = null;
    var options = null;
    var origin = null;
    var db_host = null;
    var address = null;
    var request_id = null;
    var on_failure = null;
    var export_button_click = null;
    var help_address = null;

    if ($('ExportButton').retrieve('ajax-state', 'pre-click') === 'post-click')
    {
        export_button_click = true;
    }
    else
    {
        export_button_click = false;
    }

    // if a status check is currently running, bail (an onClick() and an onChange() will be called when
    // a user changes the request ID andajax_ then clicks the `request status` button)
    if ($('StatusButton').retrieve('ajax_state', 'pre-click') !== 'ajax-running')
    {
        address = $('ExportNotify').value.trim();

        if (export_button_click)
        {
            request_id = $('RequestIdPlace').innerHTML.trim();
        }
        else
        {
            request_id = $('StatusRequestID').value.trim();
        }

        if (request_id.length == 0)
        {
            alert("You must provide a RequestID");
            return;
        }

        origin = ExportOrigin(request_id);

        if ($('PrivateHostElement').retrieve('is_private', false))
        {
            db_host = INTERNAL_SERVER;
        }
        else
        {
            db_host = EXTERNAL_SERVER;
        }

        // An external user can check status on certain internal requests. These requests originated from the external site,
        // but they were passed-through to the internal site because they involved at least one internal series that
        // was whitelisted for external access. The request IDs of those requests contains an 'X':
        //
        // JSOC_20161225_1254_X_IN

        // there are two boolean attributes describing the origin of an export request:
        // 1. the request was submitted from the external website (EXTERNAL_WEBSERVER) or the internal website (INTERNAL_WEBSERVER)
        // 2. the request was for the export of a db-external data series (the request ID ends in '_IN') or a db-internal data series (the request ID does not end in '_IN')
        //
        // the internal server can serve requests for db-internal series only; the external server can serve requests for either
        // db-external series (the request ID does not end in '_IN'), or db-internal series initiated from the external server
        // (the request ID ends in '_X_IN')
        if (origin[1] == 'invalidRequestID')
        {
            if (origin[0] == 'extServer')
            {
                alert('The request ID ' +  $("StatusRequestID").value + ' is accessible from http://' + INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN +' only. Please use a request ID generated by a request made on the http://' + EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN +' webserver (which has a format of JSOC_YYYYMMDD_NNN or JSOC_YYYYMMDD_NNN_X_IN).');
                return;
            }
            else if (origin[0] == 'intServer')
            {
                alert('The request ID ' +  $("StatusRequestID").value + ' is accessible from http://' + EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + ' only. Please use a request ID generated by a request made on the http://' + INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + ' webserver (which has a format of JSOC_YYYYMMDD_NNN_IN).');
                return;
            }
            else
            {
                return;
            }
        }

        help_address = HELP_LOCAL_NAME + '@' + location.host;

        export_app_arguments = { "address" : address, "db-host" : db_host, "request-id" : request_id };

        options =
        {
            method: 'get',
            onSuccess: function(response)
            {
                var mr_response_obj = response.responseJSON;

                if (!export_button_click)
                {
                    $('StatusButton').store({ "ajax-state" : "post-click" });
                }

                if (mr_response_obj !== null)
                {
                    AssimilateInquiryResponse(mr_response_obj);
                }
            },
            onFailure: function(response)
            {
                var error_message = "failuring getting export status: " + stringify_obj(response.responseJSON.error_message);

                if (!export_button_click)
                {
                    $('StatusButton').store({ "ajax-state" : "post-click" });
                }

                AssimilateInquiryResponse({ "request_id" : request_id.toString(), "drms_export_status" : "ErrorCode.REQUEST_FATAL_ERROR", "drms_export_status_message" : "fatal error", "error_message" : error_message, "contact" : help_address });
            },
            on428: function(response)
            {
                var error_message = "invalid arguments to pending-request-status endpoint: " + stringify_obj(response.responseJSON.error_message);

                if (!export_button_click)
                {
                    $('StatusButton').store({ "ajax-state" : "post-click" });
                }

                AssimilateInquiryResponse({ "request_id" : request_id.toString(), "drms_export_status" : "ErrorCode.REQUEST_FATAL_ERROR", "drms_export_status_message" : "fatal error", "error_message" : error_message, "contact" : help_address });
            },
            onComplete: function()
            {
            }
        };

        options['parameters'] = export_app_arguments;

        $('StatusButton').store({ "ajax-state" : "ajax-running" });
        update_status_section_ui(null, null, null, request_id, null, null, null, null, null, null, null, null, null, null, null);

        new Ajax.Request(window.location.origin + PENDING_REQUEST_STATUS_PATH, options);
    }
}

</script>

</head>
<body bgcolor="#E0F0FF" onload="OnLoadInit();" >
<div id="header">
  <a href='' id='HeaderLink'><img src='/assets/images/JSOC_120.gif'
    style="vertical-align:middle;height:60px;border:0" alt="JSOC logo"></a>
&nbsp;&nbsp;&nbsp;
<b><big style="vertical-align:middle">&nbsp;&nbsp;JSOC Data Export</big></b>
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
<input id="ResetPageButton" type="button" value="reset page" onClick="ReInitPage();" disabled>
&nbsp;&nbsp;&nbsp;
<input id="TipsOnOffButton" type="button" value="Turn Help Off" onClick="ToggleHelp();" >
&nbsp;&nbsp;<span id="AjaxBusy">0</span> Active HTTP Requests
<!-- <br clear=all> -->
<hr>
</div> <!-- end div header -->
<div id="ExportRequestDiv">
<br><b>JSOC Data Export Request Generation</b>

<!-- Start Message of the Day -->
<div class='include-html' file-resource='motd.html' target-element='MOTD' id='MOTD'></div>
<!-- END MOTD DIV -->

<span id="RecordSetExample">
&nbsp; &nbsp;
<a href='error-messages.html' target="Help">Help with Error Messages</a>
&nbsp;
<a href="release-notes.html" target="Release_Notes">Release Notes</a>
</span>
<p>
If the Method is neither "url_quick" nor "url_direct", additional options will need to be specified.
If the Method is "url", "ftp", "url-tar" or "ftp-tar", an export ID will be provided
in the RequestID elements below. The ID can be used in the "JSOC Data Export Status and Retrieval"
section to obtain the processing-status of the export. It can also be used to obtain links to the completed export.

<p>
<!-- Load bulk of html code here -->
<span id="ExportRequestForm"></span>

<div id="iframeHideDiv" style="display:none;">
  <iframe id="FileUploadFrame" onload="process_file_upload_response();" src="" style="height:0px;width:0px;border:0px solid #fff;"></iframe>
</div>

<div id="SubmitResponseDiv">
<table>
  <tr>
    <td style="width:11em">RequestID</td>
    <td style='width:12em' class='data-cell'><span id='RequestIdPlace' name='RequestIdPlace'></td>
    <td id='RequestIDDesc' style='width:30em'></td>
  </tr>

  <tr>
    <td style="width:11em">Status</td>
    <td colspan='2' class='data-cell'><span id="ExportStatus" name="ExportStatus"></td>
  </tr>

  <tr id='StreamedLinkRow', style='display:none;'>
    <td id="DataLocation" style="width:11em">Data Location</td>
    <td colspan='2' class='data-cell'><span id="ExportLocation" name="ExportLocation"></td>
  </tr>

    <tr>
        <td colspan='4'><span id='RequestUrlTable'></span></td>
    </tr>

</table>
</div>
<hr>
<div id="ExportDataDiv"  style="background-color:#C0E0FF;">
<b>JSOC Data Export Status and Retrieval</b>
<p>
<table>
  <tr>
    <td style="width:11em">RequestID</td>
    <td style="width:12em" class='data-cell'><input style="width:12em;border:none;font-size:16px" type="text" id="StatusRequestID" name="StatusRequestID" style="background-color:#FFF8DC;" value="" onChange="GetStatus();" oninput='update_status_section_ui(null, null, null, $("StatusRequestID").value, null, null, null, null, null, null, null, null, null, null, null);'></td>
    <td style='width:26em;padding-left:2em;padding-right:2em'>Identify your export request with this ID.</td>
    <td style='padding-left:2em;padding-right:2em'><span id="StatusValue"></span></td>
  </tr>

  <tr>
    <td></td>
    <td style='text-align:right'>
      <input id="StatusButton" type="button" value="get status" style="background-color:#D8D8D8" onClick="GetStatus();">
    </td>
    <td style='width:26em;padding-left:2em;padding-right:2em'><span id="StatusButtonMsg"></span </td>
    <td style='padding-left:2em;padding-right:2em' rowspan="3"><span id="StatusOther"></span></td>
  </tr>

  <tr>
    <td></td>
    <td style='text-align:right'>
      <input id="ClearButton" type="button" value="clear status" style="background-color:#D8D8D8" onClick="ClearStatus();">
    </td>
    <td style='width:26em;padding-left:2em;padding-right:2em'>Click to clear export status.</td>
  </tr>

  <tr>
    <td>Status</td>
    <td colspan='2' class='data-cell'><span id="StatusStatus" name="StatusStatus"></td>
  </tr>

  <tr>
    <td>Data Location</td>
    <td colspan='2' class='data-cell'><span id="StatusLocation" name="StatusLocation"></td>
  </tr>

  <tr id='TarFileLocationRow' style='display:none;'>
    <td>Tar File Location</td>
    <td colspan='2' class='data-cell'><span id="TarFileLocation" name="TarFileLocation"></span></td>
  </tr>

  <tr id='KeywordFileLocationRow' style='display:none;'>
    <td>Keyword File Location</td>
    <td colspan='2' class='data-cell'><span id='KeywordFileLocation' name='KeywordFileLocation'></span></td>
  </tr>

  <tr>
  <td colspan='4'><span id='StatusDataLocation' style='background-color:#FFF8DC;'></span></td>
  </tr>

</table>
</div> <!-- id="ExportRequestDiv" -->

<div id="ReExportDiv" style="display:none">
<HR>
Use this section to request a renewal/repeat of a prior export for which the data online-retention time has expired.
<table>

  <tr>
    <td style="width:10em" >RequestID</td>
    <td><input type="text" id="ReRequestID" name="ReRequestID" style="background-color:#FFF8DC;" value="" onChange="ExportNop();"></td>
    <td>Enter RequestID for repeat or prior export</td>
    <td><span id="ReStatusValue">&nbsp;</span></td>
  </tr>

  <tr id="ReNotifyRow">
    <td>Notify</td>
    <td><input id="ReExportNotify" type="text" name="Renotify" value="" onChange="ExportNop();" ></td>
    <td colspan="2">
      Provide your email address for notification.
    </td>
  </tr>

  <tr id="AjaxReExportRequestRow">
    <td colspan="4">
      re-<input id="ReExportButton" type="button" value="Submit Export Request" style="background-color:#D8D8D8" onClick="GetReExport();" >
    <span id="ReExportButtonMsg">Please only click once for re-export request.</span >
    </td>
  </tr>

</table>
</div> <!-- id="ReExportDiv" -->
</div>

<HR>
<P style="height:1px">
<div id="footer" style="vertical-align:bottom;text-align:center;">
<I>Home page for:</I>
<a href = '' id='FooterLink'><b>SDO-JSOC</b></a>
</div>

<script type="text/javascript">
$("ExportRequestForm").innerHTML = "";
// The onload function is called after this. It calls ProcessingInit() and ProcessingEnabled(). Don't do that here as well.
</script>

<div class='include-html' file-resource='private-host.html' target-element='PrivateHostElement' callback='private_host_callback'>
    <p id='PrivateHostElement' style='display:none'></p>
</div>
<div class='include-html' file-resource='request-form.html' target-element='ExportRequestForm' callback='on_load_init_callback'></div>

</body>
</html>
