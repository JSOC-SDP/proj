<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta HTTP-EQUIV="Content-Type" content="text/html; charset=iso-8859-1">
<title>JSOC Export Data</title>

<script type="text/javascript" src="tp/js/prototype.js"></script>
<script type="text/javascript" src="tp/js/cookies.js"></script>
<script type="text/javascript" src="tp/js/prototip.js"></script>
<link rel="stylesheet" type="text/css" href="tp/css/prototip.css">
<link rel='icon' type='image/png' href='icons/favicon.png'>

<script type="text/javascript">
function include_html(callback)
{
    var div_list = null;
    var div_index = null;
    var include_element = null;
    var file_resource = null;
    var target_element = null;
    var options = null;
    var resource = null;

    div_list = $$(".export-include-html");
    for (div_index = 0; div_index < div_list.length; div_index++)
    {
        include_element = div_list[div_index];
        file_resource = include_element.readAttribute("file-resource");
        target_element = $(include_element.readAttribute("target-element"));

        options =
        {
            method: "get",
            parameters: {},
            onSuccess: function(response)
            {
                var form_html = response.responseText;

                target_element.innerHTML = form_html;

                if (callback !== null)
                {
                    callback();
                }
            },
            onFailure: function(response)
            {
                alert("unable to locate request form page");
            },
            onComplete: function(response)
            {
            }
        };

        resource = window.location.origin + "/" + file_resource;

        new Ajax.Request(resource, options);
    }
}
</script>


<script type="text/javascript">

// Set CGI-BIN and include targets

// Eventually this should be put into a common file loaded by all the html web pages. To do that
// we need to copy code from exportdata.html to here that sets the base directory that is used
// when loading files with the <script> tag. Then we need to put the common file in that
// base directory, and we need to read it here. But for now, just hard-code this needed map.
var INTERNAL_SERVER = 'hmidb';
var EXTERNAL_SERVER = 'hmidb2';
var INTERNAL_WEBSERVER = 'solarwebx';
var INTERNAL_WEBSERVER_PORT = '8080';
var EXTERNAL_WEBSERVER = 'solarweb2';
var EXTERNAL_WEBSERVER_PORT = '8080';
var STANFORD_DOMAIN = 'stanford.edu';

// EB states
var EB_STATE_DISABLED = 'disabled';
var EB_STATE_ENABLED = 'enabled';
var EB_STATE_SUBMIT_ENABLED = 'submit_enabled';
var EB_STATE_SUBMIT = 'submit';
var EB_STATE_CANCEL_ENABLED = 'cancel_enabled';
var EB_STATE_PATH = 'path';
var EB_STATE_CANCEL = 'cancel';
var EB_STATE_CANCELED = 'canceled';
var EB_STATE_TIMEOUT = 'timeout';

var KEYWORD_CTYPE1 = 'CTYPE1';
var KEYWORD_CTYPE2 = 'CTYPE2';
var KEYWORD_LVL_NUM = 'LVL_NUM';
var AIA_SCALE_CTYPE1 = 'HPLN-TAN';
var AIA_SCALE_CTYPE2 = 'HPLT-TAN';
var KEYWORD_SPEC = '*spec*';
var KEYWORD_ONLINE = '*online*';
var KEYWORD_SIZE = '*size*';
var AIA_NAMESPACE = 'aia';
var NA = 'na';
var AIA_SCALE_NAXES = 2;
var AIA_LEV1P5 = 'aia.lev1p5';

// export types
var EXP_METH_FULL = 'url';
var EXP_METH_QUICK = 'url_quick';
var EXP_METH_STREAMED = 'url_direct';
var EXP_METH_FULL_FTP = 'ftp';
var EXP_METH_FULL_TAR = 'url-tar';
var EXP_METH_FULL_FTP_TAR = 'ftp-tar';

// protocol types
var PROTOCOL_JPEG = 'jpeg';
var PROTOCOL_MPEG = 'mpeg';
var PROTOCOL_MP4 = 'mp4';

var serverMap = new Array();
serverMap[EXTERNAL_WEBSERVER] = EXTERNAL_SERVER;
serverMap[EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN] = EXTERNAL_SERVER;
serverMap[INTERNAL_WEBSERVER] = INTERNAL_SERVER;
serverMap[INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN] = INTERNAL_SERVER;

var EXPORT_PATH = '/export';
var PENDING_REQUEST_RESOURCE = 'pending-request';
var PENDING_REQUEST_PATH = [ EXPORT_PATH, PENDING_REQUEST_RESOURCE ].join('/')
var RECORD_SET_RESOURCE = 'record-set';
var RECORD_SET_PATH = [ EXPORT_PATH, RECORD_SET_RESOURCE ].join('/');
var SERIES_RESOURCE = 'series';
var SERIES_PATH = [ EXPORT_PATH, SERIES_RESOURCE ].join('/');
var PREMIUM_EXPORT_REQUEST_RESOURCE = 'new-premium-request';
var PREMIUM_EXPORT_REQUEST_PATH = [ EXPORT_PATH, PREMIUM_EXPORT_REQUEST_RESOURCE ].join('/');
var PREMIUM_EXPORT_REQUEST_FROM_FORM_RESOURCE = 'new-premium-request-from-form';
var PREMIUM_EXPORT_REQUEST_FROM_FORM_PATH = [ EXPORT_PATH, PREMIUM_EXPORT_REQUEST_FROM_FORM_RESOURCE ].join('/');
var MINI_EXPORT_REQUEST_RESOURCE = 'new-mini-request';
var MINI_EXPORT_REQUEST_PATH = [ EXPORT_PATH, MINI_EXPORT_REQUEST_RESOURCE ].join('/');
var MINI_EXPORT_REQUEST_FROM_FORM_RESOURCE = 'new-mini-request-from-form';
var MINI_EXPORT_REQUEST_FROM_FORM_PATH = [ EXPORT_PATH, MINI_EXPORT_REQUEST_FROM_FORM_RESOURCE ].join('/');
var STREAMED_EXPORT_REQUEST_RESOURCE = 'new-streamed-request';
var STREAMED_EXPORT_REQUEST_PATH = [ EXPORT_PATH, STREAMED_EXPORT_REQUEST_RESOURCE ].join('/');
var RE_EXPORT_REQUEST_RESOURCE = '?';
var RE_EXPORT_REQUEST_PATH = [ EXPORT_PATH, RE_EXPORT_REQUEST_RESOURCE ].join('/');
var PENDING_REQUEST_STATUS_RESOURCE = 'pending-request-status';
var PENDING_REQUEST_STATUS_PATH = [ EXPORT_PATH, PENDING_REQUEST_STATUS_RESOURCE ].join('/');

var JSOC_FETCH = 'jsoc_fetch';
var DRMS_EXPORT = 'drms-export.sh';
var LOOKDATA = "lookdata";

// manage-request operations
var MR_OPERATION_CHECK = 'check';
var MR_OPERATION_CANCEL = 'cancel';

// manage-requests status codes
var MR_STATUS_UNKNOWN = 0;
var MR_STATUS_NOT_PENDING = 'StatusCode.NOT_PENDING';
var MR_STATUS_PENDING = 'StatusCode.PENDING';
var MR_STATUS_REQUEST_CANCELED = 'StatusCode.REQUEST_CANCELED';

var HTML_REQUESTID_DESC = 'This is your request ID; enter it below and click on "request status" to obtain the link to the data.';


</script>

<!-- Add functions for export processing (no more protocols js)  -->
<script type="text/javascript" src="js/processing.elements.js"></script>

<!-- Add list of seriesnames for which processing on export is not suportted -->
<script type="text/javascript" src="js/processing.exclusions.js"></script>

<!-- Add export email checking code. -->
<script type="text/javascript" src="js/user.registration.js"></script>

<style type="text/css">

#body { margin:0; padding:0; }
#header { position:relative; top:0; left:0; width:100%; background:#eee; }
#footer { position:fixed; bottom:0; left:0; width:100%; background:#eee; }
#ExportRecordSet { width:40em; font-size:100%; }
span.tip { background-color:blue;font-family:verdana;color:white;font-size:1em;font-weight:bold;}
.prototip { font:0.8em Arial, Helvetica, sans-serif; }
</style>

<script type="text/javascript">

// Protect page from accidental BACK button
var ON_BEFORE_UNLOAD_FXN = function()
{
    if ($('FileUploadFormID').retrieve('beforeunloadOverride', false))
    {
        $('FileUploadFormID').store({ 'beforeunloadOverride' : false })
        window.onbeforeunload = null;
    }

    if ($('FileUploadFormID').retrieve('beforeunloadEnabled', false))
    {
        // this message will never display - all browsers disallow this now;
        // return "Did you really mean to leave exportdata? Use CANCEL to stay here";
        window.onbeforeunload = function() { return 'this does not matter - never gets executed'; };
    }
};

var UPDATE_HTTP_REQUEST_COUNT = function()
{
    $("AjaxBusy").innerHTML = Ajax.activeRequestCount;

    if (Ajax.activeRequestCount == 0)
    {
        $("AjaxBusy").style.color = colorDarkGreen;
    }
    else
    {
        $("AjaxBusy").style.color = colorDarkRed;
    }
}

var MANAGE_REQUEST_ON_SUCCESS_INTERVAL = function(op, callback_fn)
{
    var success_fn = function(response)
    {
        var mr_response_obj = response.responseJSON;

        if (mr_response_obj !== null)
        {
            var status = mr_response_obj.drms_export_status;
            var state = $("ExportButton").retrieve('state', EB_STATE_DISABLED);
            var interval_fn_timer = $("ExportButton").retrieve('interval', null);
            var clear_interval_fn_timer = false;
            var interval_fn_timeout = $("ExportButton").retrieve('interval_timeout', null);
            var error = false;

            if (status.search(/errorcode/i) == 0)
            {
                // error calling MR - do nothing (don't change state)
                $("ExportButtonMsg").innerHTML = mr_response_obj.error_message;
                error = true;
            }
            else if (state == EB_STATE_TIMEOUT)
            {
                // do not do anything; set_eb_state_disabled() will take care of stopping the interval function
            }
            else if (op == MR_OPERATION_CHECK)
            {
                // action depends on state and status
                if (status == MR_STATUS_NOT_PENDING)
                {
                    if (state == EB_STATE_ENABLED)
                    {
                        state = EB_STATE_SUBMIT_ENABLED;
                        $('ExportButton').store({ "ajax-state" : "pre-click" });
                    }
                    else if (state == EB_STATE_SUBMIT_ENABLED)
                    {
                        // no change
                        state = EB_STATE_SUBMIT_ENABLED;
                    }
                    else if (state == EB_STATE_SUBMIT)
                    {
                        state = EB_STATE_SUBMIT;
                    }
                    else if (state == EB_STATE_CANCEL_ENABLED)
                    {
                        state = EB_STATE_PATH;
                        $('ExportButton').store({ "ajax-state" : "pre-click" });
                    }
                    else if (state == EB_STATE_PATH)
                    {
                        // do nothing
                        state = EB_STATE_PATH;

                        // stop interval function
                        clear_interval_fn_timer = true;
                    }
                    else if (state == EB_STATE_CANCEL)
                    {
                        // stop interval function
                        clear_interval_fn_timer = true;

                        // successful cancelation (or failure to cancel, followed by natural completion);
                        // back to the original pre-check-for-parameters state
                        state = EB_STATE_CANCELED;
                    }
                    else
                    {
                        // error
                        $("ExportButtonMsg").innerHTML = 'bad export button state[1] ' + state;
                        error = true
                    }
                }
                else if (status == MR_STATUS_PENDING)
                {
                    if (state == EB_STATE_ENABLED)
                    {
                        // cancel short-cut taken
                        state = EB_STATE_CANCEL_ENABLED;
                        $('ExportButton').store({ "ajax-state" : "pre-click" });

                        if (interval_fn_timer === null)
                        {
                            // start-up interval
                            internal_fn = CHECK_FOR_PENDING_REQUEST(true);
                            interval_fn_timer = setInterval(internal_fn, 1000);
                            $("ExportButton").store('interval', interval_fn_timer);
                        }

                        // do not allow the pending-request check to last forever (EB is in EB_STATE_CANCEL_ENABLED); 86400000 ==> 1 day
                        // reset the timeout if it is already set
                        if (interval_fn_timeout !== null)
                        {
                            clearTimeout(interval_fn_timeout);
                        }

                        interval_fn_timeout = setTimeout(function () { $("ExportButton").store('state', EB_STATE_TIMEOUT); set_eb_state_disabled(false);}, 86400000);
                        $("ExportButton").store('interval_timeout', interval_fn_timeout);
                    }
                    else if (state == EB_STATE_SUBMIT_ENABLED)
                    {
                        // error - can't happen
                        $("ExportButtonMsg").innerHTML = 'bad export button state[2] ' + state;
                        error = true
                    }
                    else if (state == EB_STATE_SUBMIT)
                    {
                        state = EB_STATE_SUBMIT;
                    }
                    else if (state == EB_STATE_CANCEL_ENABLED)
                    {
                        // no change
                        state = EB_STATE_CANCEL_ENABLED;
                    }
                    else if (state == EB_STATE_PATH)
                    {
                        // error - can't happen
                        $("ExportButtonMsg").innerHTML = 'bad export button state[3] ' + state;
                        error = true
                    }
                    else if (state == EB_STATE_CANCEL)
                    {
                        // do nothing - wait for cancelation (or natural completion) to occur
                        state = EB_STATE_CANCEL;
                    }
                    else
                    {
                        // error
                        $("ExportButtonMsg").innerHTML = 'bad export button state[4] ' + state;
                        error = true
                    }
                }
                else
                {
                    // error
                    $("ExportButtonMsg").innerHTML = 'unexpected manage-request status ' + status;
                    error = true;
                }
            }
            else if (op == MR_OPERATION_CANCEL)
            {
                if (state != EB_STATE_CANCEL_ENABLED)
                {
                    $("ExportButtonMsg").innerHTML = 'bad export button state[5] ' + state;
                    error = true;
                }
                else if (status == MR_STATUS_REQUEST_CANCELED)
                {
                    $("ExportButtonMsg").innerHTML = 'unexpected manage-request status ' + status;
                    error = true;
                }
            }
            else
            {
                // bad operation
                $("ExportButtonMsg").innerHTML = 'bad manage-request operation ' + op;
                error = true;
            }

            if (error)
            {
                // stop interval function
                clear_interval_fn_timer = true;

                state = EB_STATE_DISABLED;
            }

            if (state == EB_STATE_DISABLED)
            {
                // either state WAS EB_STATE_CANCEL, or error; call special function to initialize states
                // back to the beginning
                set_eb_state_disabled(false);
            }
            else
            {
                if (interval_fn_timer !== null && clear_interval_fn_timer)
                {
                    clearInterval(interval_fn_timer);
                    $("ExportButton").store('interval', null);

                    if (interval_fn_timeout !== null)
                    {
                        clearTimeout(interval_fn_timeout);
                        $("ExportButton").store('interval_timeout', null);
                    }
                }

                $("ExportButton").store('state', state);
                update_export_buttons();
            }
        }

        if (callback_fn)
        {
            callback_fn();
        }
    }

    return success_fn;
}

// handles only a subset of all EB states since on-demand checks are used only in
// certain circumstances
var MANAGE_REQUEST_ON_SUCCESS_ON_DEMAND = function(callback_fn)
{
    var success_fn = function(response)
    {
        var mr_response_obj = response.responseJSON;

        if (mr_response_obj !== null)
        {
            var status = mr_response_obj.drms_export_status;
            var state = $("ExportButton").retrieve('state', EB_STATE_DISABLED);
            var error = false;

            if (status.search(/errorcode/i) == 0)
            {
                // error calling MR - do nothing (don't change state)
                $("ExportButtonMsg").innerHTML = mr_response_obj.error_message;
                error = true;
            }
            else if (state != EB_STATE_ENABLED && state != EB_STATE_DISABLED)
            {
                // for enabled, disabled state only
                $("ExportButtonMsg").innerHTML = 'unexpected export-button state ' + state.toString();
                error = true;
            }
            else
            {
                // action depends on status
                if (status == MR_STATUS_NOT_PENDING)
                {
                    if (state == EB_STATE_ENABLED)
                    {
                        state = EB_STATE_SUBMIT_ENABLED;
                        $('ExportButton').store({ "ajax-state" : "pre-click" });
                    }
                }
                else if (status == MR_STATUS_PENDING)
                {
                    if (state == EB_STATE_ENABLED)
                    {
                        state = EB_STATE_CANCEL_ENABLED;
                        $('ExportButton').store({ "ajax-state" : "pre-click" });
                    }
                    else if (state == EB_STATE_DISABLED)
                    {
                        // set the EB state to EB_STATE_CANCEL_ENABLED (the user has a pending export request)
                        state = EB_STATE_CANCEL_ENABLED;
                        $('ExportButton').store({ "ajax-state" : "pre-click" });
                    }
                    else
                    {
                        $("ExportButtonMsg").innerHTML = 'bad export button state ' + state;
                        error = true
                    }
                }
                else
                {
                    // unexpected status
                    $("ExportButtonMsg").innerHTML = 'unexpected manage-request status ' + status;
                    error = true;
                }
            }

            $("ExportButton").store('state', state)
            update_export_buttons();
        }

        if (callback_fn)
        {
            callback_fn();
        }
    }

    return success_fn;
}

var MANAGE_REQUEST_XHR = function(address, op, interval, callback_fn)
{
    // we have to deal with the db-server pass-through stuff
    var export_app_arguments = null;
    var options = null;
    var origin = null;
    var db_host = null;
    var on_success = null;
    var method = null;

    origin = ExportOrigin(null);

    if (origin[0] == 'extServer')
    {
        db_host = EXTERNAL_SERVER;
    }
    else
    {
        db_host = INTERNAL_SERVER;
    }

    export_app_arguments = { "address" : address, "db-host" : db_host };

    if (interval === null || interval === undefined)
    {
        // do nothing on success; the caller does not want to check on results
        on_success = function()
        {
            if (callback_fn)
            {
                callback_fn();
            }
        };
    }
    else if (interval)
    {
        on_success = MANAGE_REQUEST_ON_SUCCESS_INTERVAL(op, callback_fn);
    }
    else
    {
        on_success = MANAGE_REQUEST_ON_SUCCESS_ON_DEMAND(callback_fn);
    }


    method = (op === MR_OPERATION_CHECK) ? 'get' : 'post';
    options =
    {
        method: method,
        onSuccess: on_success,
        onFailure: function(response)
        {
            var mr_response_obj = response.responseJSON;
            var error_msg = mr_response_obj.error_message;

            // true ==> do not allow the user to change email address (must reload to do that)
            set_eb_state_disabled(true);

            if (callback_fn !== null && callback_fn !== undefined)
            {
                callback_fn();
            }
        },
        on428: function(response)
        {
            var mr_response_obj = response.responseJSON;
            var error_msg = mr_response_obj.error_message;

            // true ==> do not allow the user to change email address (must reload to do that)
            set_eb_state_disabled(true);

            if (callback_fn !== null && callback_fn !== undefined)
            {
                callback_fn();
            }
        }
    };

    if (method === 'post')
    {
        options['postBody'] = JSON.stringify(export_app_arguments);
        options['contentType'] = 'application/json';
    }
    else
    {
        options['parameters'] = export_app_arguments;
    }
    new Ajax.Request(window.location.origin + PENDING_REQUEST_PATH, options);
}

// export button (EB) states:
// 1. DISABLED - the Check Params for Export button (CPE) has not yet been clicked; interval function (XHR) not running OR
//               failure of any kind anywhere in state graph OR CANCEL + IF "not pending"
// 2. ENABLED - CPE clicked, parameters ready, interval function (IF) running
// 3. SUBMIT_ENABLED - ENABLED + IF "not pending"
// 4. CANCEL_ENABLED - ENABLED + IF "pending"
// 5. CANCEL - SUBMIT_ENABLED + EB clicked
// 6. PATH - CANCEL_ENABLED + IF "not pending"
//
// EB labels
// 1. "not ready" - for DISABLED OR ENABLED
// 2. "submit" - for SUBMIT_ENABLED
// 3. "cancel" - for CANCEL_ENABLED
// 4. "wait" - for CANCEL
// 5. "get path" - for PATH
var CHECK_FOR_PENDING_REQUEST = function(interval)
{
    // the user has already clicked on the Check Params for Export button; the 'submit' button is currently disabled
    var manage_export_fn = function(callback_fn)
    {
        var address = $("ExportNotify").value;
        var op = MR_OPERATION_CHECK;
        var xhr = MANAGE_REQUEST_XHR;

        xhr(address, op, interval, callback_fn);
     }

     return manage_export_fn;
}

// states (the button label); destination states at arrow head
//   disabled: check params not clicked yet
//      not called
//   submit:
//      not called
//   cancel:
//      --> disabled
//   path:
//      not called
var CANCEL_PENDING_REQUEST = function(interval)
{
    var manage_export_fn = function(callback_fn)
    {
        var address = $("ExportNotify").value;
        var op = MR_OPERATION_CANCEL;
        var xhr = MANAGE_REQUEST_XHR;

        xhr(address, op, interval, callback_fn);
     }

     return manage_export_fn;
}

function OnEnterKey(evt,action)
  {
  var keynum;
  var keychar;
  if(window.event) // IE
    keynum = evt.keyCode;
  else if(evt.which) // Netscape/Firefox/Opera
    keynum = evt.which;
  if(keynum == 13)
    action();
  keychar = String.fromCharCode(keynum);
  return keychar;
  }

var previousSeries = "";
function NotifyProcessingCode()
{
    // called when RecordSet is changed.
    // Set flags to alert processing or method options here.
    // variables here will usually be defined in exportdata.d/processing.js
    // or exportdata.d/export_request_form.html

    // SeriesName is determined asynchronously.
    if (SeriesName == previousSeries)
    {
        SetProcessing(-1, null); // Do not initialize all processing options to their defaults.
    }
    else
    {
        SetProcessing(-2, null); // Init all processing options to their defaults.
    }

    previousSeries = SeriesName;
}

// Global vars
var Host = location.host;
var Internal = 0;
var SeriesName;
var SeriesInfo;
var AiaLev1AttributesGlobal = null; // set in GetDefaultFormat()
var AiaLev1KeywordsGlobal = null; // set in GetDefaultFormat()
var firstRealSegment;
var RequestID;
var RecordLimit;
var RecordCount = null; // Initialized in initVars(), Modified in GetRSCount()
var ExportQueryOK;
var ExportRecordSetOK;
var ExportProcessingOptions;
var ExportUserOK;
var TipsEnabled;
var TipsCreated = 0;
var args;
var state=0;
var ExportProcessingArgs = "";
var ProcessingObj = null;
var ProcessingAllowed = 1;

// Export processing globals.
var ExportProcessingArgsPoll = null;
var ExportProcessingOK = null;

// Protocol global vars
var ExportCompressOK;
var ExportCompressValue = "";
var ProtocolOptionsSet = 0;

// Misc vars
var firstTimePrime;
var expURL;
var IsAia = null;
var IsAiaLev1 = null; // is true, then we need to use the default file format string for aia.lev1p5

// Colors
var colorNeutral = "#D4D0C8";
var colorPreset = "D8D8D8";
var colorOptionSet = "#FFCC66";
var colorPink = "#FFD8D8";
var colorDarkPink = "#FFB0B0";
var colorRed = "#D88080";
var colorDarkRed = "#C00000";
var colorRealRed = "#FF0000";
var colorDarkishRed = "#FF8080";
var colorBrightOrange = '#F9441F';
var colorDarkBlue = "#0000B0";
var colorWhite = "#FFFFFF";
var colorBlack = "#000000";
var colorGreen = "#80FF80";
var colorDarkGreen = "#009000";
var colorYellow = "#FFF8DC";


// tester success

function initVars()
{
  Host = location.host;
  if (Host == "jsoc2.stanford.edu")
    Internal = 1;
  else
    Internal = 0;
  SeriesName = "";
  RequestID = "";
  RecordCount = null;
  $('ExportRecordSet').store({ 'count': RecordCount });
  RecordLimit = 0;
  ExportRecordSetOK = 0;
  ExportQueryOK = 0;
  ExportUserOK = 0;
  TipsEnabled = 1;
  firstTimePrime = "";
  ProcessingAllowed = 1;

  // Init processing
  ExportProcessingArgs = "";
  ExportProcessingOK = null;
  ExportProcessingArgsPoll = null;

  // Init protocols
  ExportCompressOK = 1;
  ProtocolOptionsSet = 0;

    // If the page is being loaded, then exportdataLoaded is true. If the reset page button was clicked, then
    // exportdataLoaded is true as well. So, there is no need to check for a true value for exportdataLoaded.
    ProcessingInit();

    ProcessingEnabled();
    update_protocol_ui(true);

    // Enable the reset button, now that the page has completed loaded.
    $("ResetPageButton").disabled = false;


  // if (state < 2)
  // Form init
    {
    $("ExportRequestor").value = "";
    $("RequestIdPlace").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("StatusLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("TarFileLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("ExportStatus").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("StatusDataLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $('ExportRecordSet').value = "";
    $("ExportCheckMsg").innerHTML = "";
    $("ExportCheckMsg").style.color = colorRealRed;
    // Processing
    $("ProcessRow").style.display="none";
    $("ExportProcessingHidden").value = "no_op";
    $("ProcessingCheckbox").checked = 0;
    // Protocols
    $("ProtocolRow").style.display="none";
    $('ExportProtocol').selectedIndex = 1;
    $("ExportProtocolHidden").value = "FITS";
    $("ExportCompress").selectedIndex = 0;
    $("CompressRow").style.display="none";
    $("ProtocolImageOptions").style.display="none";

    $('ExportMethod').selectedIndex = 2;
    $('ExportFilenameFmt').value = "{seriesname}.{recnum:%lld}.{segment}";
    $('ExportFilenameFmt').store({ 'valid' : true });
    $("ExportButton").value = "Submit Export Request";
    $("ExportButtonMsg").innerHTML = "Please only click once for export request.";
    $("ExportButton").style.backgroundColor = colorRed;
    $("ExportButton").disabled = true;
    $("RecordSetRow").style.display="table-row";
    $("RecordCountRow").style.display="table-row";
    $("FilenameFmtRow").style.display="none";
    $('RequestorRow').style.display = 'table-row';
    $('NotifyRow').style.display = 'table-row';
    $('FileUploadCheckbox').checked = 0;
    $("ExportOpID").value = "exp_request";
    $("ReRequestID").value = "";
    $("ReExportDiv").style.display = "none";
    $("TarFileLocationRow").style.display = "none";
    $("KeywordFileLocationRow").style.display = "none";
    $("ShowQueryCheckbox").checked = 0;
    $("StatusRequestID").value = "";
    
    update_export_method_ui(true);
    }
    
    // removes all registration statuses
    email_initVars($("ExportNotify"), $("ExportRequestor"));

    set_eb_state_disabled(false);

    $('ExportButton').store({ "reset" : true });
    update_request_section_ui(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);

    $('StatusButton').store({ "reset" : true });
    update_status_section_ui(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);

    file_upload_on_init();
}

// tester success

function getargs()
{
    // as far as I can tell, state never equals anything but 0 here; it gets set to 2 in GetExport() - called when user clicks 'submit',
    // it gets set to 2 in GetReExport, it gets touched in ProcessExportResponse() - that function first sets to 3 then to 0, setting to
    // 0 always, and it gets set to either 2 (error jsoc_fetch status) or 1 (non-error jsoc_fetch status) after jsoc_fetch op=status returns
    // but that state never gets used anywhere; the state is only read here, and it is always 0
    //
    // it seems as if 2 means something is asynchronously evaluating whether or not the URL is going to be 'good', 1 means
    // we have a good URL stored in `search`, and 0 means get the URL from the browser address box; so, this function
    // will clear-out jsoc_fetch args if we don't know the status of the existing args, it will use the known-to-be-good
    // args if we have good args stored in `search`, and it will get the args from the URL otherwise, overwriting the
    // `search` args stored in the cookie; but the other functions will force the last option by setting the state to 0, even
    // if we have good args in the `search` attribute
    state = Cookie.getData("state");

    if (state == 1)
    {
        // the export-request record-set is stored in the 'search' cookie attribute; the limit and requestid might also be stored
        var exportargs = Cookie.data["search"];

        if (exportargs != undefined)
        {
            exportargs = decodeURIComponent(exportargs);
            exportargs = exportargs.substr(1);
            exportargs = exportargs.replace(/\?/g,"QUESTIONMARK");
            args = exportargs.toQueryParams();
            if (args.ds == undefined)
            {
                args.ds = "";
            }

            args.ds = args.ds.replace(/QUESTIONMARK/g, "?");
        }
        else
        {
            args = new Object;
            args.ds = "";
        }
    }
    else if (state > 1)
    {
        args = new Object;
        args.ds = "";
        args.requestid = "";
        args.limit= "none";
    }
    else
    {
        // cookie state 0 - attempt to get the record-set specification (ds) from the exportdata.html URL
        var exportargs = location.search;

        exportargs = decodeURIComponent(exportargs);
        exportargs = exportargs.substr(1);
        exportargs = exportargs.replace(/\?/g,"QUESTIONMARK");
        args = exportargs.toQueryParams();
        if (args.ds == undefined)
        {
            args.ds = "";
        }

        args.ds = args.ds.replace(/QUESTIONMARK/g, "?");
        state = 1;
        Cookie.setData("state", state);
        Cookie.setData("search", location.search);
    }

    // load email address and username from cookie
    email_getargs($("ExportNotify"), $("ExportRequestor"));

    return args;
}

// cookie state is 0
function on_load_init_callback()
{
    var needcount = 0;

    // fix ImageSize options
    for (index = 0; index < $('ImageSize').options.length; index += 1)
    {
        $('ImageSize').options[index].value = $('ImageSize').options[index].value.trim().substr(4);
        alert('size option ' + $('ImageSize').options[index].value);
    }




    Cookie.init({ "name" : "exportdata", "expires" : 14});
    initVars(); // This call runs code that requires RecordSet to be set. However, that is not true
              // before it is set below [ $("ExportRecordSet").value = args.ds ]

    if (Internal)
    {
        $("header_logo").href="http://jsoc2.stanford.edu";
        $("footer_link").href="http://jsoc2.stanford.edu";
    }

    state = 0;
    Cookie.setData("state", state);
    args = getargs();

    if (args.ds)
    {
        $('ExportRecordSet').value = args.ds;
        needcount = 1;
    }

    if (args.id)
    {
        RequestID = args.id;
    }

    if (args.limit)
    {
        $("ExportRecordLimit").value = args.limit;

        if (args.limit == "none")
        {
            RecordLimit = 0;
        }
        else
        {
            RecordLimit = args.limit;
        }
    }

  if (needcount && $('ExportRecordSet').value != "")
    {
        if (GetRSCount(null))
        {
            $("ExportCheckMsg").innerHTML = "Invalid record-set specification";
        }

        GetDefaultFormat();
    }

    CreateTips();
    $("TipsOnOffButton").value = "Turn Help Off";
    $('RSCountPlace').up().setStyle({ 'max-width': '22em', 'overflow-wrap': 'break-word', 'word-wrap': 'break-word', 'word-break': 'break-all' });

    // make a handler for the form-changed event; if the form changes, we want to set a flag that enables the beforeunload handler;
    // initially disable the beforeunload handler
    $('FileUploadFormID').observe('change', function(event) { $('FileUploadFormID').store({ 'beforeunloadEnabled': true }); });
    $('FileUploadFormID').store({ 'beforeunloadEnabled': false });

    // protect from back button
    setInterval(ON_BEFORE_UNLOAD_FXN, 500);

    // start periodic function to update active HTTP requests counter
    setInterval(UPDATE_HTTP_REQUEST_COUNT, 500);

    set_eb_state_disabled(false);
    check_for_cancel_enabled_shortcut();

    window.focus();
}

function OnLoadInit()
{
    include_html(on_load_init_callback);
}

function ReInitPage()
  {
  Cookie.setData("state", 0);
  OnLoadInit();
  }

// tester success

function MainTips(tipstyle)
  {
  if (TipsCreated == 0)
    {
    new Tip('RecordFromFileHelp','Allows user to provide a RecordSet list in a file.  ' +
        'The file should contain recordSet specifiers in the format allowed by drms_open_records include files.  ' +
        'See http://jsoc.stanford.edu/jsocwiki/AllAboutJsocNames.',tipstyle);
    new Tip('RecordSetHelp','RecordSet to be exported. May be imported on call and/or may be entered directly here. ' +
        'May be filled in by series select in Im_patch processing option.',tipstyle);
    new Tip('CallLookdataHelp','Start lookdata.html in a different tab/window with RecordSet given.  ' +
        'If a JSOC Lookdata window already exists, the first one will be replaced by this call.',tipstyle);
    new Tip('RecordLimitHelp','RecordSet record limit. Max number of records to export.  Modifies RecordSet. ' +
        'Value should be "none" or a number. Number > 0 counts from start of RecordSet.  Negative number counts ' +
        'from high end of RecordSet.  0 means no limit',tipstyle);
    new Tip('RecordCountHelp','RecordSet record count.  Update this to repeat export with new method, email, etc.  ' +
        'There is presently a limit to the memory space allocated for record queries which restricts AIA lev1 ' +
        'requests to about 15,000 records and HMI X_45s or X_720s data to about 32,000 records.  ' +
        'The limit depends on number of keywords in each record.  This limit will be eased in the future.',tipstyle);
    new Tip('MethodHelp','Handshake method to be used in the process of doing the export and to fetch the data files. ' +
        '"url-quick" is the fastest but can only be used if the data is online and will be exported "as-is". ' +
        '"url-direct" is has the constraints of url_quick with the limit of one file per request but it will ' +
        'automatically do the postprocessing specified in the "protocol" instruction. For "url_direct" the file ' +
        'is returned directly to your browser rather than returning to the export page.  If you have the ' +
        'set to load some fits reader program when the mime-ype "fits" is encountered you will see the image promptly. ' +
        '"url" will result in a temporary directory being created and the URL to that directory be returned to you after ' +
        'a handshake process using the RequestID provided. ' +
        '"ftp" is like "url" but the returned links will be to an ftp directory. ' +
        ' A "-tar" suffix will cause a tar of all files in the request to be included with the separate files. ' +
        'NOTE: do not use "-tar" unless you really need it since that will generate an extra copy of the data.',tipstyle);
    new Tip('FilenameFmtHelp','Filename format to be used in the process of doing the export.  ' +
        'The filename format is a template used to construct a filename for each segment of each record requested.  ' +
        'The template consists of literal characters and substitution tokens enclosed in "{}".  ' +
        'The special words: seriesname, recnum, and segment are replaced with the series_name, the record number, ' +
        'or the segment name.  The element {#} will generate an increasing number, ' +
        'with optional layout e.g. default is {#:%05d}. ' +
        'Any keyword in the record may also be used.  Optional layout may be provided after a ":".' +
        'Special format options are available for type TIME keywords: A leading "A" will strip "." and ":" from the time and ' +
        'a "D" will strip the "." and ":" but will insert "@" around the date components to allow easy scripts ' +
        'to move the exported files into date structured directory trees. ' +
        'It is wise to include enough of the "prime-keys" to make a unique filename.  ' +
        'The default format template is made from series structure.',tipstyle);
    new Tip('ProcessingHelp','Processing to be done to the data prior to export. ' +
        ' Select from drop-down list for details.',tipstyle);
    new Tip('ProtocolHelp','Data storage protocol for data files to be fetched.  ' +
        '<br>"Fits" causes the data to be converted to full fits files with header information filled from the DRMS records.  ' +
        '<br>"As-is" leaves the data as it is used inside the JSOC DRMS system, ' +
        'with the header metadata stored in the database rather than with the data file.  ' +
        '"As-is" is faster since the data does not need to be rewritten.  In as-is mode the header data is ' +
        'provided in a tab-delimited file named {RequestID}.keywords.txt. <br> The "jpeg" option will ' +
        ' yield  jpeg images of the data and the <br>"mpg" or "mp4" options will ' +
        ' yield a movie along with the jpeg images that make up the frames in the movie.<br> ' +
        'Default colortables and scaling for protocols making images are provided but may be altered.',tipstyle);
    new Tip('CompressHelp','Compression parameters to be used by the cfitsio library.  ' +
        'One comma separated string for each segment name in your export will be generated. ' +
        'Use "**NONE**" to indicate uncompressed FITS files desired. ' +
        'Note that e.g. AIA data can be more than 5 times larger if not compressed.  Do not request uncompressed ' +
        'exports for more than a few files.',tipstyle);
    new Tip('RequestorHelp','Optional place for your name, this will be used later when we have a way of saving your ' +
        'preferred export options.  This value will be saved in a Cookie if allowed.',tipstyle);
    new Tip('NotifyHelp','Email address to be used to notify you when the export is complete and ready to be ' +
        'fetched using the RequestID. NOTE - an email address is required for exports from jsoc2.',tipstyle);
    new Tip('SendFileHelp','This action will submit the export request with the RecordSet specified in the upload file.',tipstyle);
    new Tip('CheckParamHelp','This button is required to verify all fields used to specify the export request ' +
        'have been filled in in a consistent way.  If all is OK, the Submit button will be enabled.  A new Check ' +
        'button press is required before each export request.',tipstyle);
    new Tip('SubmitHelp','This button does the actual export request submission.  After a submit request the button ' +
        'action is changed to a Status Request which can be used to get the response from JSOC.  For all but url-direct and ' +
        'url-quick methods a RequestID tag will be returned a few seconds after a submit request.  ' +
        'This tag will be used to identify ' +
        'your export request inside JSOC and may be used at a later time to request the processing status and to ' +
        'obtain a link to your data.',tipstyle);
    new Tip('FetchCheckboxHelp','When this box is checked, the URL string that will be sent to the JSOC jsoc_fetch ' +
        'command will be shown when the "Check Params for Export" button is pressed.  This string can be used to ' +
        'help you develop script driven exports and to see how exportdata functions.',tipstyle);
    }
  };

// tester success

</script>
<script type="text/javascript" src="js/tooltips.definitions.js"></script>
<script type="text/javascript">

function CreateTips()
  {
  var tipstyle =
    {
    style:'protoblue',
    hook:{target:'topRight',tip:'bottomLeft'},
    stem:'bottomLeft',
    closeButton:false,
    hideAfter:5,
    hideOn:'click',
    showOn:'click',
    border:3,
    radius:3,
    width:300,
    };

  MainTips(tipstyle);
  AddOnTips(tipstyle, Tip);
  TipsCreated = 1;
  $$("span.tip").each(function(showspan){showspan.show();});
  }

function HideTips()
  {
  $$("span.tip").each(function(hidespan){hidespan.hide();});
  Tips.hideAll();
  }

function ToggleHelp()
  {
  if (TipsEnabled)
    {
    HideTips();
    $("TipsOnOffButton").value = "Turn Help On";
    TipsEnabled = 0;
    }
  else
    {
    CreateTips();
    $("TipsOnOffButton").value = "Turn Help Off";
    TipsEnabled = 1;
    }
  }

// tester success
</script>
<script type="text/javascript">


// Check list of seriesnames for which processing options are not available for SeriesName spec given
function CheckNoProcessingList()
  {
  var n = NoProcessingList.length;
  var i;
  var result = 1;
  var prior = ProcessingAllowed;
  for (i=0; i<n; i++)
    {
        if (SeriesName == NoProcessingList[i])
        {
            result = 0;
            break;
        }
    }
  ProcessingAllowed = result;
  if (ProcessingAllowed != prior)
    ProcessingEnabled();
  }

// tester success
</script>
<script type="text/javascript">


function file_upload_on_init()
  {
  ExportQueryOK = 0;
  $('ExportRecordSet').value = "";
  ExportRecordSetOK = 0;
  $('FileUploadCheckbox').checked = 0;
  $("RSCountPlace").innerHTML = "";
  $("ExportButton").value = "Submit Export Request";
  $("AjaxExportRequestRow").style.display="table-row";
  $('FileUploadInfoRow').style.display="none";
  $("RecordSetRow").style.display="table-row";
  $("RecordCountRow").style.display="table-row";
  $("ExportOpID").value = "exp_request";
  }

// tester failure

// called when record set from file checkbox checked/unchecked
function FileUploadWanted()
{
    // value after user has checked/unchecked the box
    var box_checked = $('FileUploadCheckbox').checked;

    alert("file upload wanted");
    // dirty since last time the CP button was clicked
    set_eb_state_disabled(true);

    ExportQueryOK = 0;
    if (box_checked)
    {
        // box is now in checked state
        alert("effl 0");
        $('ExportRecordSet').value = '*file*';
        ExportRecordSetOK = 1;
        $('RecordSetRow').style.display = 'none';
        $('RecordCountRow').style.display = 'none';
        $('ExportOpID').value = 'exp_request';
        $('FileUploadRow').style.display = 'table-row';
        $('FileUploadInfoRow').style.display = 'none';
        $('AjaxExportRequestRow').style.display = 'none';
    }
    else
    {
        // box is now in unchecked state
        alert("effl 1");
        $('FileUploadInfoRow').style.display='none';
        file_upload_on_init();
        $('FileUploadRow').style.display='none';
    }
}

// tester success
</script>
<script type="text/javascript">


function insertOption(list,text,note)
  {
  var y=document.createElement('option');
  y.value=text;
  if (note.length)
    y.text = text + "  --- " + note;
  else
    y.text = text;
  var x = $(list);
  try
    {
    x.add(y,null); // standards compliant
    }
  catch(ex)
    {
    x.add(y); // IE only
    }
  }

function create_export_endpoint_arguments(method)
{
    var access = null;
    var export_package = null;
    var argument_argument_obj = null;
    var argument_namespace = null;
    var file_format = null;
    var file_format_args = null;
    var export_endpoint_arguments = null;

    if (method.indexOf('ftp') != -1)
    {
        access = 'ftp';
    }
    else
    {
        access = 'http';
    }

    export_package = {};
    if (method.indexOf('tar') != -1)
    {
        export_package = { "type" : "tar" };
    }
    else
    {
        export_package = { "type" : null };
    }

    argument_argument_obj = unserialize_arguments($('ExportProtocolHidden').value);
    argument_namespace = Object.keys(argument_argument_obj)[0];
    if (Object.keys(argument_argument_obj[argument_namespace]).length > 0)
    {
        file_format = argument_namespace.toLowerCase();

        // file_format_args are extra arguments for the protocol types of FITS, JPEG, MPEG, and MP4
        if (file_format != 'fits' && file_format != 'jpg' && file_format != 'mpg' && file_format != 'mp4')
        {
            // error
        }
        else
        {
            file_format_args = argument_argument_obj[argument_namespace];
        }
    }
    else
    {
        file_format = $('ExportProtocol').options[$('ExportProtocol').selectedIndex].value.toLowerCase();
    }

    if (method === EXP_METH_QUICK)
    {
       export_endpoint_arguments = { "file_name_format" : $('ExportFilenameFmt').value, "number_records" : parseInt($('ExportRecordLimit').value), "specification" : $('ExportRecordSet').value }; 
    }
    else if (method == EXP_METH_STREAMED)
    {
        export_endpoint_arguments = { "file_name_format" : $('ExportFilenameFmt').value, "specification" : $('ExportRecordSet').value };
    }
    else
    {
        export_endpoint_arguments = { "access" : access, "package" : export_package, "specification" : $('ExportRecordSet').value, "file_format" : file_format, "file_format_args" : file_format_args, "file_name_format" : $('ExportFilenameFmt').value, "number_records" : parseInt($('ExportRecordLimit').value), "processing" : ProcessingObj };
    }

    alert('exp args ' + JSON.stringify(export_endpoint_arguments));

    return export_endpoint_arguments;
}


function MakeFileUploadRequest()
{
    var method = $('ExportMethod').options[$('ExportMethod').selectedIndex].value.toLowerCase();
    var origin = null;
    var db_host = null;
    var export_endpoint_arguments = null;
    var action = null;

    alert("make file upload");

    if (CheckExportParams() == 0)
    {
        return;
    }

    origin = ExportOrigin(null);

    if (origin[0] == 'extServer')
    {
        db_host = EXTERNAL_SERVER;
    }
    else
    {
        db_host = INTERNAL_SERVER;
    }

    export_endpoint_arguments = create_export_endpoint_arguments(method);

    if (method === EXP_METH_QUICK)
    {
        action = window.location.origin + MINI_EXPORT_REQUEST_FROM_FORM_PATH;
    }
    else if (method == EXP_METH_STREAMED)
    {
        // error
    }
    else
    {
        action = window.location.origin + PREMIUM_EXPORT_REQUEST_FROM_FORM_PATH;
    }

    // $('FileUploadFormID').action = action;
    // $('FileUploadFormID').submit();

    $('EFormAddress').value = $('ExportNotify').value.trim();
    $('EFormDbHost').value = db_host;
    $('EFormArguments').value = JSON.stringify(export_endpoint_arguments);
    $('EFormRequestor').value = $('ExportRequestor').value.trim();

    alert('form data ' + $('EFormAddress').value + ' ' + $('EFormDbHost').value + ' ' + $('EFormArguments').value + ' ' + $('EFormRequestor').value);

    $('ExportFormElement').action = action;
    $('ExportFormElement').submit();
}

// called when file-upload response has loaded into the FileUploadFrame iframe
function process_file_upload_response()
{
    var iframe_html = null;
    var response = null;

    iframe_html = window.frames[0].document.getElementsByTagName("body")[0].innerHTML;
    if (iframe_html.length > 0)
    {
        response = iframe_html.responseJSON;
        ProcessExportResponse(response);
    }    
}

function file_upload_on_complete()
{
    // form-submission response has been completely processed, without error; the request might be processed
    // asynchronously, in which case the get-status code will finalize the remaining export UI; one file-upload
    // error, the file picker and submit button remain displayed
    var upload_response_element = window.frames[0].document.getElementsByTagName("body")[0];

    if ($('FileUploadCheckbox').checked && upload_response_element.innerHTML.length > 0)
    {
        //delete downloaded data
        upload_response_element.innerHTML = "";

        // hide file-upload file picker, submit button
        $('FileUploadRow').style.display = "none";

        // show the results of the file upload
        $('FileUploadInfoRow').style.display = "table-row";
    }
}

function CallLookdata()
  {
  var recset = $('ExportRecordSet').value;
  var posbracket = recset.indexOf("[");
  var posRbracket = recset.lastIndexOf("]");
  var posCurlbracket = recset.indexOf("{");
  var firstbracket = posbracket>=0 ? posbracket : posCurlbracket;
  var seriesname = (firstbracket == -1 ? recset : recset.substring(0,firstbracket));
  var recfilt = (posbracket >=0 ? recset.substring(posbracket,posRbracket+1) : "");
  var lookdataargs="ds="+seriesname;

  if (recfilt.length > 0)
    {
        // This is the filter used to select a series in lookdata.html, step 1.
        lookdataargs += "&rs=" + recfilt
    }

    // I guess the RecordCount can never be negative.
    if (RecordCount !== null && RecordCount > 0)
    {
        lookdataargs += "&n=" + RecordCount.toString();
    }

  LookdataWindow=window.open("http://" + Host + "/ajax/" + LOOKDATA + ".html?" + encodeURIComponent(lookdataargs), "JSOC Lookdata");
  LookdataWindow.window.focus();
  }

// tester success
</script>
<script type="text/javascript">


var RSCountActiveMSg = "Getting count - wait...";

// Class
function WlSeriesInfo()
{
}

// onSuccess() function for ParseSpec() 
function CreateParseSpecResponse(processSpec)
{
    var parseSpecResponseCallback = processSpec;

    var ParseSpecResponse =
        function(response)
        {
            var gri_response_obj = response.responseJSON;
            var status = null;
            var error_message = null;

            if (gri_response_obj !== null)
            {
                status = gri_response_obj.drms_export_status;
                error_message = null;

                if (status.search(/errorcode/i) == 0)
                {
                    error_message = 'failure parsing record-set specification: ' + JSON.stringify(gri_response_obj.error_message);
                }

                // gri_response_obj contains parsed spec data; use it
                // callback closure
                if (parseSpecResponseCallback !== null)
                {
                    parseSpecResponseCallback(error_message, gri_response_obj);
                }
            }
        };

    return ParseSpecResponse;
}

</script>
<script type="text/javascript">

// parses record-set specification, but does not validate parts (could return a string which is a valid series name, but
// of a series that does not exist
// `processSpec` is function returned by CreateProcessSpec()
function ParseSpec(spec, processSpec)
{
    var export_app_arguments = null;
    var db_host = null;
    var on_success = null;
    var origin = null;
    var options = null;
    var on_failure = null;

    origin = ExportOrigin(null);

    if (origin[0] == 'extServer')
    {
        db_host = EXTERNAL_SERVER;
    }
    else
    {
        db_host = INTERNAL_SERVER;
    }

    export_app_arguments = { "specification" : spec, "db-host" : db_host, "parse-only" : true };

    on_success = CreateParseSpecResponse(processSpec);

    on_failure = function(error_message, response_obj)
    {
        $('RSCountPlace').innerHTML = error_message;
        $('ExportRecordSet').disabled = false;
        set_eb_state_disabled(true);

        if (process_spec !== null)
        {
            process_spec(error_message, response_obj);
        }
    };

    options =
    {
        method: 'get',
        onSuccess: on_success,
        onFailure: function(response)
        {
            alert('on failure');
            var gri_response_obj = response.responseJSON;
            var error_message = 'failure parsing record-set specification: ' + JSON.stringfy(gri_response_obj.error_message);
            var process_spec = processSpec;

            on_failure(error_message, gri_response_obj);
        },
        on428: function(response)
        {
            var gri_response_obj = response.responseJSON;
            var error_message = 'invalid arguments to record-set endpoint: ' + JSON.stringfy(gri_response_obj.error_message);
            var process_spec = processSpec;

            on_failure(error_message, gri_response_obj);
        },
        onComplete: function()
        {
        }
    };

    options['parameters'] = export_app_arguments;

    new Ajax.Request(window.location.origin + RECORD_SET_PATH, options);
}

// tester success
</script>
<script type="text/javascript">

// callback is processRecordCount
function CreateRequestRSInfoCallback(callback, lastRecord)
{
    var processRSInfo =
        function(response)
        {
            var gri_response_obj = response.responseJSON;
            var error_message = null;
            var status = null;
            var aiaScaleCompatibilityChecked = null;
            var compatible = null;
            var online = null;
            var size = null;
            var index = null;
            var valIndex = null;

            if (gri_response_obj !== null)
            {
                status = gri_response_obj.drms_export_status;

                if (status.search(/errorcode/i) == 0)
                {
                    error_message = 'failure getting record-set information: ' + status.error_message;
                    RecordCount = null; // global
                    $('ExportRecordSet').store({ 'count': RecordCount });
                    $("RSCountPlace").innerHTML = error_message;
                    ExportRecordSetOK = 0; // global
                    SeriesName = ''; // global

                    if (callback !== null)
                    {
                        callback(errMsg);
                    }
                }
                else
                {
                    aiaScaleCompatibilityChecked = false;

                    RecordCount = gri_response_obj.count; // global
                    $('ExportRecordSet').store({ 'count': RecordCount });
                    $("RSCountPlace").innerHTML = gri_response_obj.count.toString();
                    ExportRecordSetOK = 1; // global

                    aiaScaleCompatibilityChecked = ($('OptionAiaScale').retrieve('disabled_state', null) !== null);

                    // check for compatibility with aia_scale processing

                    // aia_scale compatibility has not yet been determined; check now
                    // loop through all records, checking the keyword criteria; jsoc_info
                    // does not provide hash-accessibility to keyword info, so must
                    // loop through all keywords
                    if (gri_response_obj.hasOwnProperty('keywords'))
                    {
                        var ctype1Checked = false;
                        var ctype2Checked = false;

                        if (aiaScaleCompatibilityChecked)
                        {
                            ctype1Checked = true;
                            ctype2Checked = true;
                        }
                        else
                        {
                            compatible = true;
                        }

                        for (index = 0; index < gri_response_obj.keywords.length; index++)
                        {
                            // we are assured that the CTYPE keywords will be in the jsoc_info results,
                            // even if the series does not have those keywords; if a keyword
                            // does not exist in the series, jsoc_info prints 'Invalid Keylink'
                            // for the keyword value (as long as the keyword is specified in the keys argument
                            // to jsoc_info)
                            if (compatible && !ctype1Checked && gri_response_obj.keywords[index].name.strip().toLowerCase() == KEYWORD_CTYPE1.toLowerCase())
                            {
                                for (valIndex = 0; compatible && valIndex < gri_response_obj.keywords[index].values.length; valIndex++)
                                {
                                    // loop over records
                                    if (gri_response_obj.keywords[index].values[valIndex] != AIA_SCALE_CTYPE1)
                                    {
                                        compatible = false;
                                        break;
                                    }
                                }

                                ctype1Checked = true;
                            }

                            if (compatible && !ctype2Checked && gri_response_obj.keywords[index].name.strip().toLowerCase() == KEYWORD_CTYPE2.toLowerCase())
                            {
                                for (valIndex = 0; compatible && valIndex < gri_response_obj.keywords[index].values.length; valIndex++)
                                {
                                    // loop over records
                                    if (gri_response_obj.keywords[index].values[valIndex] != AIA_SCALE_CTYPE2)
                                    {
                                        compatible = false;
                                        break;
                                    }
                                }

                                ctype2Checked = true;
                            }

                            // check to see if all SUs are online
                            if (online === null && gri_response_obj.keywords[index].name.strip().toLowerCase() == KEYWORD_ONLINE.toLowerCase())
                            {
                                online = true;

                                for (valIndex = 0; valIndex < gri_response_obj.keywords[index].values.length; valIndex++)
                                {
                                    // loop over records
                                    if (gri_response_obj.keywords[index].values[valIndex].toLowerCase() != 'y')
                                    {
                                        online = false;
                                        break;
                                    }
                                }
                            }

                            if (size === null && gri_response_obj.keywords[index].name.strip().toLowerCase() == KEYWORD_SIZE.toLowerCase())
                            {
                                size = 0;

                                for (var valIndex = 0; valIndex < gri_response_obj.keywords[index].values.length; valIndex++)
                                {
                                    // loop over records
                                    size += gri_response_obj.keywords[index].values[valIndex];
                                }
                            }

                            if (ctype1Checked && ctype2Checked && online !== null && size != null)
                            {
                                break;
                            }
                        }
                    }
                    else if (!aiaScaleCompatibilityChecked)
                    {
                        // no keyword information was returned by jsoc_info, so we cannot tell if this series;
                        // this happens if no rows were returned
                        compatible = false;
                    }

                    if (!aiaScaleCompatibilityChecked)
                    {
                        // we definitively know whether or not aia_scale processing should be disabled
                        if (compatible)
                        {
                            $('OptionAiaScale').store({ 'disabled_state' : false });
                        }
                        else
                        {
                            $('OptionAiaScale').store({ 'disabled_state' : true });
                        }
                    }

                    if (online)
                    {
                        $('ExportRecordSet').store({ 'allSUsOnline' : true });
                    }
                    else
                    {
                        $('ExportRecordSet').store({ 'allSUsOnline' : false });
                    }

                    $('ExportRecordSet').store({ 'sizeSU' : size });

                    if (!$('OptionAiaScale').retrieve('disabled_state', false))
                    {
                        // this series' first segment has a 2D-image with a CTYPE1 value of 'HPLN-TAN' and a CTYPE2 value of 'HPLT-TAN' so
                        // it is compatible with aia_scale processing; the code to determine this is split between processSeriesSelection and
                        // processRSInfo

                        // this should remain disabled until all asynchronous processing completes
                        $('OptionAiaScaleLabel').innerHTML = 'aia_scale - Scale image to 0.6 arcsec/pixel';
                        $('OptionAiaScaleLabel').setStyle({ color: 'black' });

                        // the determination of which aia_scale proc to use was already determined; in processSeriesSelection()
                        // a check of the LVL_NUM keyword was performed; this keyword must be constant, since a series cannot be
                        // a mix of levels
                        if (IsAiaLev1 === null && IsAia)
                        {
                            if (gri_response_obj.hasOwnProperty('keywords'))
                            {
                                for (index = 0; index < gri_response_obj.keywords.length; index++)
                                {
                                    // loop over keywords
                                    if (gri_response_obj.keywords[index].name.strip().toLowerCase() == KEYWORD_LVL_NUM.toLowerCase())
                                    {
                                        IsAiaLev1 = true;

                                        for (valIndex = 0; valIndex < gri_response_obj.keywords[index].values.length; valIndex++)
                                        {
                                            // loop over records (one value element per DRMS record)
                                            var lvlnumString = gri_response_obj.keywords[index].values[valIndex];
                                            var lvlnum = null;

                                            // the series has a LVL_NUM constant keyword
                                            // round so we can compare floats
                                            lvlnum = Math.floor(10 * (parseFloat(lvlnumString) + 0.02)); // level numbers should be much farther apart than 0.02

                                            if (lvlnum != 10)
                                            {
                                                /* this is NOT an aia lev1 series */
                                                IsAiaLev1 = false;
                                                break;
                                            }
                                        }

                                        break; // look only at the LVL_NUM keyword
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        // not compatible with aia_scale processing

                        // this should remain disabled until all asynchronous processing completes
                        $('OptionAiaScaleLabel').innerHTML = 'aia_scale - Scale image to 0.6 arcsec/pixel (compatible with 2D dataseries with CTYPE1 == HPLN-TAN and CTYPE2 == HPLT-TAN only)'
                        $('OptionAiaScaleLabel').setStyle({ color: 'grey' });

                        // uncheck the aia_scale checkbox if it is currently checked
                        if ($('OptionAiaScale').checked)
                        {
                            $('OptionAiaScale').checked = false;
                        }
                    }

                    // if the user has specified the current record with [$], then replace [$] with the record-specification
                    if (lastRecord && gri_response_obj.hasOwnProperty('keywords'))
                    {
                        for (index = 0; index < gri_response_obj.keywords.length; index++)
                        {
                            if (gri_response_obj.keywords[index].name.strip().toLowerCase() == '*spec*' && gri_response_obj.keywords[index].values.length == 1)
                            {
                                $('ExportRecordSet').value = gri_response_obj.keywords[index].values[0];
                                break;
                            }
                        }
                    }
                }
            }

            if (callback !== null)
            {
                if (!ExportRecordSetOK)
                {
                    error_message = $("RSCountPlace").innerHTML;
                }

                callback(error_message);
            }
        };

    return processRSInfo;
}

// tester success
</script>
<script type="text/javascript">
// tester success

// callback is processRecordCount
function CreateObtainFastRecordCountCallback(callback)
{
    // assuming that we have not already gotten the record count
    var obtainFastRecordCount =
        function(response)
        {
            var gri_response_obj = response.responseJSON;
            var status = null;
            var error_message = null;

            if (gri_response_obj !== null)
            {
                status = gri_response_obj.drms_export_status;

                if (status.search(/errorcode/i) == 0)
                {
                    error_message = 'failure counting records: ' + JSON.stringify(gri_response_obj.error_message);
                    RecordCount = null; // global
                    $('ExportRecordSet').store({ 'count': RecordCount });
                    $("RSCountPlace").innerHTML = error_message;
                    ExportRecordSetOK = 0; // global
                }
                else
                {
                    // 'StatusCode.SUCCESS' is the only other possible status
                    RecordCount = gri_response_obj.count; // global
                    $('ExportRecordSet').store({ 'count': RecordCount });
                    $("RSCountPlace").innerHTML = gri_response_obj.count;
                    ExportRecordSetOK = 1; // global
                }

                if (callback !== null)
                {
                    error_message = null;

                    if (!ExportRecordSetOK)
                    {
                        error_message = $("RSCountPlace").innerHTML;
                    }

                    callback(error_message);
                }
            }
        };

    return obtainFastRecordCount;
}

</script>
<script type="text/javascript">


// if errMsg, then do not call jsoc_info, but we still have to call the callback (which is processRecordCount)
function ObtainFastRecordCount(errMsg, spec, callback)
{
    var export_app_arguments = null;
    var options = null;
    var origin = null;
    var db_host = null;
    var on_success = null;
    var on_failure = null;

    if (errMsg && errMsg.length != 0)
    {
        if (callback !== null)
        {
            callback(errMsg);
        }
    }
    else
    {
        // if this is the external host, then use jsocinfointext; this CGI will choose the correct db server to handle the series;
        // if this is the internal host, then use jsoc_info, which will use the internal db server; Host, RecordLimit and EXTERNAL_SERVER
        // are globals
        origin = ExportOrigin(null);

        if (origin[0] == 'extServer')
        {
            db_host = EXTERNAL_SERVER;
        }
        else
        {
            db_host = INTERNAL_SERVER;
        }

        export_app_arguments = { "specification" : spec, "db-host" : db_host, "number-records" : RecordLimit };

        // callback is processRecordCount; response.count has record count
        on_success = CreateObtainFastRecordCountCallback(callback);

        on_failure = function(error_message)
        {
            var callback = callback;

            RecordCount = null;
            $('ExportRecordSet').store({ 'count': RecordCount });
            $('RSCountPlace').innerHTML = error_message;
            ExportRecordSetOK = 0;
            SeriesName = '';
            $('ExportRecordSet').disabled = false;
            set_eb_state_disabled(true);

            if (callback !== null)
            {
                callback(error_message);
            }
        };

        options =
        {
            method: 'get',
            onSuccess: on_success,
            onFailure: function(response)
            {
                var error_message = 'failure counting records: ' + JSON.stringfy(response.responseJSON.error_message);

                return on_failure(error_message);
            },
            on428: function(response)
            {
                var error_message = 'invalid arguments to record-set endpoint: ' + JSON.stringfy(response.responseJSON.error_message);

                return on_failure(error_message);
            },
            onComplete: function(response)
            {
            }
        };

        options['parameters'] = export_app_arguments;

        new Ajax.Request(window.location.origin + RECORD_SET_PATH, options);
    }
}

// tester success
</script>
<script type="text/javascript">

// if errMsg, then do not call jsoc_info, but we still have to call the callback (which is processRecordCount)
function RequestRSInfo(errMsg, spec, lastRecord, callback)
{
    var export_app_arguments = null;
    var options = null;
    var origin = null;
    var db_host = null;
    var on_success = null;
    var on_failure = null;

    if (errMsg && errMsg.length != 0)
    {
        if (callback !== null)
        {
            callback(errMsg);
        }
    }
    else
    {
        // if this is the external host, then use jsocinfointext; this CGI will choose the correct db server to handle the series;
        // if this is the internal host, then use jsoc_info, which will use the internal db server; Host, RecordLimit and EXTERNAL_SERVER
        // are globals
        origin = ExportOrigin(null);

        if (origin[0] == 'extServer')
        {
            db_host = EXTERNAL_SERVER;
        }
        else
        {
            db_host = INTERNAL_SERVER;
        }

        export_app_arguments = { "specification" : spec, "db-host" : db_host, "number-records" : RecordLimit, "keywords" : [ KEYWORD_CTYPE1 + ',' + KEYWORD_CTYPE2 + ',' + KEYWORD_LVL_NUM + ',' + KEYWORD_SPEC + ',' + KEYWORD_ONLINE + ',' + KEYWORD_SIZE ] };

        on_success = CreateRequestRSInfoCallback(callback, lastRecord);

        on_failure = function(error_message)
        {
            var callback = callback;

            RecordCount = null;
            $('ExportRecordSet').store({ 'count': RecordCount });
            $('RSCountPlace').innerHTML = error_message;
            ExportRecordSetOK = 0;
            SeriesName = '';
            $('ExportRecordSet').disabled = false;
            set_eb_state_disabled(true);

            if (callback)
            {
                callback(error_message);
            }
        };

        options =
        {
            method: 'get',
            onSuccess: on_success,
            onFailure: function(response)
            {
                var error_message = 'failure getting record-set information: ' + JSON.stringify(response.responseJSON.error_message);

                return on_failure(error_message);
            },
            on428: function(response)
            {
                var error_message = 'invalid arguments to record-set endpoint: ' + JSON.stringify(response.responseJSON.error_message);

                return on_failure(error_message);
            },
            onComplete: function(response)
            {
            }
        };

        options['parameters'] = export_app_arguments;

        new Ajax.Request(window.location.origin + RECORD_SET_PATH, options);
    }
}

// tester success
</script>
<script type="text/javascript">


// called after the click on "Submit Export Request" button when url_direct is the selected export method
function CreateExportDownloadLink(err, callback)
{
    // extract arguments
    var args = $('ExportRecordSet').retrieve('exportArgs', null);
    var argsStr = null;
    var host = null;
    var drmsexportCGI = null;
    var url = null;
    var linkUrl = null;
    var errMsg = null;

    if (err && err.length > 0)
    {
        errMsg = err;
    }
    else if (args === null)
    {
        errMsg = 'arguments to drms-export CGI missing';
    }
    else
    {
        // XXX check to see if count is null - if so, then run requestRSInfo()
        var count = $('ExportRecordSet').retrieve('count', null);
        var sizeSU = $('ExportRecordSet').retrieve('sizeSU', null);

        Cookie.setData("state", 0);
        Cookie.setData("requestid", "");

        $("ExportButtonMsg").innerHTML = 'Please use the link below to download data prior to initiating a new request';
        $("ExportButton").value = 'Submit Export Request'; // if user clicks, then export-complete message displays
        $("ExportButton").style.backgroundColor = "#D8D8D8"; // grey

        RequestID = 'N/A';
        $("RequestIdPlace").update(RequestID);
        $("RequestIDDesc").update("");
        $("ExportStatus").update("Download size = " + Math.round(10 * sizeSU/1024/1024) / 10 + " MB");

        host = Host.toLowerCase();
        args.dbhost = serverMap[host];
        args.webserver = host;

        argsStr = Object.keys(args).map(function(key) { return key + '=' + encodeURIComponent(args[key]); }).join('&');
        url = 'http://' + host + '/cgi-bin/' + DRMS_EXPORT + '?' + argsStr;

        // make an href - when the user clicks on this link, either a save-file dialog will display or, if the user
        // has set-up their mime-type file association, the file will display in a viewer like ds9
        $('DataLocation').update('Download');

        // disable the beforeunload event handler
        $('ExportLocation').observe('click', function(event) { window.onbeforeunload = null; $('FileUploadFormID').store({ 'beforeunloadOverride' : true }); });
        // make an href - when the user clicks on this link, either a save-file dialog will display or, if the user
        // has set-up their mime-type file association, the file will display in a viewer like ds9
        linkUrl = new Element('a', { 'href' : url } ).update(args.spec);
        $('ExportLocation').update(linkUrl);
    }

    if (callback !== null)
    {
        callback(errMsg);
    }
}

// callback is requestRSInfo
function CreateProcessSeriesSelection(spec, series, seriesNs, callback)
{
    var processSeriesSelection =
        function(response)
        {
            var gsi_response_obj = response.responseJSON;
            var error_message = null;
            var status = null;

            if (gsi_response_obj !== null)
            {
                status = gsi_response_obj.drms_export_status;

                if (status.search(/errorcode/i) == 0)
                {
                    error_message = 'failure getting series information: ' + JSON.stringify(gsi_response_obj.error_message);
                    RecordCount = null; // global
                    $('ExportRecordSet').store({ 'count': RecordCount });
                    $("RSCountPlace").innerHTML = error_message;
                    SeriesName = ''; //global
                }
                else
                {
                    // 'StatusCode.SUCCESS' is the only other possible status
                    // successfully obtained series info
                    var compatible = null;
                    var keywordsObj = null;

                    for (var segment in gsi_response_obj[series.toLowerCase()].segments)
                    {
                        if (gsi_response_obj[series.toLowerCase()].segments.hasOwnProperty(segment))
                        {
                            if ((parseInt(gsi_response_obj[series.toLowerCase()].segments[segment]['segment-number']) == 0) &&
                                 (parseInt(gsi_response_obj[series.toLowerCase()].segments[segment]['number-axes']) != 2))
                            {
                                // we know that aia_scale should definitely be disabled; store that information now so we can skip
                                // the secondary check in processRSInfo
                                $('OptionAiaScale').store({ 'disabled_state' : true });
                                compatible = false;
                                break;
                            }
                        }
                    }

                    keywordsObj = gsi_response_obj[series.toLowerCase()].keywords;

                    if (compatible === null)
                    {
                        // compatibility not yet determined
                        if (!keywordsObj.hasOwnProperty(KEYWORD_CTYPE1.toLowerCase()) || !keywordsObj.hasOwnProperty(KEYWORD_CTYPE2.toLowerCase()))
                        {
                            compatible = false;
                        }
                        else
                        {
                            if ((keywordsObj[KEYWORD_CTYPE1.toLowerCase()]['constant-value'] != AIA_SCALE_CTYPE1 &&
                                 keywordsObj[KEYWORD_CTYPE1.toLowerCase()]['constant-value'] != NA) ||
                                (keywordsObj[KEYWORD_CTYPE2.toLowerCase()]['constant-value'] != AIA_SCALE_CTYPE2 &&
                                 keywordsObj[KEYWORD_CTYPE2.toLowerCase()]['constant-value'] != NA))
                            {
                                // we know that aia_scale should definitely be disabled; store that information now so we can skip
                                // the secondary check in
                                $('OptionAiaScale').store({ 'disabled_state' : true });
                                compatible = false;
                            }
                        }
                    }

                    // we can also determine compatibility with the MPT-selection check box
                    if (seriesNs.toLowerCase() == AIA_NAMESPACE)
                    {
                        $('AiaScaleUseMptCheckbox').disabled = false;
                        $('AiaScaleUseMptCheckboxLabel').innerHTML = 'Use a master pointing table to scale images (instead of keyword values)&nbsp';
                        $('AiaScaleUseMptCheckboxLabel').setStyle({ color: 'black' });
                    }
                    else
                    {
                        $('AiaScaleUseMptCheckbox').disabled = true;
                        $('AiaScaleUseMptCheckboxLabel').innerHTML = 'Use a master pointing table to scale images (instead of keyword values - compatible with AIA series only)&nbsp';
                        $('AiaScaleUseMptCheckboxLabel').setStyle({ color: 'grey' });
                    }

                    // finally, if KEYWORD_LVL_NUM is constant in an AIA series, then set the aia_scale processing flag that determines
                    // which aia_scale proc is used
                    if (seriesNs.toLowerCase() == AIA_NAMESPACE)
                    {
                        IsAia = true;

                        if (keywordsObj.hasOwnProperty(KEYWORD_LVL_NUM.toLowerCase()))
                        {
                            var lvlnumString = keywordsObj[KEYWORD_LVL_NUM.toLowerCase()]['constant-value'];
                            var lvlnum = null;

                            if (lvlnumString != NA)
                            {
                                // the series has a LVL_NUM constant keyword
                                // round so we can compare floats
                                lvlnum = Math.floor(10 * (parseFloat(lvlnumString) + 0.02)); // level numbers should be much farther apart than 0.02

                                if (lvlnum == 10)
                                {
                                    /* this is an aia lev1 series */
                                    IsAiaLev1 = true;
                                }
                            }
                        }
                    }

                }
            }

            if (callback !== null)
            {
                callback(error_message);
            }
        };

    return processSeriesSelection;
}

// tester success
</script>
<script type="text/javascript">

function RequestSeriesInfo(series, process_series_on_success, callback)
{
    var export_app_arguments = null;
    var options = null;
    var origin = null;
    var db_host = null;
    var on_success = null;
    var on_failure = null;

    origin = ExportOrigin(null);

    if (origin[0] == 'extServer')
    {
        db_host = EXTERNAL_SERVER;
    }
    else
    {
        db_host = INTERNAL_SERVER;
    }

    export_app_arguments = { "series" : [ series ], "db-host" : db_host, "links" : [] };

    on_success = process_series_on_success;

    on_failure = function(error_message)
    {

        $('ExportRecordSet').store({ "count" : null, "series" : null});
        $('RSCountPlace').innerHTML = error_message;
        $('ExportRecordSet').disabled = false;
        set_eb_state_disabled(true); 

        if (callback !== null)
        {
            callback(error_message);
        }
    };

    options =
    {
        method: 'get',
        onSuccess: on_success,
        onFailure: function(response)
        {
            var error_message = 'failure getting series information: ' + JSON.stringify(response.responseJSON.error_message);

            on_failure(error_message);
        },
        on428: function(response)
        {
            var error_message = 'invalid arguments to series endpoint: ' + JSON.stringify(response.responseJSON.error_message);
            
            on_failure(error_message);
        },
        onComplete: function(response)
        {
        }
    };

    options['parameters'] = export_app_arguments;

    new Ajax.Request(window.location.origin + SERIES_PATH, options);
}

// tester success
</script>
<script type="text/javascript">


// callback - called after record-set specification has been successfully processed (this does not mean that the
// series is valid - it just means the specification has valid syntax); callback is generally processRecordCount

function CreateProcessSpec(spec, fastCallback, callback)
{
    // called by onSuccess() of ParseSpec(), which is the function returned by CreateParseSpecResponse()
    // extracts series name and checks for record-set filter
    var processSpec =
        function(error_message, data)
        {
            if (error_message)
            {
                RecordCount = null;
                $('ExportRecordSet').store({ 'count': RecordCount });
                ExportRecordSetOK = 0;
                $('RSCountPlace').innerHTML = error_message;

                // if an error occurred, we still need to call the callback callback
                if (callback !== null)
                {
                    callback(error_message);
                }
            }
            else
            {
                // since we've only parsed the record-set specification, but have not yet tried to count records
                // we know we have valid series name, but we do not know if the series exists

                // set SeriesName
                var series = data.subsets[0].seriesname;
                var seriesNs = data.subsets[0].seriesns;
                var validSpec = data.subsets[0].spec;
                var lastRecord = false;

                SeriesName = series; // global
                if (!data.hasfilts && RecordLimit == 0)
                {
                    validSpec = series + '[$]' + (data.subsets[0].segments === null ? '' : data.subsets[0].segments);
                    lastRecord = true;
                }
                else if (data.hasfilts)
                {
                    if (data.subsets[0].filter == '[$]')
                    {
                        lastRecord = true;
                    }
                }

                // store this determination for use later when determining the disabledState of processing steps
                $('ExportRecordSet').store({ 'last_record' : lastRecord });
                $('ExportRecordSet').value = validSpec;

                // store parsed series name for this record set
                $('ExportRecordSet').store({ 'series' : series })

                // initialize series cache for this series
                series_cache = $('ExportRecordSet').retrieve('series_cache', null);
                if (series_cache === null)
                {
                    series_cache = {};
                    $('ExportRecordSet').store({ 'series_cache' : series_cache });
                }

                if (!series_cache.hasOwnProperty(series))
                {
                    series_cache[series] = null; // to be filled in with series struct info after series endpoint has loaded
                }

                // use the parsed series name to call the jsocInfoCGI to get the series information;
                // disable the aia_scale processing option if the series selected is not suitable for that
                // processing option; NOTE: the series info might not be sufficient to make this determination;
                // if this is the case, then we need to consult the actual record metadata to do so; check
                // series info first since this is a simpler, quicker test;
                //
                // series suitable for the aia_scale processing option have these properties:
                //   1. They are 2-D time series
                //   2. CTYPE1 == 'HPLN-TAN'
                //   3. CTYPE2 == 'HPLT-TAN'
                //
                // the RequestSeriesInfo callback needs to call RequestRSInfo with callback as the callback

                // if we want the callback to return results quickly, then we need to skip running requestRSInfo() since
                // that could be a slow asynchronous call;
                var actualCB = null;

                if (fastCallback)
                {

                    // we only need to do this if the record count has not yet been obtained
                    actualCB = function(error_message) { ObtainFastRecordCount(error_message, validSpec, callback); };

                    // if we have skipped the requestRSInfo callback, then we need to do that later
                }
                else
                {
                    // gets record count too, but could be slow async call
                    actualCB = function(error_message) { RequestRSInfo(error_message, validSpec, lastRecord, callback); };
                }

                // `processSeriesSelection` is an onSuccess, with `actualCB` as its callback
                var processSeriesSelection = CreateProcessSeriesSelection(validSpec, series, seriesNs, actualCB);
                RequestSeriesInfo(series, processSeriesSelection, actualCB);
            }
        };

    return processSpec;
}

// Internal-DB pass-through.
// If the user is accessing the external website, the database source of the series information could be the internal database.
// External users have access to a sanctioned list of internal data series. So, we do not necessarily want to use the 'Host'
// variable to identify the jsoc_info CGI. If the user is accessing a sanctioned internal series, then we need to use the jsoc_info
// CGI hosted on jsoc2.stanford.edu, not the one on 'Host' (which is jsoc.stanford.edu).
// The callback is optional. Many functions require jsoc_info to have returned before they can continue.
//
// IF THE CALLBACK IS NOT null THEN IT MUST BE CALLED, EVEN ON ERROR; OTHERWISE, CERTAIN GLOBAL VARIABLES
// WILL NOT BE SET APPROPRIATELY
function GetRSCount(countCallback)
{
    ExportQueryOK = 0;
    ExportRecordSetOK = 0;
    SeriesName = "";
    SeriesAttributesGlobal = null;
    $('ExportFilenameFmt').store({ 'originalFormat' : null }); // we have neither determined the original format nor the aia.lev1p5-format yet
    IsAia = null;
    IsAiaLev1 = null;

    var recset = $('ExportRecordSet').value;

    if (recset.length == 0)
    {
        $("RSCountPlace").innerHTML = "ERROR - missing record-set specification.";
        return(1);
    }

    $("RSCountPlace").innerHTML = RSCountActiveMSg;
    // we need not only the series name, but we need the CTYPE1 and CTYPE2 keyword values so that
    // we can determine if the series is suitable for aia_scale processing; from recset, we can
    // extract the seriesname
    var cb = CreateProcessSpec(recset, true, countCallback);
    ParseSpec(recset, cb); // stores series in $('ExportRecordSet') 'series' attribute (value is an object with k-v for each series)

    RecordCount = null; // To indicate that the RecordCount has not been set yet.
    $('ExportRecordSet').store({ 'count': RecordCount });

    return(0);
}

function GetCompatibleFormat(series, attributes, keywords)
{
    var format = null;
    var ipkey;
    var extPrime;
    var dataType;

    if (attributes && keywords)
    {
        format = series;

        for (ipkey = 0; ipkey < attributes.drmsprimekey.length; ipkey++)
        {
            // loop on prime keywords (remove _index from keyword name to HACKILY convert from internal name to external name)
            extPrime = attributes.drmsprimekey[ipkey].replace(/_index/i, '');
            dataType = keywords[extPrime.toLowerCase()]['data-type'].toLowerCase();

            if (dataType == 'time')
            {
                format = format + '.' + '{' + extPrime + ':A}';
            }
            else
            {
                format = format + '.' + '{' + extPrime + '}';
            }
        }

        format = format + '.' + '{segment}';
    }

    return format;
}

// tester success
</script>
<script type="text/javascript">

// load the series endpoint; the securedrms client caches the series information, so if 
// the endpoint is loaded for a previous invocation, the response will be returned quickly;
// the series information is NOT cached in the javascript - that is something to consider
function GetDefaultFormat()
{
    var RecordSet = $('ExportRecordSet').value;
    var series_cache = null;
    var series = null;

    series_cache = $('ExportRecordSet').retrieve('series_cache', null);
    series = $('ExportRecordSet').retrieve('series', null);

    var doInfoReqFn = function()
    {
        var export_app_arguments = null;
        var options = null;
        var origin = null;
        var db_host = null;

        origin = ExportOrigin(null);

        if (origin[0] == 'extServer')
        {
            db_host = EXTERNAL_SERVER;
        }
        else
        {
            db_host = INTERNAL_SERVER;
        }

        // the series endpoint automatically follows links for both keywords and segments
        export_app_arguments = { "series" : [ $('ExportRecordSet').value ], "db-host" : db_host, "parse-record-sets" : true, "links" : [] };

        options =
        {
            method: 'get',
            onSuccess: function(response)
            {
                var gsi_response_obj = response.responseJSON;
                var status = null;
                var error_message = null;

                if (gsi_response_obj !== null)
                {
                    status = gsi_status_obj.drms_export_status;

                    if (status.search(/errorcode/i) == 0)
                    {
                        error_message = 'failure getting series information: ' + JSON.stringify(gsi_response_obj.error_message);
                    }
                    else
                    {
                        var keywords = (new Hash(gsi_response_obj.keywords)).keys();
                        var segments = (new Hash(gsi_response_obj.segments)).keys();
                        var prime_key_length = gsi_response_obj.drmsprimekey.length;
                        var number_keys = keywords.length;
                        var format = null;
                        var key_index = null;
                        var seg_index = null;
                        var member = null;
                        var member_obj = null;
                        var series_cache = null;
                        var series = null;

                        // cache series info
                        series_cache = $('ExportRecordSet').retrieve('series_cache', null);
                        series = $('ExportRecordSet').retrieve('series', null);

                        if (series_cache !== null && series !== null && (!series_cache.hasOwnProperty(series) || series_cache[series] === null))
                        {
                            series_cache[series] = gsi_response_obj;
                        }

                        if (prime_key_length == 0)
                        {
                            format = series + '.{recnum:%lld}.{segment}';
                        }
                        else
                        {
                            format = series + '.';
                            for (key_index = 0; key_index < prime_key_length; key_index += 1)
                            {
                                member = gsi_response_obj.drmsprimekey[key_index];
                                member_obj = gsi_response_obj.keywords[member.toLowerCase()];

                                if (member_obj['data-type'].toLowerCase() === 'time')
                                {
                                    if (firstTimePrime === null || firstTimePrime === '')
                                    {
                                        // global
                                        firstTimePrime = member;
                                    }

                                    format = format + '{' + member + ':A}.';
                                }
                                else
                                {
                                    format = format + '{' + member + '}.';
                                }

                            }

                            format = format + '{segment}';
                        }

                        $('ExportFilenameFmt').value = format;
                        $('ExportFilenameFmt').store('valid', true);

                        for (seg_index = 0; seg_index < segments.length; seg_index += 1)
                        {
                            if (gsi_response_obj.segments[segments[seg_index].toLowerCase()].protocol.toLowerCase() === 'fits')
                            {
                                // global
                                firstRealSegment = segments[seg_index];
                                break;
                            }
                        }
                    }
                }
            },
            onFailure: function(response)
            {
                alert('[ GetDefaultFormat ] Something went wrong...');
                set_eb_state_disabled(true);
            },
            on428: function(response)
            {
                alert('[ GetDefaultFormat ] Something went wrong...');
                set_eb_state_disabled(true);
            },
            onComplete: function(response)
            {
            }
        };

        options['parameters'] = export_app_arguments;

        new Ajax.Request(window.location.origin + SERIES_PATH, options);
    };


    if (series_cache === null || series === null || !series_cache.hasOwnProperty(series))
    {
        // Just call the function. It will determine if it should use the internal or external version of the CGI.
        doInfoReqFn();
    }

    if (IsAiaLev1 && (!AiaLev1AttributesGlobal || !AiaLev1KeywordsGlobal))
    {
        // now we have to get the default format information for aia.lev1p5; we only use this information
        // if there is an aia_scale processing step, but do it now since we do not know if the user
        // will check the aia_scale checkbox or not
        var export_app_arguments = null;
        var options = null;
        var origin = null;
        var db_host = null;

        origin = ExportOrigin(null);

        if (origin[0] == 'extServer')
        {
            db_host = EXTERNAL_SERVER;
        }
        else
        {
            db_host = INTERNAL_SERVER;
        }

        // the series endpoint automatically follows links for both keywords and segments
        export_app_arguments = { "series" : [ AIA_LEV1P5 ], "db-host" : db_host, "links" : [], "segments" : [] };

        options =
        {
            method: 'get',
            onSuccess: function(response)
            {
                var gsi_response_obj = response.responseJSON;
                var status = null;
                var error_message = null;

                if (gsi_response_obj !== null)
                {
                    status = gsi_status_obj.drms_export_status;

                    if (status.search(/errorcode/i) == 0)
                    {
                        error_message = 'failure getting series information: ' + JSON.stringify(gsi_response_obj.error_message);

                        // don't do anything; let the process of getting the aia.lev1p5 format fail
                        AiaLev1AttributesGlobal = null;
                        AiaLev1KeywordsGlobal = null;
                    }
                    else
                    {
                        AiaLev1AttributesGlobal = data[AIA_LEV1P5.toLowerCase()].attributes;
                        AiaLev1KeywordsGlobal = data[AIA_LEV1P5.toLowerCase()].keywords;
                    }
                }
                else
                {
                    AiaLev1AttributesGlobal = null;
                    AiaLev1KeywordsGlobal = null;
                }
            },
            onFailure: function(response)
            {
                AiaLev1AttributesGlobal = null;
                AiaLev1KeywordsGlobal = null;
                set_eb_state_disabled(true);
            },
            on428: function(response)
            {
                AiaLev1AttributesGlobal = null;
                AiaLev1KeywordsGlobal = null;
                set_eb_state_disabled(true);
            },
            onComplete: function(response)
            {
            }
        };

        options['parameters'] = export_app_arguments;

        alert('aia stuff');
        new Ajax.Request(window.location.origin + SERIES_PATH, options);
    }
}
// tester success
</script>
<script type="text/javascript">
function CreateDataTable(export_data, package)
{
    var count = export_data.length;
    var valuetable = null;
    var record_specification = null;
    var export_url = null;
    var file_name = null;

    valuetable = "<table id='ResultsTable' border='1'>";
    valuetable = valuetable + "<tr><td>File<\/td><td>Record<\/td><td>Filename<\/td><\/tr>";

    for (ifile = 0; ifile < count; ifile++)
    {
        record_specification = export_data[ifile][0];

        valuetable = valuetable + "<tr>";
        valuetable = valuetable + "<td>" + (ifile + 1) + "<\/td>";
        valuetable = valuetable + "<td>" + record_specification + "<\/td>";

        if (package !== null && package.hasOwnProperty('type') && package.type !== null && package.type.trim().toLowerCase() === 'tar')
        {
            file_name = export_data[ifile][1];
            valuetable = valuetable +  "<td>" + file_name + "<\/td><\/tr>";
        }
        else
        {
            export_url = export_data[ifile][1];
            file_name = export_url.substring(export_url.lastIndexOf('/') + 1);
            valuetable = valuetable + "<td>" + "<a href='" + export_url + "' target='_blank'>" + file_name + "<\/a>" + "<\/td>";
        }

        valuetable = valuetable + "<\/tr>";
    }

    valuetable = valuetable + "<\/table>";
    return valuetable;
}

function delete_data_table()
{
    // var su_link = $("StatusDataLocation").select('a')[0];

    // the top section
    $("ExportLocation").innerHTML = "";

    // the table in the lower section ("JSOC Data Export Status and Retrieval")
    $("StatusDataLocation").innerHTML = "";

    $("StatusLocation").innerHTML = "";

    // if (su_link !== null && su_link !== undefined)
    //{
    //    alert('dub');
//
  //      su_link.remove();
    //}
}

function ExportNop()
  {
  }

function ExportRSChanged()
{
    // dirty since last time the CP button was clicked
    set_eb_state_disabled(true);

    ExportQueryOK = 0;
    RecordCount = null; // This will cause the record-count global to be updated later.
    $('ExportRecordSet').store({ 'count': RecordCount });

    // reset the wavelength used for the image options for this record-set
    $('ExportRecordSet').store({ "wavelength" : null });
    $("CountButton").style.backgroundColor = colorYellow;
    ExportNewRS(); // to fix operator not pressing enter or count
  }

</script>
<script type="text/javascript">

// called after the record count is complete (always gets called when the user changes the record-set specification)
function ProcessRSChange(error)
{
    var option_index;
    var processing_option_id;
    var disabled_state_rec_dep;
    var need_rs_info = false;

    // GetDefaultFormat() starts another jsoc_info asnchronously. It sets firstTimePrime. firstTimePrime is used in processing.js.
    // GetDefaultFormat() requires SeriesName, which is set in the first jsoc_info.
    // ProcessRSChange() is now not called until the first jsoc_info has completed.
    if (error === null)
    {
        firstTimePrime = ""; // Used in GetDefaultFormat()
        GetDefaultFormat();

        CheckNoProcessingList();
        // NotifyProcessingCode requires the first jsoc_info to have completed (the one started by SetRecordLimit()).
        // It also requires that SetProcessing() has completed its asynchronous running.
        NotifyProcessingCode();

        // check each export processing step's disabled_state (except for processing option 0 - that is no_op)
        for (option_index = 1; option_index < ExportProcessingOptions.length; option_index++)
        {
            processing_option_id = ExportProcessingOptions[option_index].id;
            disabled_state_rec_dep = $(processing_option_id).retrieve('disabled_state_rec_dep', false);

            if (disabled_state_rec_dep)
            {
                // SET disabled state (if it is not set already - null means that true/false value has not yet been determined); the
                // way we do this is to get rs info
                if ($(processing_option_id).retrieve('disabled_state', null) === null)
                {
                    // start asynchronous call to determine the processing option's disabledState value; the record-set will have
                    // already been entered, and the [$] resolved into an actual record specification; this asynchronous call
                    // could take a long time to complete
                    RequestRSInfo('', $('ExportRecordSet').value, $('ExportRecordSet').retrieve('last_record', false), function(errMsg) { $('ProcessingCheckbox').disabled = false; $('ProcessingCheckboxLabel').style.color = 'black'; $('ProcessingCheckboxLabel').style['font-weight'] = 'normal'; $('ProcessingWaitMessage').style.display = 'none'; });
                    need_rs_info = true;
                    break; // call RequestRSInfo 1x
                }
                else
                {
                    $('ProcessingCheckboxLabel').style.color = 'black';
                    $('ProcessingCheckboxLabel').style['font-weight'] = 'normal';
                    $('ProcessingWaitMessage').style.display = 'none';
                }
            }
        }

        if (!need_rs_info)
        {
            // we don't have to wait to enable 'enable processing' checkbox
            $('ProcessingCheckbox').disabled = false;
        }
    }
    else
    {
        // something went wrong; uncheck any processing check boxes that are checked and hide the processing UI
        for (iProc = 0; iProc < ExportProcessingOptions.length; iProc++)
        {
            var ExpOpt = ExportProcessingOptions[iProc];

            $(ExpOpt.id).checked = false;
            if (ExpOpt.id != 'OptionNone' && ExpOpt.hasOwnProperty('rowid'))
            {
                // the 'none' processing step has no processing UI html element
                $(ExpOpt.rowid).style.display = "none";
            }
        }
    }

    update_export_buttons();

    // Re-enable the RecordSet text box.
    $('ExportRecordSet').disabled = false;

    // must set to false every time the user enters a specification, even on error, otherwise the user will never
    // be able to enter a new specification
    newRSRunning = false;
}


</script>
<script type="text/javascript">

// Called when record-set changes, when user clicks on Recount button, when user clicks on enter key in RecordSet field;
var newRSRunning = false;
function ExportNewRS()
{
    // This took forever to figure out. JS event handlers CAN interrupt each other at alert()s.
    // ExportRecordSet has both an onchange and an onclick handler that fire when you click on the Recount
    // button after you enter a record-set specification. As a result, ExportNewRS() is called twice.
    // IFF you have an alert anywhere between the checking for newRSRunning and the setting of
    // newRSRunning in ExportNewRS(), then the onchange handler
    // will be interrupted at the alert() statement, and the onclick handler will run.
    var old_set = null;
    var set_changed = true;

    if (newRSRunning)
    {
        return;
    }
    // NO alert()!
    newRSRunning = true;

    // figure out if the user actually changed the record-set specification
    old_set = $('ExportRecordSet').retrieve('old_set', null);
    if (old_set != null && old_set == $('ExportRecordSet').value)
    {
        set_changed = false;
    }
    else
    {
        // update old_set
        $('ExportRecordSet').store({ 'old_set' : $('ExportRecordSet').value });
    }

    if (set_changed)
    {
        $('OptionAiaScale').store({ 'disabled_state' : null }); // means aia_scale compatibility not determined yet; also
                                                                // means that $('OptionAiaScale') has a disabledState property;
                                                                // changing record-set invalidates the existing validation
    }

    // disable the 'Enable Processing' checkbox - will be enabled once the record-set has been examined for processing-step checkbox
    // disabled state
    $('ProcessingCheckbox').disabled = true;
    $('ProcessingCheckboxLabel').style.color = 'grey';

    // close the processing checkboxes
    $("ProcessingCheckbox").checked = false;
    ProcessingEnabled();

    // display a message notifying user that we are working on enabling processing options (must examine all records)
    $('ProcessingWaitMessage').style.color = colorBrightOrange;
    $('ProcessingWaitMessage').style['font-weight'] = 'bold';
    $('ProcessingWaitMessage').style.opacity = 1.0;
    $('ProcessingWaitMessage').innerHTML = 'Determining applicable processing steps...please wait...';
    $('ProcessingWaitMessage').style.display = 'table-row';

    // disable processing step checkboxes for now, since we are about to change the record-set, and some processing steps
    // need the record-set to be present
    for (iProc = 0; iProc < ExportProcessingOptions.length; iProc++)
    {
        var ExpOpt = ExportProcessingOptions[iProc];
        $(ExpOpt.id).disabled = true;
    }

    SeriesName = "";
    ExportQueryOK = 0;
    $("CountButton").style.backgroundColor = colorNeutral;

    // Disable RecordSet text edit while the asynchronous stuff runs for the newly set record-set.
    $('ExportRecordSet').disabled = true;

    // we changed the record-set - clear out record count
    RecordCount = null
    $('ExportRecordSet').store({ 'count' : null });

    // this is the text after RequestID in the upper section; we just changed the input parameters, so get rid of this
    $("RequestIdPlace").innerHTML = "";

    // remove requestid so that the CP and EB buttons and messages will get reset correctly
    $("StatusRequestID").value = "";

    // get rid of the results tables in the upper and lower sections
    delete_data_table();

    // SetRecordLimit() starts jsoc_info asynchronously (via GetRSCount()).
    if (SetRecordLimit(ProcessRSChange))
    {
        return; // SetRecordLimit calls GetRSCount(), non-zero on RS syntax error
    }
}

// tester success
</script>
<script type="text/javascript">


function SetRecordLimit(callbackAfterJsocinfo)
{
    var newLimit;

    // dirty since last time the CP button was clicked
    set_eb_state_disabled(true);

    newLimit = 1 * $("ExportRecordLimit").value;
    if (isNaN(newLimit))
    {  // newlimit is a non-numeric string
        newLimit = $("ExportRecordLimit").value;
        if (newLimit == "none")
        {
            RecordLimit = 0;
        }
        else
        {
            $("ExportRecordLimit").style.backgroundColor = colorRed;
            alert("RecordLimit must be a number or 'none'");
            RecordLimit = 0;
        }
    }
    else
    {
        if (newLimit == 0)
        {
            $("ExportRecordLimit").value = "none";
        }

        RecordLimit = newLimit;
    }

    $("ExportRecordLimit").style.backgroundColor = colorWhite;
    return (GetRSCount(callbackAfterJsocinfo));
}

// reset ==> called in response to RS change, so disabled state is clean
function update_export_method(reset)
{
    var valid = null;

    if (reset)
    {
        valid = ($('ExportMethod').options[2].value.trim().toLowerCase() === EXP_METH_FULL);
        $('ExportMethod').store({ "valid" : true });
        set_eb_state_disabled(false);
    }

    // there is nothing to modify in response to a user pull-down selection
    return valid;
}

function validate_export_method()
{
    var valid = null;
    var export_method_element = $('ExportMethod');
    var export_method = export_method_element.options[export_method_element.selectedIndex].value.trim().toLowerCase();

    valid = export_method_element.retrieve('valid', null);
    
    if (valid === null)
    {
        if (export_method === EXP_METHOD_STREAMED || export_method === EXP_METHOD_QUICK || export_method === EXP_METHOD_FULL || export_method === EXP_METHOD_FULL_FTP || export_method === EXP_METHOD_FULL_TAR || export_method === EXP_METHOD_FULL_FTP_TAR)
        {
            valid = true;
        }
        else
        {
            valid = false;
        }

        export_method_element.store({ "valid" : valid });

    }

    return valid;
}

// called only when the user changes the export method pulldown
function SetExportMethod(by_whom)
{
    // byWhom = 0 for user click, else 1 (vestigial)

    // dirty since last time the CP button was clicked
    set_eb_state_disabled(true);

    update_export_method_ui(false);
}

function disable_processing()
{
    var index = null;

    // hide processing altogether
    $('ProcessRow').style.display = 'none';
   
    // set processing checkbox to none/noop
    $(ExportProcessingOptions[0].id).checked = true;

    for (index = 1; index < ExportProcessingOptions.length; index++)
    {
        $(ExportProcessingOptions[index].id).checked = false;
        $(ExportProcessingOptions[index].rowid).style.display = 'none';
    } 
}

function update_export_method_ui(reset)
{
    var method = $('ExportMethod').options[$('ExportMethod').selectedIndex].value.trim().toLowerCase();

    if (reset)
    {
        update_export_method(true);
    }
    else
    {
        update_export_method(false);
        $('ExportMethod').store({ "valid" : false });
        if (!validate_export_method())
        {
            update_export_method(true);
        }
    }
    
    if (method === EXP_METH_STREAMED)
    {
        disable_processing();

        // enable file-format selection, change file format to 'as-is'
        $('ProtocolRow').style.display = 'table-row';
        $('ExportProtocol').selectedIndex = 0;
        update_protocol_ui(false);

        // hide export status section - we will display a link only in the SubmitResponseDiv.ExportLocation span
        $('ExportDataDiv').hide()

        // hide file-name format pulldown
        $('FilenameFmtRow').style.display = 'none';
    }
    else if (method === EXP_METH_QUICK)
    {
        disable_processing();

        // hide file-format selection option
        $('ProtocolRow').style.display = 'none';
        $('ExportProtocol').selectedIndex = 0;
        update_protocol_ui(false);

        // hide file-name format pulldown
        $('FilenameFmtRow').style.display = 'none';
    }
    else if (method === EXP_METH_FULL || method === EXP_METH_FULL_FTP || method === EXP_METH_FULL_TAR || method === EXP_METH_FULL_FTP_TAR)
    {
        // enable processing UI
        $('ProcessRow').style.display = 'table-row';

        // enable file-format selection
        $('ProtocolRow').style.display = 'table-row';

        // show file-name format pulldown
        $('FilenameFmtRow').style.display = 'table-row';

        // show export status section
        $('ExportDataDiv').show();
    }
    else
    {
        alert("Please set Method to url_quick, url_direct,  url, or ftp");
    }
}

// called when file-name format changes
function SetExportFilenameFmt()
{
    return validate_filename_format();
}

function validate_filename_format()
{
    format_valid = null;

    // dirty since last time the CP button was clicked
    set_eb_state_disabled(true);

    format_valid = ($('ExportFilenameFmt').value.trim().length > 0);
    $('ExportFilenameFmt').store({ 'valid' : format_valid });
}

// Called after user clicks on 'Enable Processing' checkbox; check the disabledState for all processing steps that
// use the disabledState property
function ProcessingEnabled()
{
    var option_index = 0;
    var processing_option = null;
    var disabled_state = null;

    ExportQueryOK = 0;

    if ($("ProcessingCheckboxHide").checked)
    {
        $("ProcessingCheckbox").checked = false;
    }

    if ($("ProcessingCheckbox").checked)
    {
        // The user enabled processing
        if ($('ExportRecordSet').value == "" || $('ExportRecordSet').value == "[$]")
        {
            $("ProcessingWaitMessage").style.display = "table-row";
            $("ProcessingCheckbox").checked = false;
            return;
        }

        $("ProcessingWaitMessage").style.display = "none";
        $("ProcessingCheckboxHide").checked = false;
        $("ProcessingShowCheckbox").style.display = "none";
        $("ExportProcessing").style.display = "table-row";

        // enable the processing step checkboxes that should be enabled
        for (option_index = 0; option_index < ExportProcessingOptions.length; option_index++)
        {
            processing_option_id = ExportProcessingOptions[option_index].id;

            // if disabled-state metadata do not exist, then set disabled to false (the second arg to retrieve() is the default)
            $(processing_option_id).disabled = $(processing_option_id).retrieve('disabled_state', false);
        }

    }
    else
    {
        // The user disabled processing.
    $(ExportProcessingOptions[0].id).checked = true; // Enable the none processing option.
    $("ExportProcessing").style.display = "none";
    if (ProcessingAllowed == 0)
      {
      $("ProcessingWaitMessage").style.display = "table-row";
      $("ProcessingWaitMessage").innerHTML = "Processing not available for series " + SeriesName;
      $("ProcessingCheckboxHide").checked = true;
      $("ProcessingShowCheckbox").style.display = "none";
      }
    else
      {
      $("ProcessingWaitMessage").style.display = "none";
      $("ProcessingCheckboxHide").checked = false;
      $("ProcessingShowCheckbox").style.display = "table-row";
      }

    SetProcessing(0, null); // Pretend the user clicked on the none processing option.
    }
  }

var SizeRatio;

// Called when a processing-option checkbox has changed, or the record-set query has changed.
// Make the ExportProcessingArgs string (a |-separated list of processing steps).

var setProcessingRunning = false;
var setProcessingQueue = [];

function unserialize_arguments(serialized_arguments)
{
    var name_space = null;
    var separator_index = null;
    var pairs = null;
    var property = null;
    var value = null;
    var argument_obj = null;
    var index = null;
    var pair = null;

    argument_obj = {};

    // property name is substring before first ','
    separator_index = serialized_arguments.search(/,/i);
    if (separator_index > 0)
    {
        name_space = serialized_arguments.slice(0, separator_index);
        pairs = serialized_arguments.slice(separator_index + 1).split(",");

        argument_obj[name_space] = {};

        for (index = 0; index < pairs.length; index += 1)
        {
            pair = pairs[index];
            separator_index = pair.search(/[=]/);
            argument_obj[name_space][pair.slice(0, separator_index)] = pair.slice(separator_index + 1);
        }
    }
    else
    {
        argument_obj[serialized_arguments] = {};
    }

    return argument_obj;
}

function runSetProcessing(intervalFn, spCallback)
{
    // 0 if no procesing enabled (Enable Processing is not checked),  -1 if same seriesname, -2 if series has changed between export processing requests.
    // ichecked > 0 if the user clicks on/off a processing-step checkbox.
    if (setProcessingRunning)
    {
        // do not clear interval, this will continue to run until it is safe to run the code in the rest of the function
		return;
	}

    // No alerts in here.
	setProcessingRunning = true;

    ichecked = setProcessingQueue.shift()

	if (typeof ichecked == 'undefined')
	{
		// nothing to do; should not get here because each function instance handles one SetProcessing() call
		clearInterval(intervalFn);
		setProcessingRunning = false;
		return;
	}

    ExportQueryOK = 0;

    if (ProcessingAllowed == 0)
    {
        $(ExportProcessingOptions[0].id).checked = true;
    }
    if (ichecked > 0)
    {
        $(ExportProcessingOptions[0].id).checked = false; // Disable the 'none' processing step.
    }

    ExportProcessingOK = null;

    // Add recordLimit FIRST always. Could change when user changes RecordSet specification.
    ExportProcessingArgs = "n=" + RecordLimit;

    // do not put RecordLimit in ProcessingObj
    ProcessingObj = {};

    var isok = 1;
    var nchecked = 0;
    var iProc = 0;
    var nProcs = ExportProcessingOptions.length;
    SizeRatio = 1.0;

    if ($(ExportProcessingOptions[0].id).checked) // no_op case must be first
    {
        // no_op - none processing checkbox is checked
        nchecked++;
        for (iProc=1; iProc<nProcs; iProc++)
        {
            var ExpOpt = ExportProcessingOptions[iProc];
            $(ExpOpt.id).checked = false;
            $(ExpOpt.rowid).style.display = "none";

            if (ExpOpt.id != "OptionImPatch")
            {
                ExpOpt.Init(1);
            }
        }

        ExportProcessingArgs += "|no_op";
    }
    else
    {
        // no_op - none is NOT checked
        for (iProc=1; iProc<nProcs; iProc++)
        {
            // ExportProcessingOptions is a list of all processing options. The command to perform
            // any given option is sent to jsoc_fetch only if ExportProcessingOptions[iProc].id.checked is true.
            // So, the order of the processing steps is the order they appear in ExportProcessingOptions,
            // which is determined in ProcessingInit() in processing.js.
            var ExpOpt = ExportProcessingOptions[iProc];

            if ($(ExpOpt.id).checked)
            {
                nchecked++;
                $(ExportProcessingOptions[0].id).checked = false; // Do not send the 'none' processing option to jsoc_fetch.

                if (ichecked == -2)
                {
                    // This is the on-load case, where we want to initialize all processing parameters to their defaults.
                    ExpOpt.Init(1);
                    $(ExpOpt.rowid).style.display="table-row";
                    isok = 0;

                    // We need to run the check function for each checked option since we changed the record-set; the
                    // Check() functions always run synchronously; they return the arguments to the processing program;

                    if (ExpOpt.hasOwnProperty('Check') && ExpOpt.Check && typeof ExpOpt.Check === 'function')
                    {
                        ExpOpt.paramsValid = null; // blow-away the cache so Check() can actually do the check and generate the command-line arguments.
                        args = ExpOpt.Check(true);

                        if (args == 'error')
                        {
                            // Error that requires the checkbox to be unchecked.
                            $(ExpOpt.id).checked = false;
                            $(ExpOpt.rowid).style.display = 'none';
                            nchecked--;
                        }
                    }
                }
                else
                {
                    $(ExpOpt.rowid).style.display="table-row";
                    // This is the case where we do not want to reset the processing parameters to the default.
                    ExpOpt.Init(0); // 0 initializes globals needed by Check() functions; initialization is asynchronous, so
                                    // we run a setInterval function below, waiting for completion; the Check() functions can modify the UI
                }
            }
            else
            {
                $(ExpOpt.rowid).style.display="none";

                // keep existing argument values for ImPatch only (the other processing options have no way
                // of resetting them to default values, so we have to do that here if the user has unchecked
                // the option's checkbox
                if (ExpOpt.id != "OptionImPatch")
                {
                    ExpOpt.Init(1);
                }
            }
        }

        if (nchecked > 0)
        {
            // The Set() functions can run asynchronously. We have at least one Set() function that succeeded (which means
            // there could be AJAX running).
            ExportProcessingArgsPoll = setInterval(function(){ GetExportProcessingArguments(spCallback); }, 50);

            // Disable all processing-step checkboxes, until GetExportProcessingArguments() resolves.
            for (iProc = 0; iProc < nProcs; iProc++)
            {
                var ExpOpt = ExportProcessingOptions[iProc];
                $(ExpOpt.id).store({ 'disabled_state' : $(ExpOpt.id).disabled })
                $(ExpOpt.id).disabled = true;
            }
        }
    }

    // it is possible that the aia_scale box was unchecked; in this case, we must restore the original
    // filename format (but only if it indeed was changed to one compatible with aia.lev1p5)
    var originalFormat = $('ExportFilenameFmt').retrieve('originalFormat', null);
    if (originalFormat !== null)
    {
        // the originalFormat value data has been set, so the original format was changed to one compatible with aia.levp5;
        // restore the original if the aia_scale check box is no longer checked
        if ($('OptionAiaScale').checked == false)
        {
            $('ExportFilenameFmt').value = originalFormat;
            $('ExportFilenameFmt').store({ 'valid' : true });
        }

        // blow away the args-ready state so that Check() is run the next time the user checks the aia_scale checkbox
        ExportProcessingOptions[AiaScaleOption].paramsValid = null;
    }

  if (nchecked == 0)
    {
    $(ExportProcessingOptions[0].id).checked = true; // Set no-op processing step.

    // Hide the non-no-op steps.
    for (iProc=1; iProc<nProcs; iProc++)
    {
        var ExpOpt = ExportProcessingOptions[iProc];
        $(ExpOpt.rowid).style.display = "none";
    }

    ExportProcessingArgs += "|no_op";
    }
  $("ExportSizeRatio").value = SizeRatio;

  $("ExportProcessingHidden").value = ExportProcessingArgs;

    clearInterval(intervalFn);

    if (ExportProcessingArgsPoll)
    {
        // We don't know if export processing is OK yet.
        ExportProcessingOK = false;
        // do not clear the setProcessingRunning flag
    }
    else
    {
        if (isok)
        {
            ExportProcessingOK = true;
        }
        else
        {
            ExportProcessingOK = false;
        }

        setProcessingRunning = false;

        if (spCallback)
        {
            spCallback();
        }
    }
}
// tester success
</script>
<script type="text/javascript">


// the processing.js code defines SetProcessing as the onChange function for the processing checkboxes
function SetProcessing(ichecked, spCallback)
{
  	var intervalFn;

    // dirty since last time the CP button was clicked
    set_eb_state_disabled(true);

  	setProcessingQueue.push(ichecked)
  	intervalFn = setInterval(function(){ runSetProcessing(intervalFn, spCallback); }, 100);
}

// Cannot determine the arguments at the time that SetProcessing() is called because there might be
// asynchronous processes running (AJAX calls) that need to complete before the arguments can be
// finalized.

// Polling function
function GetExportProcessingArguments(spCallback)
{
    var ExpOpt = null;
    var args = null;
    var iProc = 0;
    var SizeRatio = 1.0;
    var oneChecked = false;
    var argument_argument_obj = null;
    var argument_namespace = null;

    if (!ExportProcessingArgsReady())
    {
        // Wait till all the Set() procs for each processing step have completed their asynchronous processing.
        return;
    }

    for (iProc = 1; iProc < ExportProcessingOptions.length; iProc++)
    {
        ExpOpt = ExportProcessingOptions[iProc];

        if ($(ExpOpt.id).checked)
        {
            args = ExportProcessingOptions[iProc].Check(true);

            if (args === null)
            {
                // a Set() function is pending; wait until it has completed
                return;
            }

            if (args == 'error')
            {
                // Error that requires the checkbox to be unchecked.
                $(ExpOpt.id).checked = false;
                $(ExpOpt.rowid).style.display = 'none';
                continue;
            }

            oneChecked = true;

            // At this point, we know for sure if there is an error with the export options chosen. If so,
            // ignore that processing step, and uncheck its checkbox.
            if (args.length > 0)
            {
                // args contains all the processing args. ExportProcessingArgs will have n=X already.
                ExportProcessingArgs += "|" + args;
                argument_argument_obj = unserialize_arguments(args);
                argument_namespace = Object.keys(argument_argument_obj)[0];
                ProcessingObj[argument_namespace] = argument_argument_obj[argument_namespace];
                SizeRatio *= ExpOpt.Size;
            }
        }
    }

    if (!oneChecked)
    {
        $(ExportProcessingOptions[0].id).checked = true; // Set no-op processing step.

        // Hide the non-no-op steps.
        for (iProc = 1; iProc < ExportProcessingOptions.length; iProc++)
        {
            var ExpOpt = ExportProcessingOptions[iProc];
            $(ExpOpt.rowid).style.display = "none";
        }

        ExportProcessingArgs += "|no_op";
    }

    // Re-enable all processing-step checkboxes, until GetExportProcessingArguments() resolves.
    for (iProc = 0; iProc < ExportProcessingOptions.length; iProc++)
    {
        var ExpOpt = ExportProcessingOptions[iProc];

        $(ExpOpt.id).disabled = $(ExpOpt.id).retrieve('disabled_state', false);
    }

    $("ExportSizeRatio").value = SizeRatio;
    $("ExportProcessingHidden").value = ExportProcessingArgs; // Not used.

    clearInterval(ExportProcessingArgsPoll);
    ExportProcessingArgsPoll = null;
    ExportProcessingOK = true; // This means that everything that is going to modify the export arguments has completed
                               // modifying said parameters. It does NOT mean that the parameter values are acceptable.

    setProcessingRunning = false;

    if (spCallback)
    {
        spCallback();
    }
}

// called when user changes protocol (export file format) pulldown
function SetExportProtocol(byWhom)
{
    // byWhom is 'vestigial'

    // dirty since last time the CP button was clicked
    set_eb_state_disabled(true);

    update_protocol_ui(false);
}

// respond to changes in the protocol options elements (only image options at this point)
function update_protocol_options_ui(reset)
{
    // reset validation on all protocol options (only image options at this point)
    $('ProtocolImageOptions').store({ "valid" : null });
    $('ExportProtocolHidden').store({ "valid" : null });

    if (reset)
    {
        update_protocol_options(true);
        update_hidden_protocol(true);
    }
    else
    {
        update_protocol_options(false);
        if (!validate_protocol_options())
        {
            alert('invalid image options');
            // current child data are invalid; fix by calling with reset flag
            update_protocol_options(true);
        }

        update_hidden_protocol(false);
        if (!validate_hidden_protocol())
        {
            update_hidden_protocol(true);
        }
    }
}

// called when the user modifies ImageCT
function ProtocolImageUserSet(opt)
{
    // `opt` is 'vestigial'

    // dirty since last time the CP button was clicked
    set_eb_state_disabled(true);

    update_protocol_options_ui(false);
}

// called when...
// 1. initializing image options with color-table metadata
// 2. the user has clicked on the reset-defaults button
// if the user modifies the ImageCT UI element, the result is a change to the 
// text elements that appear to the right of the image-option elements;
// there is no `reset` argument since this function is called only when resetting
// the options UI
function reset_image_protocol_options(record_set_series, record_set_wavelength, color_table_metadata)
{
    alert('reset_image_protocol_options');
    // use the specified wavelength to choose an appropriate color table, and then 
    // use the values from the color table to set the UI element values
    var series_wave = null;
    var series_wave_map = null;
    var metadata = null;
    var image_color_table_element = $('ImageCT');
    var image_min_element = $('ImageMin');
    var image_max_element = $('ImageMax');
    var scale = null;
    var image_scale_element = $('ImageScl');
    var index = null;

    series_wave = record_set_series.trim().toLowerCase() + ':' + record_set_wavelength.toString();

    if (color_table_metadata !== null && color_table_metadata.hasOwnProperty('series_wave_map') && color_table_metadata.series_wave_map !== null)
    {
        series_wave_map = color_table_metadata.series_wave_map;
    }

    if (series_wave_map !== null)
    {
        metadata = series_wave_map[series_wave];
    }

    if (metadata === undefined)
    {
        $('ImageSer').innerHTML = '[ no colortable located for ' + record_set_series + '; unless edited, min/max will be derived from data ]';
        $('ImageCT').selectedIndex = $('ImageCT').options.length - 1;
        $('ImageMin').value = 'NOT SPECIFIED';
        $('ImageMin').store({ "specified" : false });
        $('ImageMax').value = 'NOT SPECIFIED';
        $('ImageMax').store({ "specified" : false });

        if (color_table_metadata.scale_indexes['MINMAX'] === undefined)
        {
            $('ImageScl').selectedIndex = $('ImageCT').options.length - 1;
        }
        else
        {
            $('ImageScl').selectedIndex = color_table_metadata.scale_indexes['MINMAX'];
        }
    }
    else
    {
        $('ImageSer').innerHTML = metadata['series'];
        $('ImageCT').selectedIndex = color_table_metadata.color_table_indexes[metadata['ct']];
        $('ImageMin').value = metadata['min'];
        $('ImageMin').store({ "specified" : true });
        $('ImageMax').value = metadata['max'];
        $('ImageMax').store({ "specified" : true });
        $('ImageScl').selectedIndex = color_table_metadata.scale_indexes[metadata['scaling']];
    }

    $('ImageSize').selectedIndex = 2; // 512x512 image

    $('ImageSize').store({ "specified" : true });

    update_hidden_protocol(false);

    $('ProtocolImageOptions').store({ "initialized" : true });

    set_eb_state_disabled(true);
}

function validate_image_protocol_options(series, wavelength, color_table_metadata)
{
    var protocol = $('ExportProtocol').value.trim();
    var protocol_argument = null;
    var hidden_protocol = $('ExportProtocolHidden').value.trim();
    var image_ct = null; 
    var image_scaling = null;
    var image_zoom = null; // 1, 4, 8, or 16
    var image_min = null; // number or not specified
    var image_max = null; // number or not specified
    var image_list = [];
    var protocol_list = [];
    var index = null;
    var valid = null;

    if ($('ImageCT').selectedIndex != -1)
    {
        image_ct = $('ImageCT').options[$('ImageCT').selectedIndex].value.trim(); // color table, or not specified
    }
    else
    {
        image_ct = $('ImageCT').value.trim();
    }

    if ($('ImageScl').selectedIndex != -1)
    {
        image_scaling = $('ImageScl').options[$('ImageScl').selectedIndex].value.trim(); // color table, or not specified
    }
    else
    {
        image_scaling = $('ImageScl').value.trim();
    }

    if ($('ImageSize').selectedIndex != -1)
    {
        image_zoom = $('ImageSize').options[$('ImageSize').selectedIndex].value.trim(); // color table, or not specified
    }
    else
    {
        image_zoom = $('ImageSize').value.trim();
    }




    valid = $('ProtocolImageOptions').retrieve('valid', null); 

    if (valid === null)
    {
        image_zoom = parseInt(image_zoom);

        if ($('ImageMin').retrieve('specified', false))
        {
            image_min = parseFloat($('ImageMin').value.trim());
        }

        if ($('ImageMax').retrieve('specified', false))
        {
            image_max = parseFloat($('ImageMax').value.trim());
        } 

        if (image_zoom !== 'NaN' && image_zoom > 0 && image_min !== 'NaN' && image_max !== 'NaN' && image_min < image_max)
        {
            valid = true;
        }
        else
        {
            alert('invalid  ' + JSON.stringify(image_zoom) + ' ' + JSON.stringify(image_min) + ' ' + JSON.stringify(image_max));
            valid = false;
        }

        $('ProtocolImageOptions').store({ "valid" : valid });
    }

    return valid;
}

// called only in response to a 'reset defaults' button click; resetting image protocols only
function ProtocolImageDefaults()
{
    var record_set_series = $('ExportRecordSet').retrieve('series', null);
    var record_set_wavelength = $('ExportRecordSet').retrieve('wavelength', null);
    var color_table_metadata = $('ImageCT').retrieve('metadata', null);

    reset_image_protocol_options(record_set_series, record_set_wavelength, color_table_metadata);

    set_eb_state_disabled(true);
}

// callback is reset_image_protocol_options
function initialize_image_protocol_options(update_options_callback)
{
    var color_table_metadata = $('ImageCT').retrieve('metadata', null);
    var metadata_loaded = (color_table_metadata !== null);
    var wavelength = $('ImageCT').retrieve('wavelength', null);
    var wavelength_extracted = (wavelength !== null);
    var extract_wavelength_fn = null;
    var load_color_table_metadata_fn = null;

    extract_wavelength_fn = function(color_table_metadata, update_options_callback)
    {
        var specification = $('ExportRecordSet').value.trim();
        var export_app_arguments = null;
        var options = null;
        var origin = null;
        var db_host = null;
        var on_failure = null;

        origin = ExportOrigin(null);

        if (origin[0] == 'extServer')
        {
            db_host = EXTERNAL_SERVER;
        }
        else
        {
            db_host = INTERNAL_SERVER;
        }

        // uses internal DB - that is where the color table series are stored
        export_app_arguments = { "specification" : specification, "db-host" : db_host, "keywords" : [ "WAVELNTH" ], "number-records" : 1 };

        on_failure = function(error_message, color_table_metadata)
        {
            var record_set_series = $('ExportRecordSet').retrieve('series', null);
            var record_set_wavelength = $('ExportRecordSet').retrieve('wavelength', null);

            // unlike most error cases, do not set the EB state to disabled; we basically just ignore the filling-in-of image 
            // parameters with a color-table 
            update_options_callback(record_set_series, record_set_wavelength, color_table_metadata);
        };

        options =
        {
            method : 'get',
            onSuccess : function(response)
            {
                var gri_response_obj = response.responseJSON;
                var error_message = null;
                var status = null;
                var record_set_series = $('ExportRecordSet').retrieve('series', null);
                var record_set_wavelength = null;
                var color_table_element = $('ImageCT');
                var color_table_metadata = $('ImageCT').retrieve('metadata', null);

                if (gri_response_obj !== null)
                {
                    status = gri_response_obj.drms_export_status;
                    if (status.search(/errorcode/i) == 0)
                    {
                        error_message = 'failure obtaining record-set information: ' + JSON.stringify(gri_response_obj.error_message);
                    }
                    else
                    {
                        record_set_wavelength = Math.round(gri_response_obj.keywords[0].values[0]);
                        $('ExportRecordSet').store({ "wavelength" : record_set_wavelength })
                        update_options_callback(record_set_series, record_set_wavelength, color_table_metadata);
                    }
                }
            },
            onFailure : function(response)
            {
                var error_message = 'failure getting record-set information: ' + JSON.stringify(response.responseJSON.error_message);
                var color_table_metadata = $('ImageCT').retrieve('metadata', null);

                on_failure(error_message, color_table_metadata);
            },
            on428 : function(response)
            {
                var error_message = 'invalid arguments to record-set endpoint: ' + JSON.stringify(response.responseJSON.error_message);
                var color_table_metadata = $('ImageCT').retrieve('metadata', null);

                on_failure(error_message, color_table_metadata);
            }
        };

        options['parameters'] = export_app_arguments;

        new Ajax.Request(window.location.origin + RECORD_SET_PATH, options);
    };

    load_color_table_metadata_fn = function(extract_wavelength_callback, update_options_callback)
    {
        var export_app_arguments = null;
        var options = null;
        var origin = null;
        var db_host = null;
        var on_failure = null;

        origin = ExportOrigin(null);

        if (origin[0] == 'extServer')
        {
            db_host = EXTERNAL_SERVER;
        }
        else
        {
            db_host = INTERNAL_SERVER;
        }

        // uses internal DB - that is where the color table series are stored
        export_app_arguments = { "specification" : "jsoc.color_table_metadata[][]", "db-host" : db_host, "keywords" : [ "Inseries", "WAVELNTH", "CT_name", "scalemin", "scalemax", "scaling" ] };

        on_failure = function(callback)
        {
            var color_table_indexes = {};
            var scale_indexes = {};
            var color_table_metadata = null;

            $('ImageCT').options[0] = new Option('none');
            color_table_indexes['none'] = 0;

            $('ImageCT').options[scale_option_index] = new Option('none');
            scale_indexes['none'] = 0;

            color_table_metadata = { "color_table_indexes" : color_table_indexes, "scale_indexes" : scale_indexes, "keywords" : null, "color_table_map" : null, "series_wave_map" : null };
            $('ImageCT').store({ "metadata" : color_table_metadata });

            if (callback !== null)
            {
                callback($('ExportRecordSet'), null, null);
            }
        };

        options =
        {
            method: 'get',
            onSuccess: function(response)
            {
                var gri_response_obj = response.responseJSON;
                var error_message = null;
                var status = null;
                var number_color_tables = null;
                var color_table_element = $('ImageCT');
                var scale_element = $('ImageScl');
                var index = null;
                var series = null;
                var wavelength = null;
                var min = null;
                var max = null;
                var color_table = null;
                var color_table_indexes = {};
                var color_table_option_index = null;
                var scale = null;
                var scale_indexes = {};
                var scale_option_index = null;
                var keywords = null;
                var color_table_metadata = null;
                var color_table_map = null;
                var series_wave_map = null;

                if (gri_response_obj !== null)
                {
                    status = gri_response_obj.drms_export_status;

                    if (status.search(/errorcode/i) == 0)
                    {
                        color_table_option_index = 0;
                        scale_option_index = 0;
                        error_message = 'no color tables found';

                        color_table_element.options[0] = new Option('none');
                        color_table_indexes['none'] = color_table_option_index;
                        color_table_option_index += 1;

                        scale_element.options[scale_option_index] = new Option('none');
                        scale_indexes['none'] = scale_option_index;
                        scale_option_index += 1;
                    }
                    else
                    {
                        number_color_tables = gri_response_obj.count;

                        if (number_color_tables == 0)
                        {
                            color_table_option_index = 0;
                            scale_option_index = 0;

                            color_table_element.options[0] = new Option('none');
                            color_table_indexes['none'] = color_table_option_index;
                            color_table_option_index += 1;

                            scale_element.options[scale_option_index] = new Option('none');
                            scale_indexes['none'] = scale_option_index;
                            scale_option_index += 1;
                        }
                        else
                        {
                            keywords = gri_response_obj.keywords;
                            color_table_option_index = 0;
                            scale_option_index = 0;
                            color_table_map = {};
                            series_wave_map = {};

                            for (index = 0; index < number_color_tables; index += 1)
                            {
                                series = keywords[0].values[index].trim();
                                wavelength = keywords[1].values[index].trim();
                                color_table = keywords[2].values[index].trim();
                                min = keywords[3].values[index].trim();
                                max = keywords[4].values[index].trim();
                                scale = keywords[5].values[index].trim();

                                if (color_table_indexes[color_table] === undefined)
                                {
                                    color_table_element.options[color_table_option_index] = new Option(color_table);
                                    color_table_indexes[color_table] = color_table_option_index;

                                    // insert into mapping
                                    color_table_map[color_table] = { "series" : series, "ct" : color_table, "min" : min, "max" : max, "scaling" : scale };
                                    
                                    color_table_option_index += 1;
                                }

                                if (scale_indexes[scale] === undefined)
                                {
                                    scale_element.options[scale_option_index] = new Option(scale);
                                    scale_indexes[scale] = scale_option_index;

                                    scale_option_index += 1;
                                }

                                // insert into mapping
                                if (series_wave_map[series + ':' + wavelength] === undefined)
                                {
                                    series_wave_map[series + ':' + wavelength] = { "series": series, "wavelength" : wavelength, "ct" : color_table, "min" : min, "max" : max, "scaling" : scale};
                                }
                            }

                            // add grey as a default
                            color_table = 'grey.sao';
                            if (color_table_indexes[color_table] === undefined)
                            {
                                color_table_element.options[color_table_option_index] = new Option(color_table);
                                color_table_indexes[color_table] = color_table_option_index;
                                color_table_option_index += 1;
                            }
                        }
                    }

                    color_table_metadata = { "color_table_indexes" : color_table_indexes, "scale_indexes" : scale_indexes, "keywords" : keywords, "color_table_map" : color_table_map, "series_wave_map" : series_wave_map };
                    color_table_element.store({ 'metadata' : color_table_metadata });
                }

                // the select lists (pull-downs) are populated; now select options and fill-in other UI elements
                // must get the value of the wavelength of the series
                return extract_wavelength_callback(color_table_metadata, update_options_callback);
            },
            onFailure: function(response)
            {
                var error_message = 'failure obtaining record-set information: ' + JSON.stringify(response.responseJSON.error_message);

                on_failure(update_options_callback);
            },
            on428: function(response)
            {
                var error_message = 'invalid arguments to record-set endpoint: ' + JSON.stringify(response.responseJSON.error_message);
 
                on_failure(update_options_callback);
            }
        };

        options['parameters'] = export_app_arguments;
   
        new Ajax.Request(window.location.origin + RECORD_SET_PATH, options);
    };

    if (metadata_loaded)
    {
        // asynchronous
        if (!wavelength_extracted)
        {
            extract_wavelength_fn(color_table_metadata, update_options_callback);
        }
        else
        {
            update_options_callback($('ExportRecordSet').retrieve('series', null), wavelength, color_table_metadata);
        }
    }
    else
    {
        // asynchronous
        load_color_table_metadata_fn(extract_wavelength_fn, update_options_callback);
    }
}

// update the ExportProtocol UI elements and any stored data; do not touch the protocol-specific
// options or the hidden protocol string
// reset ==> called in response to an RS change, so the disabled state is clean
function update_protocol(reset)
{
    var protocol = $('ExportProtocol').options[$('ExportProtocol').selectedIndex].value.trim().toLowerCase();

    if (reset)
    {
        // fits
        $('ExportProtocol').selectedIndex = 1;
        set_eb_state_disabled(false);
    }
    else
    {
        if (protocol === 'jpeg' || protocol === 'mpeg' || protocol === 'mp4')
        {
            // if we have not initialized the color tables, do that now
            if (!$('ProtocolImageOptions').retrieve('initialized', false))
            {
                initialize_image_protocol_options(reset_image_protocol_options);
            }
        }
    }

    // there is nothing to modify in response to a user UI edit
}

// updates both the ProtocolImageOptions and ExportProtocolHidden elements
// reset ==> called in response to RS change, so disabled state is clean
function update_protocol_options(reset)
{
    var protocol = $('ExportProtocol').options[$('ExportProtocol').selectedIndex].value.trim().toLowerCase();
    var series = $('ExportRecordSet').retrieve('series', null);
    var color_table_element = $('ImageCT');
    var color_table_metadata = color_table_element.retrieve('metadata', null);
    var wavelength = color_table_element.retrieve('wavelength', null);
    var color_table = color_table_element.options[color_table_element.selectedIndex].value.trim();
    var color_table_map = null;
    var metadata = null;

    if (reset)
    {
        // now, we need to reset the options html elements (re-populate with defaults); and if the color tables 
        // have not been loaded already, we need to do that first
        if (protocol === 'as-is')
        {
            // there are no as-is-specific options to reset; as-is does not make use of the hidden protocol string
        }
        else if (protocol === 'fits')
        {
            // there are no fits-specific options to reset
        }
        if (protocol === 'jpeg' || protocol === 'mpeg' || protocol === 'mp4')
        {
            // FULL reset - re-download color table metadata
            color_table_element.store({ "metadata" : null });
            $('ExportRecordSet').store({ "wavelength" : null });
            $('ProtocolImageOptions').store({ "initialized" : null });
        }

        set_eb_state_disabled(false);
    }
    else
    {
        // update protocol-specific UI elements
        if (protocol === 'as-is')
        {
            // there are no as-is-specific options to update; as-is does not make use of the hidden protocol string
        }
        else if (protocol === 'fits')
        {
            // there are no fits-specific options to update
        } 
        if (protocol === 'jpeg' || protocol === 'mpeg' || protocol === 'mp4')
        {
            if ($('ImageMin').value.trim().length > 0)
            {
                $('ImageMin').store({ "specified" : true });
            }
            else
            {
                $('ImageMin').store({ "specified" : false });
            }

            if ($('ImageMax').value.trim().length > 0)
            {
                $('ImageMax').store({ "specified" : true });
            }
            else
            {
                $('ImageMax').store({ "specified" : false });
            }

            if (color_table_metadata !== null && color_table_metadata.color_table_map !== null)
            {
                color_table_map = color_table_metadata.color_table_map;
                metadata = color_table_map[color_table];

                if (metadata !== null)
                {
                    $('ImageCTTxt').innerHTML = metadata['series'];
                    $('ImageMinTxt').innerHTML = metadata['min'];
                    $('ImageMaxTxt').innerHTML = metadata['max'];
                    $('ImageSclTxt').innerHTML = metadata['scaling'];
                }
            }
        }
    }
}

</script>
<script type="text/javascript">

// respond to a change in the protocol pull-down (e.g., FITS --> JPEG); not responding to change in protocol options
// reset ==> called in response to RS change, so disabled state is clean
function update_protocol_ui(reset)
{
    var compression_element = $('CompressRow');
    var protocol = $('ExportProtocol').options[$('ExportProtocol').selectedIndex].value.trim().toLowerCase();

    $('ExportProtocol').store({ "valid" : null });
    $('ExportProtocolHidden').store({ "valid" : null });

    if (reset)
    {
        update_protocol(true);
        update_hidden_protocol(true);
    }
    else
    {
        update_protocol(false);
        if (!validate_protocol())
        {
            update_protocol(true);
        }

        update_hidden_protocol(false);
        if (!validate_hidden_protocol(false))
        {
            update_hidden_protocol(true);
        }
    }

    // always hidden now
    compression_element.style.display = 'none';
    if (protocol === 'as-is' || protocol === 'fits')
    {
        $('ProtocolImageOptions').style.display = 'none';
    }
    else
    {
        $('ProtocolImageOptions').style.display = 'table-row';
    }
}
// tester success
</script>
<script type="text/javascript">



// This function gets called when the Notify field gets modified [exportdata.html only]
function SetExportNotify(clickedByUser)
{
    var address = $("ExportNotify").value.trim();;
    var requestor = $("ExportRequestor").value.trim();
    var snail_address = null; // no UI yet
    var doValidation = true;
    var valid = false;
    var registration_callback = function()
    {
        update_export_buttons();
        check_for_cancel_enabled_shortcut();
    };

    // dirty since last time the CP button was clicked
    set_eb_state_disabled(true);

    // invalidate address
    $("ExportNotify").store('valid', null);
    $("RequestorMessage").innerHTML = "Provide an optional identifier."
    $("ExportCheckMsg").store('cp_message', null);
    $("ExportNotify").store('error_msg', null);

    if (doValidation)
    {
        valid = ValidateNotificationAddress($("ExportNotify"));
        if (valid)
        {
            $("ExportNotify").store('valid', true);

            // disable the CP button since we are actively checking on the address
            update_export_buttons();

            // check_for_cancel_enabled_shortcut() - see if we can go straight to EB_STATE_CANCEL_ENABLED if
            // the user already has a request pending
            // false --> do registration
            // ART
            // register_address(address.slice(0), requestor, snail_address, $("ExportNotify"), $("ExportCheckMsg"), update_export_buttons, registration_callback);

            check_registration(address, requestor, snail_address, $("ExportNotify"), $("ExportCheckMsg"), update_export_buttons, registration_callback);
        }
    }
}

// SetExportUser is called from change in either the Requester or Notify input text boxes.
// There is no call made to check the validity of the notification email address provided
// however. Instead, the user must click on the "Check Params for Export" button.
// [register_email.html only]
function SetExportUser(clickedByUser)
{
    var requestor = null;
    var address = null;
    var newAddress = null;
    var valid = false;

    // invalidate requestor
    $("ExportRequestor").store('valid', null);

    requestor = $("ExportRequestor").value.trim();
    address = $("ExportNotify").value.trim();

    valid = ValidateExportRequestor($("ExportRequestor"));
    if (valid)
    {
        // used to do spd stuff
    }
}

// this function is no longer called when the user changes the compression pulldown because
// the compression row is now hidden
function SetExportCompress()
{
    update_compression_ui(false);
}

// reset ==> called in response to RS change, so disabled state is clean
function update_compression_ui(reset)
{
    var compression_row_element = $('CompressRow');
    var compression_element = $('ExportCompress');

    if (reset)
    {
        // compression is now always hidden, and always set to Rice Compression
        compression_row_element.style.display = 'none';
        compression_element.selectedIndex = 0; // Rice Compression
        compression_element.store({ "valid" : true });

        set_eb_state_disabled(false);
    }
    else
    {
        update_compression(false);
        compression_element.store({ "valid" : null});
        if (!validate_compression())
        {
            update_compression(true);
        }

        // impacts hidden protocol string too
        update_hidden_protocol(false);
        
        // set valid to null - compression changed, which changes the hidden protocol string
        $('ExportProtocolHidden').store({ "valid" : null});
        if (!validate_protocol_options())
        {
            update_hidden_protocol(true); 
        }
    }
}

// reset ==> called in response to RS change, so disabled state is clean
function update_compression(reset)
{
    var compression_element = $('ExportCompress');
    var valid = null;

    if (reset)
    {
        // Rice compression
        compression_element.selectedIndex = 0;
        compression_element.store({ 'valid' : true });

        set_eb_state_disabled(false);
    }

    // there is nothing to modify in response to a user UI edit
}

function validate_compression()
{
    var compression_element = $('ExportCompress');
    var compression = compression_element.options[compression_element.selectedIndex].value.trim().toLowerCase();    
    var valid = null;

    valid = compression_element.retrieve('valid', null);
    if (valid === null)
    {
        if (compression.length == 0 || compression === '**none**' || compression === 'compress Rice')
        {
            valid = true;
        }
        else
        {
            valid = false;
        }

        compression_element.store({ 'valid' : valid });
    }

    return valid;
}

</script>
<script type="text/javascript">

// reset ==> called in response to RS change, so disabled state is clean
function update_hidden_protocol(reset)
{
    var protocol = $('ExportProtocol').options[$('ExportProtocol').selectedIndex].value.trim().toLowerCase();
    var hidden_protocol = null;
    var image_min = parseFloat($('ImageMin').value.trim());
    var image_max = parseFloat($('ImageMax').value.trim());
    var image_ct = null;
    var image_scaling = null;
    var image_zoom = null;
    var index = null;
    var series_info = null;
    var data_type = null;
    var compression_list = [];
    var image_list = [];

    if ($('ImageCT').selectedIndex != -1)
    {
        image_ct = $('ImageCT').options[$('ImageCT').selectedIndex].value.trim(); // color table, or not specified
    }
    else
    {
        image_ct = $('ImageCT').value.trim();
    }

    if ($('ImageScl').selectedIndex != -1)
    {
        image_scaling = $('ImageScl').options[$('ImageScl').selectedIndex].value.trim(); // color table, or not specified
    }
    else
    {
        image_scaling = $('ImageScl').value.trim();
    }

    if ($('ImageSize').selectedIndex != -1)
    {
        image_zoom = $('ImageSize').options[$('ImageSize').selectedIndex].value.trim(); // color table, or not specified
    }
    else
    {
        image_zoom = $('ImageSize').value.trim();
    }

    if (reset)
    {
        $('ExportProtocolHidden').value = '';

        set_eb_state_disabled(false);
    }
    else
    { 
        if (protocol === 'fits')
        {
            // force Rice compression, except for floating-point images
            series_info = get_current_series_info();

            if (series_info !== null)
            {
                for (index = 0; index < series_info.segments.length; index += 1)
                {
                    data_type = series_info.segments[index].type.time.toLowerCase();

                    if (data_type === 'float' || data_type === 'double')
                    {
                        compression_list.push('**NONE**');
                    }
                    else
                    {
                        compression_list.push('compress Rice');
                    }
                }

                if (compression_list.length > 0)
                {
                    $('ExportProtocolHidden').value = protocol + ',' + compression_list.join(',');
                }
                else
                {
                    $('ExportProtocolHidden').value = protocol;
                }

                set_eb_state_disabled(true);
            }
        }
        else
        {
            if (protocol === 'mpeg')
            {
                hidden_protocol = 'mpg';
            }
            else if (protocol = 'mp4')
            {
                hidden_protocol = 'mp4';
            }
            else if (protocol = 'jpeg')
            {
                hidden_protocol = 'jpg';
            }

            if (hidden_protocol !== null)
            {
                if ($('ImageMin').retrieve('specified', false))
                {
                    image_list.push('min=' + parseFloat($('ImageMin').value.trim()).toString());
                }

                if ($('ImageMax').retrieve('specified', false))
                {
                    image_list.push('max=' + parseFloat($('ImageMax').value.trim()).toString());
                }

                image_list.push('CT=' + $('ImageCT').value.trim());

                image_list.push('scaling=' + $('ImageScl').value.trim());

                image_list.push('size=' + parseFloat($('ImageSize').options[$('ImageSize').selectedIndex].value.trim()).toString());

                $('ExportProtocolHidden').value = hidden_protocol;
                
                if (image_list.length > 0)
                {
                    $('ExportProtocolHidden').value = hidden_protocol + ',' + image_list.join(',');
                }
                else
                {
                    $('ExportProtocolHidden').value = hidden_protocol;
                }

                set_eb_state_disabled(true);
            }
        }
    }

    return $('ExportProtocolHidden').value;
}


</script>
<script type="text/javascript">

function validate_protocol()
{
    var series_info = null;
    var protocol = $('ExportProtocol').options[$('ExportProtocol').selectedIndex].value.trim().toLowerCase();
    var valid = null;

    valid = $('ExportProtocol').retrieve('valid', null);
   
    if (valid === null)
    {
        if (protocol === 'as-is' || protocol === 'fits' || protocol === 'jpeg' || protocol === 'mpeg' || protocol === 'mp4')
        {
            valid = true;
        }
        else
        {
            valid = false;
        }

        $('ExportProtocol').store({ 'valid' : valid });
    }

    return valid;
}

</script>
<script type="text/javascript">

function validate_hidden_protocol()
{
    var hidden_protocol = null;
    var protocol_list = null;
    var protocol = null;
    var series_info = null;
    var data_type = null;
    var compression_list = null;
    var image_list = null;
    var image_ct = null;
    var image_scaling = null;
    var image_zoom = null;
    var protocol_argument = null;
    var index = null;
    var valid = null;

    valid = $('ExportProtocolHidden').retrieve('valid', null);

    if (valid === null)
    {
        hidden_protocol = $('ExportProtocolHidden').value.trim();
        protocol = $('ExportProtocol').options[$('ExportProtocol').selectedIndex].value.trim().toLowerCase(); 

        if (hidden_protocol.length == 0)
        {
            if (protocol === 'fits')
            {
                valid = false;
            }
            else if (protocol === 'jpeg' || protocol === 'mpeg' || protocol === 'mp4')
            {
                valid = false;
            }
            else
            {
                // should have 'as-is' at least
                valid = false;
            }
        }
        else
        {
            protocol_list = hidden_protocol.split(',');

            if (protocol === 'fits')
            {
                series_info = get_current_series_info();

                if (series_info === null)
                {
                    valid = false;
                }
                else
                {
                    compression_list = ['fits'];

                    for (index = 0; index < series_info.segments.length; index += 1)
                    {
                        data_type = series_info.segments[index].type.trim().toLowerCase();

                        if (data_type === 'float' || data_type === 'double')
                        {
                            compression_list.push('**NONE**');
                        }
                        else
                        {
                            compression_list.push('compress Rice');
                        }
                    }

                    if (compression_list.length == protocol_list.length)
                    {
                        valid = true;
                        for (index = 0; index < protocol_list.length; index += 1)
                        {
                            if (compression_list[index].trim() != protocol_list[index].trim())
                            {
                                alert('problem ' + JSON.stringify(compression_list[index].trim()) + ' ' + JSON.stringify(protocol_list[index].trim()));
                                valid = false;
                                break;
                            }
                        }
                    }
                    else
                    {
                        valid = false;
                    }
                }
            }
            else if (protocol === 'jpeg' || protocol === 'mpeg' || protocol === 'mp4')
            {
                protocol_list.sort();
                image_list = [];

                if (protocol === 'mpeg')
                {
                    protocol_argument = 'mpg';
                }
                else if (protocol = 'mp4')
                {
                    protocol_argument = 'mp4';
                }
                else if (protocol = 'jpeg')
                {
                    protocol_argument = 'jpg';
                }

                if (protocol_argument !== null)
                {
                    image_list.push(protocol_argument);
                    
                    if ($('ImageMin').retrieve('specified', false))
                    {
                        image_list.push('min=' + parseFloat($('ImageMin').value.trim()).toString());
                    }

                    if ($('ImageMax').retrieve('specified', false))
                    {
                        image_list.push('max=' + parseFloat($('ImageMax').value.trim()).toString());
                    }

                
                    if ($('ImageCT').selectedIndex != -1)
                    {
                        image_ct = $('ImageCT').options[$('ImageCT').selectedIndex].value.trim(); // color table, or not specified
                    }
                    else
                    {
                        image_ct = $('ImageCT').value.trim();
                    }

                    if ($('ImageScl').selectedIndex != -1)
                    {
                        image_scaling = $('ImageScl').options[$('ImageScl').selectedIndex].value.trim(); // color table, or not specified
                    }
                    else
                    {
                        image_scaling = $('ImageScl').value.trim();
                    }

                    if ($('ImageSize').selectedIndex != -1)
                    {
                        image_zoom = $('ImageSize').options[$('ImageSize').selectedIndex].value.trim(); // color table, or not specified
                    }
                    else
                    {
                        image_zoom = $('ImageSize').value.trim();
                    }
                

                    image_list.push('CT=' + image_ct);
                    image_list.push('scaling=' + image_scaling);
                    image_list.push('size=' + parseFloat(image_zoom).toString());

                    image_list.sort();
                }

                if (image_list.length == protocol_list.length)
                {
                    valid = true;
                    for (index = 0; index < protocol_list.length; index += 1)
                    {
                        if (image_list[index].trim() != protocol_list[index].trim())
                        {
                            alert('problem ' + JSON.stringify(image_list[index].trim()) + ' ' + JSON.stringify(protocol_list[index].trim()));
                            valid = false;
                            break;
                        }
                    }
                }
                else
                {
                    valid = false;
                }
            }
            else
            {
                // should be no arguments (no comma-sep list after protocol); as-is used to have arguments, but they were never used
                if (hidden_protocol.indexOf(',') == -1)
                {
                    valid = true;
                }
                else
                {
                    valid = false;
                }
            } 
        }

        $('ExportProtocolHidden').store({ "valid": valid });
    }

    return valid;
}

function validate_fits_protocol_options()
{
    return true;
}

function validate_as_is_protocol_options()
{
    return true;
} 

function validate_protocol_options()
{
    var protocol = $('ExportProtocol').options[$('ExportProtocol').selectedIndex].value.trim().toLowerCase();
    var valid = null;

    if (protocol === 'fits')
    {
        valid = validate_fits_protocol_options();
    }
    else if (protocol === 'jpeg' || protocol === 'mpeg' || protocol === 'mp4')
    {
        valid = $('ProtocolImageOptions').retrieve('valid', null);
        if (valid === null)
        {
            valid = validate_image_protocol_options();
            $('ProtocolImageOptions').store({ "valid" : valid });
        }
    }
    else
    {
        valid = validate_as_is_protocol_options();
    }

    return valid;
}

function get_current_series_info()
{
    var record_set_element = $('ExportRecordSet');
    var series = record_set_element.retrieve('series', null);
    var series_cache = record_set_element.retrieve('series_cache', {});
    var info = null;

    if (series !== null)
    {
        info = series_cache[series];
    }

    return info;
}

function validate_fits_protocol_options()
{
    var series_info = null;
    var index = null;
    var data_type = null;
    var compression_list = [];

    series_info = get_current_series_info();

    if (series_info === null)
    {
        valid = false;
    }
    else
    {
        for (index = 0; index < series_info.segments.length; index += 1)
        {
            data_type = series_info.segments[index].type.time.toLowerCase();

            if (data_type === 'float' || data_type === 'double')
            {
                compression_list.push('**NONE**');
            }
            else
            {
                compression_list.push('compress Rice');
            }
        }
    }

    if (compression_list.length > 0)
    {
        if (hidden_protocol.indexOf(compression_list.join(',')) == -1)
        {
            valid = false;
        }
        else
        {
            valid = true;
        }
    }
    else
    {
        // no segments
        valid = true;
    }

    return valid;
}

// Notify and Requestor checking is now in the email registration js script.

function ExportShowQuery()
{
    var args = null;
    var paramString = null;

    if ($("ShowQueryCheckbox").checked)
    {
        args = $('ExportRecordSet').retrieve('exportArgs', null);

        if (args != null)
        {
            paramString = decodeURIComponent(Object.toQueryString(args));
            if (paramString)
            {
                $("ExportParameters").innerHTML = paramString.replace(/&/g,"&amp;");
            }
        }
    }
    else
    {
        $("ExportParameters").innerHTML = "";
    }
}
// tester success
</script>
<script type="text/javascript">


function disable_input()
{
    $("FileUploadCheckbox").disabled = true;
    $('ExportRecordSet').disabled = true;
    $("ExportRecordLimit").disabled = true;
    $("CountButton").disabled = true;
    $("ExportMethod").disabled = true;
    $('ExportFilenameFmt').disabled = true;
    $("ProcessingCheckbox").disabled = true;
    $('ExportProtocol').disabled = true;
    $("ExportNotify").disabled = true;
}

function enable_input(address_too)
{
    $("FileUploadCheckbox").disabled = false;
    $('ExportRecordSet').disabled = false;
    $("ExportRecordLimit").disabled = false;
    $("CountButton").disabled = false;
    $("ExportMethod").disabled = false;
    $('ExportFilenameFmt').disabled = false;
    $("ProcessingCheckbox").disabled = false;
    $('ExportProtocol').disabled = false;
    if (address_too)
    {
        $("ExportNotify").disabled = false;
    }
}

function set_eb_state_disabled(make_dirty)
{
    var state = null;
    var interval_fn_timer = null;
    var interval_fn_timeout = null;

    if (make_dirty)
    {
        // do not allow the user to change email address at this point (do that on reload)
        $("ExportCheckButton").store({ 'dirty' : true });
    }
    else
    {
        $("ExportCheckButton").store({ 'dirty' : false });
    }

    // the only acceptable states are EB_STATE_DISABLED, EB_STATE_SUBMIT_ENABLED, EB_STATE_PATH, EB_STATE_CANCEL
    state = $("ExportButton").retrieve('state', EB_STATE_DISABLED);

    if (state == EB_STATE_DISABLED)
    {

    }
    else if (state == EB_STATE_SUBMIT_ENABLED || state == EB_STATE_PATH || state == EB_STATE_CANCEL || state == EB_STATE_CANCELED || statue == EB_STATE_TIMEOUT)
    {
        // EB_STATE_SUBMIT_ENABLED - user wants to change input instead of clicking on `submit`
        // EB_STATE_PATH - export request complete, time to reset for the next request
        // EB_STATE_CANCEL - user clicked on `cancel` button, and the export request was canceled
        // EB_STATE_CANCELED - user clicked on `continue` button, and the canceled export request was cleared
        // EB_STATE_TIMEOUT - the export button interval function ran for too long without user intervention,
        //                    (like clicking on the button)

        // clear interval
        interval_fn_timer = $("ExportButton").retrieve('interval', null);
        if (interval_fn_timer !== null)
        {
            clearInterval(interval_fn_timer);
            $("ExportButton").store('interval', null);
        }

        interval_fn_timeout = $("ExportButton").retrieve('interval_timeout', null);;
        if (interval_fn_timeout !== null)
        {
            clearTimeout(interval_fn_timeout);
            $("ExportButton").store('interval_timeout', null);
        }

        $("ExportButton").store('state', EB_STATE_DISABLED);
        // $("ExportCheckMsg").store({ 'cp_message' : '' });
        $("ExportCheckMsg").store('cp_message', null);
    }
    else
    {
        $("ExportCheckMsg").store({ 'cp_message' : 'Cannot change input while state is ' + state });
    }

    update_export_buttons();
}
// tester success
</script>
<script type="text/javascript">


// update label, color, disabled
function update_export_buttons()
{
    var state = $("ExportButton").retrieve('state', EB_STATE_DISABLED);
    var check_message = $("ExportCheckMsg").retrieve('cp_message', null);
    var addresses = $("ExportNotify").retrieve('addresses', {});
    var address = $("ExportNotify").value.trim();
    var address_valid = null;
    var requestor = $("ExportRequestor").value.trim();
    var requestor_valid = null;
    var error_msg = $("ExportNotify").retrieve('error_msg', null);
    var registration_status = null;
    var checking_registration = null;
    var registration_pending = null;
    var address_registered = null;
    var eb_dirty = $("ExportCheckButton").retrieve('dirty', false); // dirty == false ==> page was reset

    if (state == EB_STATE_DISABLED)
    {
        if (addresses !== null && address.length > 0 && Object.prototype.hasOwnProperty.call(addresses, address) && Object.prototype.hasOwnProperty.call(addresses[address], 'registration_status'))
        {
            registration_status = addresses[address].registration_status;
        }

        if (address.length > 0)
        {
            // after ValidateNotificationAddress(), `valid` element attribute is always set
            address_valid = ($("ExportNotify").retrieve('valid', null) === null) ? ValidateNotificationAddress($("ExportNotify")) : $("ExportNotify").retrieve('valid', false);
        }

        if (requestor.length > 0)
        {
            // after ValidateExportRequestor(), `valid` element attribute is always set
            requestor_valid = ($("ExportRequestor").retrieve('valid', null) === null) ? ValidateExportRequestor($("ExportRequestor")) : $("ExportRequestor").retrieve('valid', false);
        }

        if (address.length > 0 && !address_valid)
        {
            check_message = error_msg;
        }
        else if (requestor.length > 0 && !requestor_valid)
        {
            check_message = requestor_error_msg;
        }

        checking_registration = (registration_status == 'checking') ? true : false
        registration_pending = (registration_status == 'registering' || registration_status == 'pending') ? true : false;
        address_registered = (registration_status !== null && (typeof(registration_status) === 'boolean') && registration_status) ? true : false;

        if ($("ExportCheckButton").retrieve('on_demand', null))
        {
            // on_demand pending-request check happening
            // auto-checking for pending-request to allow user to cancel it before entering a new record-set
            $("ExportCheckButton").style.backgroundColor = colorRed;
            $("ExportCheckButton").value = 'wait...';
            $("ExportCheckButton").disabled = true;
            $("ExportCheckMsg").style.color = colorRealRed;
            $("ExportNotify").disabled = true;
            $("ExportRequestor").disabled = true;

            if (check_message === null)
            {
                check_message = 'Checking for pending request...';
            }
            $("ExportCheckMsg").innerHTML = check_message;
        }
        else
        {
            // no on-demand registration check happening; a user-requested export could be happening, or no address registration/check
            // happening at all (could have completed already, or there never has been  one)
            $("ExportCheckButton").style.backgroundColor = colorYellow;
            // ART
            $("ExportCheckButton").value = address_registered ? 'check parameters' : 'register address';

            if (!address_valid && address.length > 0)
            {
                $("ExportCheckButton").disabled = true;
                $("ExportNotify").disabled = false;
            }
            else if (!requestor_valid && requestor.length > 0)
            {
                $("ExportCheckButton").disabled = true;
                $("ExportRequestor").disabled = false;
            }
            else if ((registration_status !== null && (typeof(registration_status) != 'boolean')) || (error_msg !== null && error_msg.length > 0))
            {
                // an error other than invalid address or requestor syntax
                $("ExportCheckButton").disabled = true;
                $("ExportNotify").disabled = true;
                $("ExportRequestor").disabled = true;

                if (!registration_pending && !checking_registration)
                {
                    $("ExportNotify").disabled = false;
                    $("ExportNotifyMsg").innerHTML = "REGISTRATION FAILURE";
                }
            }
            else
            {
                // no error
                if (registration_pending || checking_registration)
                {
                    $("ExportCheckButton").disabled = true;
                    $("ExportNotify").disabled = true;
                    $("ExportRequestor").disabled = true;
                    $("ExportNotifyMsg").style.color = colorDarkBlue;

                    if (registration_pending)
                    {
                        $("ExportNotifyMsg").innerHTML = "registering...";
                    }
                    else
                    {
                        $("ExportNotifyMsg").innerHTML = "checking...";
                    }
                }
                else
                {
                    $("ExportCheckButton").disabled = false;

                    if (address_registered)
                    {
                        $("ExportNotify").disabled = true;
                        $("ExportRequestor").disabled = true;
                    }
                    else
                    {
                      $("ExportNotify").disabled = false;
                      $("ExportRequestor").disabled = false;
                    }
                }
            }

            $("ExportCheckMsg").style.color = colorRealRed;
            if (check_message === null)
            {
                if (!address_registered)
                {
                    if (address.length == 0)
                    {
                        check_message = 'Please enter an email address in the Notify text box';
                    }
                    else
                    {
                        check_message = 'Click to register email address';
                    }
                }
                else if ($('ExportRecordSet').value.length == 0)
                {
                    check_message = 'Please enter a record-set specification';
                }
                else
                {
                    check_message = 'Click to check export parameters and continue';
                }
            }
            $("ExportCheckMsg").innerHTML = check_message;
        }

        $("ExportButton").style.backgroundColor = colorRed;
        $("ExportButton").value = "not ready"
        $("ExportButton").disabled = true;
        $("ExportButtonMsg").style.color = colorBlack;

        if ($("StatusRequestID").value.length == 0)
        {
            $("ExportButtonMsg").innerHTML = 'Click on "check parameters" first';
        }
        else
        {
            // still finishing a previous export request
            $("ExportButtonMsg").style.color = colorRealRed;
            $("ExportButtonMsg").innerHTML = "Fetch data from the URLs below before starting a new request";
        }

        // check for registration complete
        if (registration_status !== null)
        {
            if (typeof(registration_status) == 'boolean')
            {
                if (registration_status)
                {
                    $("ExportNotifyMsg").style.color = colorDarkGreen;
                    $("ExportNotifyMsg").innerHTML = "REGISTERED";
                    $("ExportNotify").disabled = true;
                    $("ExportRequestor").disabled = true;
                }
                else
                {
                    $("ExportNotifyMsg").style.color = colorDarkRed;
                    $("ExportNotifyMsg").innerHTML = "UNREGISTERED";
                    $("ExportNotify").disabled = false;
                    $("ExportRequestor").disabled = false;
                }
            }
            else if (registration_pending)
            {
                $("ExportNotifyMsg").style.color = colorDarkBlue;
                $("ExportNotify").disabled = true;
                $("ExportRequestor").disabled = true;
                $("ExportNotifyMsg").innerHTML = "registering...";
            }
        }

        enable_input(!eb_dirty && !address_registered);
    }
    else if (state == EB_STATE_ENABLED)
    {
        $("ExportCheckButton").disabled = true;

        $('ExportCheckMsg').style.backgroundColor = colorBlack;
        if (check_message === null)
        {
            check_message = '';
        }
        $('ExportCheckMsg').innerHTML = check_message;

        $("ExportButton").value = "wait...";
        $("ExportButtonMsg").innerHTML = '';

        // the user has already selected all the export parameters; don't allow them to change them
        disable_input();
    }
    else if (state == EB_STATE_SUBMIT_ENABLED)
    {
        $('ExportCheckMsg').innerHTML = '';

        $("ExportButton").style.backgroundColor = colorGreen;
        $("ExportButton").value = "submit";
        $("ExportButton").disabled = false;
        $("ExportButtonMsg").style.color = colorRealRed;
        $("ExportButtonMsg").innerHTML = 'Click to submit export request (or modify input to cancel submission)';

        // allow the user to change the record set (but not the email address)
        enable_input();
    }
    else if (state == EB_STATE_SUBMIT)
    {
        $('ExportCheckMsg').innerHTML = '';

        if ($('ExportButton').retrieve('error', false))
        {
            $('ExportButton').value = $('ExportButton').retrieve('label', 'FAILURE...');
            $('ExportButton').style.backgroundColor = colorDarkPink;
            $('ExportButtonMsg').innerHTML = $('ExportButtonMsg').retrieve('message', 'failure initiating export request');
        }
        else
        {
            $('ExportButton').value = $('ExportButton').retrieve('label', 'wait...');
            $('ExportButton').style.backgroundColor = colorYellow;
            $('ExportButtonMsg').innerHTML = $('ExportButtonMsg').retrieve('message', '');
        }

        disable_input();
    }
    else if (state == EB_STATE_CANCEL_ENABLED)
    {
        $("ExportCheckButton").disabled = true;
        $("ExportCheckMsg").style.color = colorBlack;
        $("ExportCheckMsg").innerHTML = '';

        $('ExportButton').style.backgroundColor = colorGreen;

        if ($('ExportButton').retrieve('error', false))
        {
            $('ExportButton').value = $('ExportButton').retrieve('label', 'FAILURE...');
            $('ExportButton').style.backgroundColor = colorDarkPink;
            $('ExportButtonMsg').innerHTML = $('ExportButtonMsg').retrieve('message', 'failure initiating export request');
        }
        else
        {
            $('ExportButton').value = $('ExportButton').retrieve('label', 'FAILURE...');
            $('ExportButton').style.backgroundColor = colorDarkPink;
            $('ExportButtonMsg').innerHTML = $('ExportButtonMsg').retrieve('message', 'failure initiating export request');
        }

        $("ExportButton").disabled = false;
        $("ExportButtonMsg").style.color = colorRealRed;

        disable_input();
    }
    else if (state == EB_STATE_PATH)
    {
        $('ExportCheckMsg').innerHTML = '';

        if ($('ExportButton').retrieve('error', false))
        {
            $('ExportButton').value = $('ExportButton').retrieve('label', 'FAILURE...');
            $('ExportButton').style.backgroundColor = colorDarkPink;
            $('ExportButtonMsg').innerHTML = $('ExportButtonMsg').retrieve('message', 'failure exporting data');
        }
        else
        {
            $('ExportButton').value = $('ExportButton').retrieve('label', 'get path');
            $('ExportButton').style.backgroundColor = colorGreen;
            $('ExportButtonMsg').innerHTML = $('ExportButtonMsg').retrieve('message', 'click to obtain URL path to exported data');
        }

        $("ExportButton").disabled = false;

        disable_input();
    }
    else if (state == EB_STATE_CANCEL)
    {
        $('ExportCheckMsg').innerHTML = '';

        if ($('ExportButton').retrieve('error', false))
        {
            $('ExportButton').value = $('ExportButton').retrieve('label', 'FAILURE...');
            $('ExportButton').style.backgroundColor = colorDarkPink;
            $('ExportButtonMsg').innerHTML = $('ExportButtonMsg').retrieve('message', 'failure cancelling export');
        }
        else
        {
            $('ExportButton').value = $('ExportButton').retrieve('label', 'wait...');
            $('ExportButton').style.backgroundColor = colorGreen;
            $('ExportButtonMsg').innerHTML = $('ExportButtonMsg').retrieve('message', 'cancelling export');
        }

        $('ExportButton').disabled = true;

        disable_input();
    }
    else if (state == EB_STATE_CANCELED)
    {
        $('ExportCheckMsg').innerHTML = '';

        if ($('ExportButton').retrieve('error', false))
        {
            $('ExportButton').value = $('ExportButton').retrieve('label', 'FAILURE...');
            $('ExportButton').style.backgroundColor = colorDarkPink;
            $('ExportButtonMsg').innerHTML = $('ExportButtonMsg').retrieve('message', 'unable to proceed');
        }
        else
        {
            $('ExportButton').value = $('ExportButton').retrieve('label', 'canceled');
            $('ExportButton').style.backgroundColor = colorRed;
            $('ExportButtonMsg').innerHTML = $('ExportButtonMsg').retrieve('message', 'export request canceled; click to continue');
        }

        $('ExportButton').disabled = false;
    }
}

// tester success
</script>
<script type="text/javascript">

// returns boolean now
function is_ok_to_submit(element, attribute)
{
    var return_messages = false;
    var is_ok = true;
    var address = null;
    var message = null;
    var protocol = null;

    if (element && element !== undefined && attribute && attribute !== undefined)
    {
        return_messages = true;
    }

    if (!NotificationAddressRegistered($('ExportNotify')))
    {
        address = $('ExportNotify').value.trim();
        if (address.length > 0)
        {
            message = 'Email address ' + address + ' is not registered';
        }
        else
        {
            message = 'Please enter email address';
        }

        is_ok = false;
    }

    if (is_ok)
    {
        if (!ExportRecordSetOK)
        {
            message = 'Please enter valid record-set specification';
            is_ok = false;
        }
    }

    if (is_ok)
    {
        if (!$('ExportMethod').retrieve('valid', false))
        {
            message = 'Please select export method';
            is_ok = false;
        }
    }

    if (is_ok)
    {
        if (!$('ExportFilenameFmt').retrieve('valid', false))
        {
            message = 'Please enter file-name format string';
            is_ok = false;
        }
    }

    if (is_ok)
    {
        if (!$('ExportProtocol').retrieve('valid', false))
        {
            message = 'Please select export protocol';
            is_ok = false;
        }
    }

    if (is_ok)
    {
        protocol = $('ExportProtocol').options[$('ExportProtocol').selectedIndex].value.trim().toLowerCase();

        if ((protocol === 'fits' || protocol === 'jpeg' || protocol === 'mpeg' || protocol === 'mp4') && !$('ExportProtocolHidden').retrieve('valid', false))
        {
            message = 'Internal error: hidden protocol string not set';
            is_ok = false;
        }
    }

    if (is_ok)
    {
        if ($("ProcessingCheckbox").checked && (!ExportProcessingOK || !ProcessingOK()))
        {
            message = 'Processing details not correct, fix and retry export request';
            is_ok = false;
        }
    }

    if (return_messages)
    {
        element.store(attribute, message);
    }

    return is_ok;
}

function check_for_cancel_enabled_shortcut()
{
    // this is an asyncrhonous check, so we need to have the CP button "wait..." while the check occurs
    // and then call this function back after completion; on_demand attribute:
    //   null/false --> no on_demand check occurring
    //   true --> on_demand check in progress
    if ($("ExportNotify").value.trim().length > 0 && !$("ExportCheckButton").retrieve('on_demand', null))
    {
        // not currently checking pending-user status (on_demand check); and
        // not making an interval check either since the CP button is disabled while that is occuring
        $("ExportCheckButton").store({ 'on_demand' : true });
        update_export_buttons();

        // most likely the email check is already done at this point, but if not, then ...
        // 1. if the email XHR has already begun, then the callback will be repeatedly called
        //    until resolution and caching of the registation status in $("ExportNotify").retrieve('addresses', {});
        // 2. if the email XHR has not already begun (not likely), then it will be started and then the
        //    callback will be executed as in 1.
        //
        // either way, call NotificationAddressRegistered() in the callback until we get an answer, at which point
        // we can then branch to code that either:
        // 1. sets the EB state to EB_STATE_CANCEL_ENABLED (if the email is registered and there is a pending update); we
        //    need to always check the record-set spec - if it is present, then do not change the EB state
        // 2. do not change EB state (the email is not registered - the user will see a message asking them to register one)

        // check for registered email address, then pending user request

        var check_registered_callback_fn = function()
        {
            var address = $("ExportNotify").value.trim();
            var addresses = null;
            var registration_status = null;
            var registered = null;
            var error_msg = null;

            if (!$("ExportCheckButton").retrieve('on_demand', null))
            {
                // we are done, but the callback is still being called by the email-check code
                update_export_buttons();
                return;
            }

            // email address is valid, but is it registered?
            addresses = $("ExportNotify").retrieve('addresses', {});

            if (addresses && addresses.hasOwnProperty(address))
            {
                registration_status = addresses[address].registration_status;
                if (typeof(registration_status) === 'string')
                {
                    if (registration_status == 'registering' || registration_status == 'pending')
                    {
                      alert('should not be here');
                        registered = null;
                    }
                    else if (registration_status == 'timed_out_server')
                    {
                        // registration process timeout (not timeout due to no response from AJAX call)
                        registered = false;
                        error_msg = $("ExportNotify").retrieve('error_msg', null);
                        $("ExportCheckMsg").store('cp_message', error_msg);
                    }
                    else if (registration_status == 'timed_out_client')
                    {
                        // registration process timeout (client did not respond to email in time)
                        registered = false;
                        error_msg = $("ExportNotify").retrieve('error_msg', null);
                        $("ExportCheckMsg").store('cp_message', error_msg);
                    }
                    else if (registration_status == 'error')
                    {
                        registered = false;
                        error_msg = $("ExportNotify").retrieve('error_msg', null);
                        $("ExportCheckMsg").store('cp_message', error_msg);
                    }
                    else
                    {
                        registered = false;
                        $("ExportCheckMsg").store('cp_message', 'Invalid registration status ' + registration_status);
                    }
                }
                else if (typeof(registration_status) === 'boolean')
                {
                    $("ExportCheckMsg").store('cp_message', null);
                    $("ExportNotify").store('error_msg', null);
                    registered = registration_status;
                }
                else
                {
                    registered = false;
                }
            }
            else
            {
                // unless there is some error, eventually addresses will be set
                registered = null;
            }

            update_export_buttons();

            if (registered !== null)
            {
                update_export_buttons();

                // we have an answer (email-registration check is no longer pending)
                if (registered)
                {
                    // now we can check for pending request (on_demand - not interval)
                    var check_pending_fn = CHECK_FOR_PENDING_REQUEST(false);

                    // finally, if the user has a pending request, then we can set up the
                    // normal interval function, starting with EB state EB_STATE_CANCEL_ENABLED
                    var update_state_callback_fn = function()
                    {
                        var state = null;
                        var internal_fn = null;
                        var interval_fn_timer = null;
                        var interval_fn_timeout = null;

                        // we're done performing an on_demand for a pending request
                        $("ExportCheckButton").store({ 'on_demand' : false });

                        state = $("ExportButton").retrieve('state', EB_STATE_DISABLED);;

                        // set-up interval function only if there was in fact a pending request
                        // (which is indicated by the EB state)
                        if (state == EB_STATE_CANCEL_ENABLED)
                        {
                            interval_fn_timer = $("ExportButton").retrieve('interval', null);
                            if (interval_fn_timer === null)
                            {
                                internal_fn = CHECK_FOR_PENDING_REQUEST(true);
                                interval_fn_timer = setInterval(internal_fn, 1000);
                                $("ExportButton").store('interval', interval_fn_timer);
                            }

                            // do not allow the pending-request check to last forever (EB is in EB_STATE_CANCEL_ENABLED)
                            if (interval_fn_timeout !== null)
                            {
                                clearTimeout(interval_fn_timeout);
                            }

                            if (interval_fn_timer !== null)
                            {
                                interval_fn_timeout = setTimeout(function () { $("ExportButton").store('state', EB_STATE_TIMEOUT); set_eb_state_disabled(false);}, 10000);
                                $("ExportButton").store('interval_timeout', interval_fn_timeout);
                            }

                        }
                        else
                        {
                            // tell user to provide record-set specification; this is the normal
                            // behavior that the CP function performs
                        }

                        update_export_buttons();
                    };

                    check_pending_fn(update_state_callback_fn);
                }
                else
                {
                    // we're done - the user is not registered, or an error occurred, so we can't check for a pending request
                    $("ExportCheckButton").store({ 'on_demand' : false });
                    update_export_buttons();
                }
            }
        };

        update_export_buttons();
        startEmailCheck($("ExportNotify"), $("ExportRequestor"), $("ExportCheckMsg"), update_export_buttons, check_registered_callback_fn);
    }
}

// tester success
</script>
<script type="text/javascript">


// This function is called when the user clicks on the "Check Params for Export"
// button.
// A lot of the calls in this function are asynchronous.
function CheckExportButtonOnClickAction()
{
    var isOK = null;
    var record_count = null;
    var file_upload = null;


    record_count = $('ExportRecordSet').retrieve('count', null);
    file_upload = $('ExportRecordSet').retrieve('file_upload', false);

    // complete the SetProcessing part of this check
    // If there was an error in the processing options, then ExportProcessingOK is not true.
    // ProcessingOK() is synchronous.
    $("ExportCheckMsg").store({ 'cp_message' : null });

    // first deal with missing record-set specification; this is allowed if there is an email address provided
    if ($('ExportRecordSet').value.trim().length == 0 && $("ExportNotify").value.trim().length > 0)
    {
        // let's check for an existing request and allow the user to cancel it if one exists;
        check_for_cancel_enabled_shortcut();
        update_export_buttons();
        return 0; // there is no record-set, so the export parameters are incomplete
    }

    if (!file_upload)
    {
        if (record_count === null)
        {
            // deal with bad record-set specification
            $("ExportCheckMsg").store({ 'cp_message' : 'Still counting records; wait a second then retry' });
            update_export_buttons();
            return 0;
        }
    }

    // we've dealt with record-set specification (and possibly email address registration); now deal with the rest;
    // use is_ok_to_submit() to get an error message to display in the CP button message

    // update the UI and internal variables with values the user has chosen
    SetExportProtocol(1);

    // This is an asynchronous call, so we need to put the following "isOK" check into a
    // callback function. Return isOK == 0 since we do not know if it is OK to do an export
    // at this point.

    // this may or may not be an asynchronous call; $("ExportNotify").retrieve('valid', false) will either synchronously
    // return the acceptability of the notification address, or it will be updated when the asynchronous call completes;
    // if this is an asynchronous call, then $("ExportNotify").retrieve('valid', false) below will indicate that
    // the notification address is not acceptable, and the user will need to click on "Check Params for Export"
    // again
    if ($("ExportNotify").value.trim().length > 0)
    {
        update_export_buttons();
        startEmailCheck($("ExportNotify"), $("ExportRequestor"), $("ExportCheckMsg"), update_export_buttons, null);

        // note - ExportQueryOK is missing here
    }

    // notificationAddressOK may be in the process of being updated asynchronously, in which case notificationAddressOK == false
    isOK = is_ok_to_submit($("ExportCheckMsg"), 'cp_message');
    update_export_buttons();

    if (isOK)
    {
        var args = {};
        var check_pending_fn = null;

        if ($("ExportMethod").options[$("ExportMethod").selectedIndex].value == 'url_direct')
        {
            // if export method == 'url_quick':
            //   1. make sure all SUs are online (use results of jsoc_info call used when the record-set was selected)
            //   2. determine if we want to stream a tar file (if num fits files > 1) or fits file (if num fits files == 1)
            //   3. call exportCGI, which calls drms-export-to-stdout with the arguments determined in #2,
            //      opening a pipe to receive results
            //   4. stream an HTTP header back to the export user
            //   5. stream the file (tar or fits)
            if ($('ExportRecordSet').retrieve('count', null) > 1)
            {
                $("ExportCheckMsg").store({ 'cp_message' : 'url_direct can only be used if exporting a single FITS file' });
                isOK = false;
            }
            else
            {
                if ($('ExportRecordSet').retrieve('allSUsOnline', false))
                {
                    // call drms-export-to-stdout CGI
                    // the tar file will have the name of the file; there will be only one image file in the tar file
                    args.skiptar = 'true';
                    args.spec = $('ExportRecordSet').value;
                    args.filename = $('ExportFilenameFmt').value;
                    // dbhost added to args when submit button clicked

                    // no compression - url_direct is for streaming a single FITS file, uncompressed
                    args.compression = 'none';
                }
            }
        }
        else
        {
            args.op = $("ExportOpID").value;
            args.ds = $('ExportRecordSet').value;
            args.sizeratio = $("ExportSizeRatio").value;
            args.process = ExportProcessingArgs;
            args.requestor = $("ExportRequestor").value;
            args.notify = $("ExportNotify").value;
            args.method = $('ExportMethod').options[$('ExportMethod').selectedIndex].value.trim();
            args.filenamefmt = $('ExportFilenameFmt').value;
            args.format = "json";
            args.protocol = $('ExportProtocolHidden').value;
        }

        $('ExportRecordSet').store({ 'exportArgs' : args });
        $('ExportCheckMsg').store({ 'cp_message' : 'OK to submit export request' });
        update_export_buttons();
        ExportShowQuery();

        $("ExportButton").store('state', EB_STATE_ENABLED);
        update_export_buttons();

        // on-demand (check once, not in intervals); presents the user with an enabled 'submit'/'cancel' button
        // (it will be 'submit' because the call to check_for_cancel_enabled_shortcut() will have set the state
        // to 'cancel' if a request was pending and execution will never have gotten here).
        check_pending_fn = CHECK_FOR_PENDING_REQUEST(false);
        check_pending_fn();
    }
    else
    {

        $('ExportRecordSet').store({ 'exportArgs' : null });
    }

    if (isOK)
    {
        $("ExportCheckButton").store({ 'dirty' : false });
    }

    return isOK;
}

// called when user clicks on CPE button
function CheckExportParams()
{
    var addresses = $("ExportNotify").retrieve('addresses', {});
    var address = $("ExportNotify").value.trim();
    var requestor = $("ExportRequestor").value.trim();
    var snail_address = null; // no UI yet
    var registration_status = null;
    var address_registered = null;

    if (addresses !== null && address.length > 0 && Object.prototype.hasOwnProperty.call(addresses, address) && Object.prototype.hasOwnProperty.call(addresses[address], 'registration_status'))
    {
        registration_status = addresses[address].registration_status;
    }

    address_registered = (registration_status !== null && (typeof(registration_status) === 'boolean') && registration_status) ? true : false;

    if (address_registered)
    {
        // Up till now, SetProcessing() gets called whenever a processing option checkbox gets clicked.
        // But SetProcessing() does not get called when the user changes processing option values. Call it
        // now with -1 (which means the record-set spec has not changed).
        SetProcessing(-1, CheckExportButtonOnClickAction);  // asynchronous - can't do the rest until this asynchronous call completes.
    }
    else
    {
        // register the email address
        var registration_callback = function()
        {
            update_export_buttons();
            check_for_cancel_enabled_shortcut();
        };

        // we have to reset the registration status for this address; we previously checked its status which sets
        // the status to `false`; if we call register_address() without first resetting it, then we get the cached
        // value of `false` returned and the registration code is bypassed
        addresses[address].registration_status = null;
        register_address(address, requestor, snail_address, $("ExportNotify"), $("ExportCheckMsg"), update_export_buttons, registration_callback);
    }
}

function cancel_export()
{
    var address = $("ExportNotify").value.trim();
    var cancel_pending_fn = null;
    var internal_fn = null;
    var interval_fn_timer = null;
    var interval_fn_timeout = null;

    if (address !== null && address.length > 0)
    {
        $("StatusRequestID").value = ''; // remove export request ID from RequestID in lower section
        $("RequestIdPlace").innerHTML = ''; // remove export request ID from RequestID in upper section

        cancel_pending_fn = CANCEL_PENDING_REQUEST();

        // null -> do nothing on success; let interval function handle the resulting state changes
        cancel_pending_fn(null);

        interval_fn_timer = $("ExportButton").retrieve('interval', null);
        if (interval_fn_timer === null)
        {
            // start-up interval
            internal_fn = CHECK_FOR_PENDING_REQUEST(true);
            interval_fn_timer = setInterval(internal_fn, 1000);
            $("ExportButton").store('interval', interval_fn_timer);

            // do not allow the pending-request check to last forever (EB is in EB_STATE_CANCEL)
            interval_fn_timeout = setTimeout(function () { $("ExportButton").store('state', EB_STATE_TIMEOUT); set_eb_state_disabled(false);}, 30000);
            $("ExportButton").store('interval_timeout', interval_fn_timeout);
        }
    }
}

// tester succeeded
</script>
<script type="text/javascript">

// this is the code executed when the user clicks on the ExportButton button
function ExportButtonOnClickAction()
{
    // if the use was able to click this button, then it was OK to submit an export request
    var EB_state = $('ExportButton').retrieve('state', EB_STATE_DISABLED);
    var internal_fn = null;
    var interval_fn_timer = null;
    var interval_fn_timeout = null;

    if (EB_state === EB_STATE_SUBMIT_ENABLED)
    {
        EB_state = EB_STATE_SUBMIT;
        $('ExportButton').store('state', EB_state);
        // update_export_buttons();
        update_request_section_ui(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);

        // call jsoc_fetch now
    }
    else if (EB_state === EB_STATE_CANCEL_ENABLED)
    {
        EB_state = EB_STATE_CANCEL;
        $('ExportButton').store('state', EB_state);
        update_export_buttons();

        // start up interval function (so we know when export request has been completely processed) 
        interval_fn_timer = $("ExportButton").retrieve('interval', null);
        if (interval_fn_timer === null)
        {
            // start-up interval
            internal_fn = CHECK_FOR_PENDING_REQUEST(true);
            interval_fn_timer = setInterval(internal_fn, 1000);
            $('ExportButton').store('interval', interval_fn_timer);
        }

        // set or reset timeout timer
        interval_fn_timeout = $('ExportButton').retrieve('interval_timeout', null);
        if (interval_fn_timeout !== null)
        {
            // do not allow the pending-request check to last forever (EB is in EB_STATE_CANCEL); next state is EB_STATE_CANCELED
            // which should happen relatively quickly
              clearTimeout(interval_fn_timeout);
        }

        if (interval_fn_timer !== null)
        {
            interval_fn_timeout = setTimeout(function () { $('ExportButton').store('state', EB_STATE_TIMEOUT); set_eb_state_disabled(false);}, 15000);
            $('ExportButton').store('interval_timeout', interval_fn_timeout);
        }

        // this state transition is handled by calling manage-request, not jsoc_fetch (the code below
        // is all about jsoc_fetch); run this:
        // manage-request.py address=<foo>@<bar> operation=cancel
        // if this call fails for any reason, no worries, the export simply is not canceled, and
        // we get stuck in the EB_STATE_CANCEL state until it completes by natural causes
        cancel_export();

        // do not continue onto calling jsoc_fetch
        return;
    }
    else if (EB_state === EB_STATE_CANCELED)
    {
        set_eb_state_disabled(false);

        // do not continue onto calling jsoc_fetch
        return;
    }
    else if (EB_state === EB_STATE_PATH)
    {
        // need to use the PENDING_REQUEST_STATUS_PATH endpoint and ProcessRequestStatusResponse() 
        // as the onSuccess() - we update just the upper/request section's status ui
        $('ExportRecordSet').store({ 'exportArgs' : { "op" : "exp_status", "requestid" : $('RequestIdPlace').innerHTML } });
    }
    else
    {
        $('ExportButton').store({ "error" : true });
        $('ExportButtonMsg').store({ "message" : "unexpected-export button state" });
        update_request_section_ui(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);

        set_eb_state_disabled(true);

        // do not continue onto calling jsoc_fetch
        return;
    }

    if ($('ExportMethod').options[$('ExportMethod').selectedIndex].value === EXP_METH_STREAMED)
    {
        // no need to process a full export request via jsoc_fetch
        if ($('ExportRecordSet').retrieve('count', null) > 1)
        {
            $("ExportLocation").innerHTML =  '<b>Multiple files were requested - use the url_direct export method to request a single file only.<\/b><p>';
        }
        else
        {
            CreateExportDownloadLink(null, null);
        }

        return;
    }

    var doFetchReqFn = function()
    {
        var export_app_arguments = null;
        var options = null;
        var origin = null;
        var db_host = null;
        var export_endpoint = null;
        var export_arguments = null;
        var export_endpoint_arguments = null;
        var on_failure = null;

        var access = null;
        var export_package = null;
        var file_format = null;
        var file_format_args = null;
        var method = null;

        origin = ExportOrigin(null);

        if (origin[0] == 'extServer')
        {
            db_host = EXTERNAL_SERVER;
        }
        else
        {
            db_host = INTERNAL_SERVER;
        }

        // arguments from URL form
        export_arguments = $('ExportRecordSet').retrieve('exportArgs', null);
        method = $('ExportMethod').options[$('ExportMethod').selectedIndex].value.trim();

        // the export method dictates the type of export (in the flask app);
        //   'url_quick' ==> mini
        //   'url_direct' ==> streamed (handled in a different part of the js)
        //    everything else ==> premium
        if (method.toLowerCase() == EXP_METH_QUICK)
        {
            export_endpoint = MINI_EXPORT_REQUEST_PATH;

            export_endpoint_arguments = { "specification" : export_arguments.ds, "file_name_format" : export_arguments.filenamefmt, "number_records" : RecordLimit };
        }
        else if (method.toLowerCase() == EXP_METH_STREAMED)
        {
            // error
            $('ExportButtonMsg').innerHTML = "streamed exports are handled with by a different button";
            $('ExportButton').value = 'FAILURE ...';
            $('ExportButton').style.backgroundColor = colorDarkPink;
            set_eb_state_disabled(true);
        }
        else
        {
            export_endpoint = PREMIUM_EXPORT_REQUEST_PATH;

            if ($('ExportMethod').options[$('ExportMethod').selectedIndex].value.trim().toLowerCase().indexOf('ftp') == 0)
            {
                access = 'ftp';
            }
            else
            {
                access = 'http';
            }

            export_package = {};
            if ($('ExportMethod').options[$('ExportMethod').selectedIndex].value.trim().toLowerCase().indexOf('tar') != -1)
            {
                export_package = { "type" : "tar" };
            }
            else
            {
                export_package = { "type" : null };
            }

            argument_argument_obj = unserialize_arguments(export_arguments.protocol);
            argument_namespace = Object.keys(argument_argument_obj)[0];

            if (Object.keys(argument_argument_obj[argument_namespace]).length > 0)
            {
                file_format = argument_namespace.toLowerCase();

                // file_format_args are extra arguments for the protocol types of JPEG, MPEG, and MP4
                // extra args exist - for some reason the saved string != the displayed string
                if (file_format != 'jpg' && file_format != 'mpg' && file_format != 'mp4')
                {
                    // error
                }
                else
                {
                    file_format_args = argument_argument_obj[argument_namespace];
                }
            }
            else
            {
                file_format = export_arguments.protocol.toLowerCase();
            }

            // no longer a need to provide size ratio to back-end; jsoc_fetch will calculate it using the processing
            // steps as input
            export_endpoint_arguments = { "access" : access, "package" : export_package, "specification" : export_arguments.ds, "file-format" : file_format, "file-format-args" : file_format_args, "file-name-format" : export_arguments.filenamefmt, "number-records" : RecordLimit, "processing" : ProcessingObj };
        }

        if (export_endpoint !== null)
        {
            export_app_arguments = { "address" : export_arguments.notify, "db-host" : db_host, "export-arguments" : JSON.stringify(export_endpoint_arguments), "requestor" : export_arguments.requestor };

            options =
            {
                method: 'post',
                onSuccess: function(response)
                {
                    var ir_response_obj = response.responseJSON;

                    $('ExportButton').store({ "ajax-state" : "post-click" });

                    if (ir_response_obj !== null)
                    {
                        ProcessExportResponse(ir_response_obj);
                    }
                },
                onFailure: function(response)
                {
                    var error_message = 'failure initiating export: ' + JSON.stringify(response.responseJSON.error_message);

                    $('ExportButton').store({ "ajax-state" : "post-click" });

                    ProcessExportResponse({ "error_message" : error_message });
                },
                on428: function(response)
                {
                    var error_message = 'invalid arguments to ' + export_endpoint + ' endpoint: '+ JSON.stringify(response.responseJSON.error_message);

                    $('ExportButton').store({ "ajax-state" : "post-click" });
                    
                    ProcessExportResponse({ "error_message" : error_message });
                },
                onComplete: function(response)
                {
                    $('ExportButton').store({ "ajax-state" : "post-click" });
                }
            };

            $('ExportButton').store({ "ajax-state" : "ajax-running" });
            update_request_section_ui(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);

            options['postBody'] = JSON.stringify(export_app_arguments);
            options['contentType'] = 'application/json';

            new Ajax.Request(window.location.origin + export_endpoint, options);
        }
    }

    // Just call the function. It will determine if it should use the internal or external version of the CGI.
    doFetchReqFn();
}

// tester success
</script>
<script type="text/javascript">

// the name of the function in the html; this simply calls a function with a function name that denotes it is called
// when a button gets clicked
function GetExport()
{
    return ExportButtonOnClickAction();
}

function ExportOrigin(requestID)
{
    var retVal = [];
    var hostname = location.hostname.toLowerCase();
    var port = location.port; // string

    if ((hostname === EXTERNAL_WEBSERVER || hostname === EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN) && port === EXTERNAL_WEBSERVER_PORT)
    {
        retVal.push('extServer');
    }
    else if ((hostname === INTERNAL_WEBSERVER || hostname === INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN) && port === INTERNAL_WEBSERVER_PORT)
    {
        retVal.push('intServer');
    }
    else
    {
        retVal.push('invalidServer');
    }

    if (requestID)
    {
        if (retVal[0] == 'invalidServer')
        {
            // can't determine if request ID is valid or not
            retVal.push('invalidRequestID');
        }
        else
        {
            if ($("StatusRequestID").value.search("_IN") != -1)
            {
                // an internal request ID
                if (retVal[0] == 'extServer' && $("StatusRequestID").value.search("_X") == -1 ||
                    retVal[0] == 'intServer' && $("StatusRequestID").value.search("_X") != -1)
                {
                    // the external server can process internal request IDs, but only if there is an '_X_IN' in the ID
                    retVal.push('invalidRequestID');
                }
                else
                {
                    retVal.push('intRequestID');
                }
            }
            else
            {
                // an external request ID
                if (retVal[0] == 'intServer')
                {
                    // the internal server cannot process external request IDs
                    retVal.push('invalidRequestID');
                }
                else
                {
                    retVal.push('extRequestID');
                }
            }
        }
    }

    return retVal;
}
// tester success
</script>
<script type="text/javascript">


function GetReExport()
{
    // disabled at the moment - the ReExportDiv UI is disabled
    var export_app_arguments = null;
    var options = null;
    var origin = null;
    var db_host = null;
    var export_endpoint = null;
    var export_arguments = null;
    var export_endpoint_arguments = null;

    origin = ExportOrigin(null);

    if (origin[0] == 'extServer')
    {
        db_host = EXTERNAL_SERVER;
    }
    else
    {
        db_host = INTERNAL_SERVER;
    }

    if (origin[1] == 'invalidRequestID')
    {
        if (origin[0] == 'extServer')
        {
            alert('The request ID ' +  $("StatusRequestID").value + ' is accessible from http://' + INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN +' only. Please use a request ID generated by a request made on the http://' + EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN +' webserver (which has a format of JSOC_YYYYMMDD_NNN or JSOC_YYYYMMDD_NNN_X_IN).');
            return;
        }
        else if (origin[0] == 'intServer')
        {
            alert('The request ID ' +  $("StatusRequestID").value + ' is accessible from http://' + EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + ' only. Please use a request ID generated by a request made on the http://' + INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + ' webserver (which has a format of JSOC_YYYYMMDD_NNN_IN).');
            return;
        }
        else
        {
            return;
        }
    }

    // endpoint is not implemented; the original code is in the exp_repeat branch of jsoc_fetch.c
    export_arguments = null;

    Cookie.setData("state", 2);

    $("ExportStatus").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("ExportLocation").innerHTML = "";
    $("ReExportButtonMsg").innerHTML = "Export request submitted, please wait...";
    $("ReExportButton").value = "Processing ...";
    $("ReExportButton").style.backgroundColor = colorPink;

    options =
    {
        method: 'post',
        onSuccess: function(response)
        {
            var ir_response_obj = response.responseJSON;

            if (ir_response_obj !== null)
            {
                ProcessExportResponse(ir_response_obj);
            }
        },
        onFailure: function(response)
        {
            var error_message = "failuring re-exporting data: " + JSON.stringify(response.responseJSON.error_message);

            ProcessExportResponse({ "error_message" : error_message });
        },
        on428: function(response)
        {
            var error_message = "invalid arguments to re-export endpoint: " + JSON.stringify(response.responseJSON.error_message);

            ProcessExportResponse({ "error_message" : error_message });
        },
        onComplete: function(response)
        {
        }
    };

    options['postBody'] = JSON.stringify(export_app_arguments);
    options['contentType'] = 'application/json';

    new Ajax.Request(window.location.origin + RE_EXPORT_REQUEST_PATH, options);
}

// tester success
</script>
<script type="text/javascript">


function ProcessExportResponse(ir_response_obj)
{
    var endpoint_status = null;
    var endpoint_status_wordy = null;
    var request_id = null;
    var payload_size = null;    
    var seconds_elapsed = null;
    var sums_directory = null;
    var number_records = null;
    var number_files = null;
    var access = null;
    var data_package = null;
    var file_format = null;
    var keywords_file = null;
    var export_data = null;
    var contact = null;
    var error_message = null;
    var interval_fn_timer = null;
    var interval_fn_timeout = null;

    // state gets set to 0 before leaving this function, so this statement has no effect
    Cookie.setData("state", 3);

    if (ir_response_obj !== null)
    {
        alert('got ir obj beg ' + JSON.stringify(ir_response_obj));
        endpoint_status = ir_response_obj.drms_export_status;
        endpoint_status_wordy = ir_response_obj.drms_export_status_description;

        if (ir_response_obj.hasOwnProperty('request_id'))
        {

            request_id = ir_response_obj.request_id;
        }

        if (ir_response_obj.hasOwnProperty('mb_exported') && ir_response_obj.mb_exported !== null)
        {
            payload_size = ir_response_obj.mb_exported.toString();
        }

        if (ir_response_obj.hasOwnProperty('wait') && ir_response_obj.wait !== null && ir_response_obj.wait.length > 0)
        {
            seconds_elapsed = ir_response_obj.wait.toString();
        }

        if (ir_response_obj.hasOwnProperty('sums_directory'))
        {
            sums_directory = ir_response_obj.sums_directory;
        }

        if (ir_response_obj.hasOwnProperty('number_records') && ir_response_obj.number_records !== null)
        {
            number_records = ir_response_obj.number_records.toString();
        }

        if (ir_response_obj.hasOwnProperty('number_files') && ir_response_obj.number_files !== null)
        {
            number_files = ir_response_obj.number_files.toString();
        }

        if (ir_response_obj.hasOwnProperty('access'))
        {
            access = ir_response_obj.access;
        }

        if (ir_response_obj.hasOwnProperty('package'))
        {
            data_package = ir_response_obj.package;
        }

        if (ir_response_obj.hasOwnProperty('file_format'))
        {
            file_format = ir_response_obj.file_format;
        }

        if (ir_response_obj.hasOwnProperty('keywords_file'))
        {
            keywords_file = ir_response_obj.keywords_file;
        }

        if (ir_response_obj.hasOwnProperty('export_data'))
        {
            export_data = ir_response_obj.export_data;
        }

        if (ir_response_obj.hasOwnProperty('error_message'))
        {
            error_message = 'failure initiating export: ' + JSON.stringify(ir_response_obj.error_message);
        }

        if (ir_response_obj.hasOwnProperty('contact'))
        {
            contact = ir_response_obj.contact;
        }
    }
    else
    {
        error_message = 'failure initiating export';
        endpoint_status = 'ErrorCode.REQUEST_FATAL_ERROR';
    }

    if (endpoint_status === 'ErrorCode.REQUEST_TOO_MANY')
    {
        update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_reccords, number_files, access, data_package, file_format, keywords_file, export_data, contact);

        set_eb_state_disabled(true);
        Cookie.setData('state', 0);
    }
    else if (endpoint_status == 'StatusCode.REQUEST_NOT_QUEUED')
    {
        // request has not been inserted into jsoc.export_new - cannot happen when clicking export submit since
        // that click will ensure the export is inserted into jsoc.export_new, or there will be an export failure
        error_message = 'unexpected endpoint status ' + endpoint_status;
        endpoint_status = 'ErrorCode.REQUEST_FATAL_ERROR';

        set_eb_state_disabled(true);
        Cookie.setData('state', 0);
    }
    else if (endpoint_status == 'StatusCode.REQUEST_NOT_ONLINE')
    {
        // can only happen for re-export
        update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_reccords, number_files, access, data_package, file_format, keywords_file, export_data, contact); 

        set_eb_state_disabled(true);
        Cookie.setData('state', 0);
    }
    else if (endpoint_status == 'StatusCode.REQUEST_FATAL_ERROR')
    {
        update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_reccords, number_files, access, data_package, file_format, keywords_file, export_data, contact); 

        set_eb_state_disabled(true);
        Cookie.setData('state', 0);
    }
    else if (endpoint_status == 'StatusCode.REQUEST_TOO_LARGE')
    {
        update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_reccords, number_files, access, data_package, file_format, keywords_file, export_data, contact); 

        set_eb_state_disabled(true);
        Cookie.setData('state', 0);
    }
    else if (endpoint_status === 'StatusCode.REQUEST_QUEUED' || endpoint_status === 'StatusCode.REQUEST_QUEUED_DEBUG' || endpoint_status === 'StatusCode.REQUEST_PROCESSING')
    {
        update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);

        // fill in the request id in $('StatusRequestID') - passing in a request ID will effect this
        update_status_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);

        // we now know that the JSOC has seen the export request; before jsoc_fetch returns, it inserts a row
        // into export_pending_reqs, which means the user has a pending request; jsoc_fetch sets status to 2
        // when starting a new request (not 1, which is what the status check will return)

        // it is safe to change state to cancel_enabled
        if ($('ExportButton').retrieve('state', EB_STATE_DISABLED) === EB_STATE_SUBMIT)
        {
            $('ExportButton').store('state', EB_STATE_CANCEL_ENABLED);
            $('ExportButton').store({ "ajax-state" : "pre-click" });
            update_export_buttons();

            interval_fn_timer = $('ExportButton').retrieve('interval', null);
            if (interval_fn_timer === null)
            {
                // start-up interval
                internal_fn = CHECK_FOR_PENDING_REQUEST(true);
                interval_fn_timer = setInterval(internal_fn, 1000);
                $('ExportButton').store('interval', interval_fn_timer);
            }

            // do not allow the pending-request check to last forever (EB is in EB_STATE_CANCEL_ENABLED); export processing
            // could take a while so set a 1 day timeout (86400000)
            interval_fn_timeout = $("ExportButton").retrieve('interval_timeout', null);
            if (interval_fn_timeout !== null)
            {
                clearTimeout(interval_fn_timeout);
            }

            if (interval_fn_timer !== null)
            {
                interval_fn_timeout = setTimeout(function () { $('ExportButton').store('state', EB_STATE_TIMEOUT); set_eb_state_disabled(false);}, 86400000);
                $('ExportButton').store('interval_timeout', interval_fn_timeout);
            }
        }
        else
        {
            // error
            alert('unexpected eb state');
        }

        Cookie.setData('requestid', request_id);

        if ($('FileUploadCheckbox').checked)
        {
            $('FileUploadInfo').innerHTML = 'file upload done; ' + number_records + ' records requested';
        }

        // file upload processing occuring asynchronously; file_upload_on_complete() will be a no-op if no file-upload is occurring
        file_upload_on_complete();
    }
    else if (endpoint_status === 'StatusCode.REQUEST_COMPLETE')
    {
        // implies url_quick format and all online as-is; there should be no request ID
        update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_reccords, number_files, access, data_package, file_format, keywords_file, export_data, contact);

        Cookie.setData('state', 0);
        Cookie.setData('requestid', '');

        // the user has clicked on the "get path" EB button; we need to changed back to disabled state
        if ($('ExportButton').retrieve('state', EB_STATE_DISABLED) == EB_STATE_PATH)
        {
            // before we change the state to disabled, we need to ensure that the interval function is no longer running
            // (due to a race condition, it may still be running (interval sets to EB_STATE_PATH, then this code here
            // runs, which changes state to EB_STATE_DISABLED before interval function has a chance to clear itself))
            set_eb_state_disabled(false);
        }
        else
        {
            // error
            alert('unexpected eb state');
            set_eb_state_disabled(true);
        }
        
        if ($('FileUploadCheckbox').checked)
        {
            $('FileUploadInfo').innerHTML = 'file upload done; ' + number_records + ' records requested';
        }

        // file_upload_on_complete() will be a no-op if no file-upload is occurring
        file_upload_on_complete();
    }
    else if (endpoint_status.search(/errorcode/i) == 0)
    {
        // by setting `error`, this will cause update_export_buttons() to display FAILURE... for the export button
        error_message = 'unexpected endpoint error ' + endpoint_status;
        endpoint_status = 'ErrorCode.REQUEST_FATAL_ERROR';

        update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_reccords, number_files, access, data_package, file_format, keywords_file, export_data, contact);

        set_eb_state_disabled(true);
        Cookie.setData('state', 0);
    }
    else
    {
        // unknown status
        error_message = 'unexpected endpoint status ' + endpoint_status;
        endpoint_status = 'ErrorCode.REQUEST_FATAL_ERROR';

        update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_reccords, number_files, access, data_package, file_format, keywords_file, export_data, contact); 
   
        set_eb_state_disabled(true); 
        Cookie.setData('state', 0);
    }
}
// tester success
</script>
<script type="text/javascript">


function ClearStatus()
{
    update_status_section_ui(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
}

</script>
<script type="text/javascript">

// update the UI of the upper/request sectioni
// cannot be the case that both buttons have been clicked simultaneously (they would stomp on each other)
// both button clicks affect all UI elements
function update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keyword_fiile, export_data, contact)
{
    // update the UI at the bottom of the uppper/request section; there is a table with three columns (the first column is a header - RequestID, Status, Data Location):
    // first column:
    //   $('DataLocation') - the header is eitheer 'Data Location' (for non-streamed exports) or 'Download' (for streamed exports)
    // second column:
    //   $('RequestIdPlace') - the requestID for an export that was initiated successfully
    //   $('ExportStatus') - information like if the export is being processed, data are ready for download, the size of data exported, error 
    //   messages if the data could not be exported
    //  $('ExportLocation') - a table with URL paths for data
    // third column:
    //   $('RequestIDDesc') - instructions how to get export status updates (in the lower/status section)
    //   none - only two columns for the 'Status' row
    //   none - only two columns for the 'Data Location' row
    var reset = null;
    var export_button_click = null;
    var export_button_error = null;
    var status_button_click = null;
    var status_button_error = null;
    var request_id_resolved = null;
    var request_id_instructions = null;
    var export_status = null;
    var url_table = null;

    reset = $('ExportButton').retrieve('reset', false);

    if ($('ExportButton').retrieve('ajax-state', 'pre-click') !== 'pre-click')
    {
        export_button_click = true;
        if (endpoint_status !== null && endpoint_status.search(/errorcode/i) == 0)
        {
            export_button_error = true;
        }
        else
        {
            export_button_error = false;
        }
    }

    if ($('StatusButton').retrieve('ajax-state', 'pre-click') !== 'pre-click')
    {
        status_button_click = true;

        if (endpoint_status !== null && endpoint_status.search(/errorcode/i) == 0)
        {
            status_button_error = true;
        }
        else
        {
            status_button_error = false;
        }
    }
    else
    {
        alert('status button click false');
        status_button_click = false;
    }

    if (reset)
    {
        $('DataLocation').innerHTML = 'Data Location';
    }
    else
    {
        if ($('ExportMethod').options[$('ExportMethod').selectedIndex].value.trim().toLowerCase() === EXP_METH_STREAMED)
        {
            $('DataLocation').innerHTML = 'Download';
        }
        else
        {
            $('DataLocation').innerHTML = 'Data Location';
        }
    }

    if (reset)
    {
        request_id_resolved = '';
        $('RequestIdPlace').style.backgroundColor = colorYellow;
        $('RequestIdPlace').disabled = true;
    }
    else
    {
        if (request_id !== null && request_id.length > 0)
        {
            request_id_resolved = request_id;
        }
        else if (endpoint_status === 'StatusCode.REQUEST_COMPLETE')
        {
            // no request id plus a complete request means that the request was satisfied without creating an entry in jsoc.export; this happens
            // when method is 'url-quick'; it does NOT happen under any other circumstance, not even if format is 'as-is'
            request_id_resolved = 'N/A';
        }
        else
        {
            request_id_resolved = '';
        }
    }

    $('RequestIdPlace').innerHTML = request_id_resolved;

    if (reset)
    {
        request_id_instructions = '';
    }
    else
    {
        // since both an export click and a status click modify $('RequestIDDesc'), we do not need to differentiate
        if (request_id_resolved === request_id && (endpoint_status === 'StatusCode.REQUEST_COMPLETE' || endpoint_status === 'StatusCode.REQUEST_PROCESSING' || endpoint_status === 'StatusCode.REQUEST_QUEUED' || endpoint_status === 'StatusCode.REQUEST_QUEUED_DEBUG'))
        {
            request_id_instructions = HTML_REQUESTID_DESC;
        }

        // either ajax is running, or pre-click
        if (request_id_resolved === null || request_id_resolved.length == 0)
        {
            if ((export_button_click && $('ExportButton').retrieve('ajax-state', 'pre-click') === 'ajax-running') || (status_button_click && $('StatusButton').retrieve('ajax-state', 'pre-click') === 'ajax-running'))
            {
                request_id_instructions = 'obtaining request ID';
            }
            else
            {
                if ((export_button_click && export_button_error) || (status_button_click && status_button_error))
                {
                    request_id_instructions = 'error obtaining request ID';
                }
                else
                {
                   request_id_instructions = '';
                }
            }
        }
    }

    $('RequestIDDesc').innerHTML = request_id_instructions;

    if (reset)
    {
        export_status = '';
        $('ExportStatus').style.backgroundColor = colorYellow;
        $('ExportStatus').disabled = true;
    }
    else
    {
        // since both an export click and a status click modify $('ExportStatus'), we do not need to differentiate; if ajax is still
        // running, then much of the following will be skipped over (export_status === null)
        export_status = $('ExportStatus').retrieve('message', null);
        if (export_status === null || export_status.length == 0)
        {
            if (endpoint_status === 'StatusCode.REQUEST_COMPLETE')
            {
                export_status = 'complete, size ' + payload_size + ' MB';
            }
            else if (endpoint_status === 'StatusCode.REQUEST_PROCESSING' || endpoint_status === 'StatusCode.REQUEST_QUEUED' || endpoint_status === 'StatusCode.REQUEST_QUEUED_DEBUG' || endpoint_status === 'StatusCode.REQUEST_NOT_QUEUED')
            {
                alert('should be here, setting exportstatus string ');
                if (seconds_elapsed !== null && seconds_elapsed.length > 0)
                {
                    export_status = 'in progress; payload size, ' + payload_size + ' MB; seconds since request initiated, ' + seconds_elapsed;
                }
                else
                {
                    export_status = 'in progress; payload size, ' + payload_size + ' MB';
                }
            }
            else if (endpoint_status === 'ErrorCode.REQUEST_TOO_LARGE')
            {
                export_status = 'denied (payload too large); size, ' + payload_size + ' MB, contact, ' + contact;
            }
            else if (endpoint_status === 'ErrorCode.REQUEST_FATAL_ERROR')
            {
                if (error_message !== null && error_message.length > 0)
                {
                    export_status =  'failed; ' + error_message;
                }
            }
            else if (endpoint_status === 'ErrorCode.REQUEST_NOT_ONLINE')
            {
                export_status = 'timed out; export no longer online';
            }
            else if (endpoint_status === 'ErrorCode.REQUEST_TOO_MANY')
            {
                if (error_message !== null && error_message.length > 0)
                {
                    export_status =  'denied (too many requests); ' + error_message;
                }
            }
        }

        if (export_status === null || export_status.length == 0)
        {
            export_status = endpoint_status_wordy;
        }

        // either ajax is running, or pre-click
        if (export_status === null || export_status.length == 0)
        {
            if ((export_button_click && $('ExportButton').retrieve('ajax-state', 'pre-click') === 'ajax-running') || (status_button_click && $('StatusButton').retrieve('ajax-state', 'pre-click') === 'ajax-running'))
            {
                export_status = 'obtaining status';
            }
            else
            {
                if ((export_button_click && export_button_error) || (status_button_click && status_button_error))
                {
                    export_status = 'error obtaining status';
                }
                else
                {
                    export_status = '';
                }
            }
        }
    }

    $('ExportStatus').innerHTML = export_status;

    // only an export button click should create the url table in the upper/request section
    if (reset)
    {
        $('ExportLocation').innerHTML = '';
        $('ExportLocation').style.backgroundColor = colorYellow;
        $('ExportLocation').disabled = true;
    }
    else
    {
        if (export_button_click)
        {
            if (export_data !== null)
            {
                $('ExportLocation').innerHTML = CreateDataTable(export_data, data_package) + '<br>';
            }
            else
            {
                url_table_element = '';
                $('ExportLocation').innerHTML = '';
            }
        }
    }

    // export buttons
    if (endpoint_status === 'StatusCode.REQUEST_COMPLETE')
    {
        if (export_button_click)
        {
            $('ExportButton').store({ "error" : false, "label" : "complete" });
            $('ExportButtonMsg').store({ "message" : null });
        }
    }
    else if (endpoint_status === 'StatusCode.REQUEST_PROCESSING' || endpoint_status === 'StatusCode.REQUEST_QUEUED' || endpoint_status === 'StatusCode.REQUEST_QUEUED_DEBUG')
    {
        if (export_button_click)
        {
            $('ExportButton').store({ "error" : false, "label" : "wait..." });
            $('ExportButtonMsg').store({ "message" : null });
        }
    }
    else if (endpoint_status === 'ErrorCode.REQUEST_TOO_LARGE')
    {
        if (export_button_click)
        {
            $('ExportButton').store({ "error" : true, "label" : "too large" });
            $('ExportButtonMsg').store({ "message" : "JSOC intervention required (" + endpoint_status_wordy + "); payload size = " + payload_size + " MB, " + number_files + " files generated, contact: " + contact });
        }
    }
    else if (endpoint_status === 'ErrorCode.REQUEST_FATAL_ERROR')
    {
        if (export_button_click)
        {
            $('ExportButton').store({ "error" : true, "label" : "bad export" });
            $('ExportButtonMsg').store({ "message" : error_message });
        }
    }
    else if (endpoint_status === 'ErrorCode.REQUEST_NOT_ONLINE')
    {
        $('ExportButton').store({ "error" : true, "label" : "timeout" });
        $('ExportButtonMsg').store({ "message" : error_message });
    }
    else if (endpoint_status === 'ErrorCode.REQUEST_TOO_MANY')
    {
        if (export_button_click)
        {
            $('ExportButton').store({ "error" : true, "label" : "too many" });
            $('ExportButtonMsg').store({ "message" : error_message });

        }
    }
    
    update_export_buttons();

    if (reset)
    {
        $('ExportButton').store({ "reset" : false });
    }
}

</script>
<script type="text/javascript">

// update the UI of the lower/status section
// can be called from after export button click (when the user clicks 'get path')
function update_status_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_reccords, number_files, access, data_package, file_format, keywords_file, export_data, contact)
{
    // the lower status section is a table with 4 columns, but there is no real table structure in the display; there 
    // are essentially 5 rows, followed by a table of export urls:
    //   row 1 (4 columns) - header 'RequestID' [const], request ID text box, description (This is the ID tag for your export request) [const], 
    //     status string (success, export status error code string, blank)
    //   row 2 (3 columns) - request button, instructions for button (please only click once for status request), another random description
    //     (List formats are index.html, index.json, and index.txt; export script file is JSOC_20211103_932.drmsrun) - when rendered, this
    //     text appears to be in row 3 and looks like a third column
    //   row 3 (2 columns) - clear-request button, instructions for button (clear old status request ID)
    //   row 4 (2 columns) - header 'Status', status string (data ready, size = 14 MB)
    //   row 5 (2 columns) - header 'Data Location', base url
    //   row 6 (2 columns) - header 'Tar File Location', url [can be hidden]
    //   row 7 (2 columns) - header 'Keyword File Location', url [can be hidden]
    //   row 8 (n x 3 table) - file number, record, url
    var reset = null;
    var export_button_click = null;
    var export_button_error = null;
    var status_button_click = null;
    var status_button_error = null;
    var request_id_resolved = null;
    var link_element = null;

    reset = $('StatusButton').retrieve('reset', false);

    if ($('ExportButton').retrieve('ajax-state', 'pre-click') !== 'pre-click')
    {
        export_button_click = true;
        export_button_error = $('ExportButton').retrieve('error', false);
    }
    else
    {
        export_button_click = false;
    }

    if ($('StatusButton').retrieve('ajax-state', 'pre-click') !== 'pre-click')
    {
        status_button_click = true;
        status_button_error = $('StatusButton').retrieve('error', false);
    }
    else
    {
        status_button_click = false;
    }

    // affected by both export and status button clicks
    // row 1, col 2
    if (reset)
    {
        request_id_resolved = '';
    }
    else
    {
        if (request_id !== null && request_id.length > 0)
        {
            request_id_resolved = request_id;
        }
        else if (endpoint_status === 'StatusCode.REQUEST_COMPLETE')
        {
            // no request id plus a complete request means that the request was satisfied without creating an entry in jsoc.export; this happens
            // when method is 'url-quick'; it does NOT happen under any other circumstance, not even if format is 'as-is'
            request_id_resolved = 'N/A';
        }
        else
        {
            request_id_resolved = '';
        }
    }

    $('StatusRequestID').value = request_id_resolved;
    $('StatusRequestID').style.backgroundColor = colorYellow;

    // row 1, col 4 - affected by status button click only
    if (reset)
    {
        $('StatusValue').innerHTML = '';
    }
    else
    {
        if (status_button_click)
        {
            message = $('StatusValue').retrieve('message', null);
            if (message === null || message.length == 0)
            {
                if (endpoint_status !== null)
                {
                    message = endpoint_status;
                }
            }

            if (message === null || message.length == 0)
            {
                if (status_button_error)
                {
                    message = 'error';
                }
                else
                {
                    message = '';
                }
            }

            $('StatusValue').innerHTML = message;
        }
    }

    // row 2, col 1 (button label, color) - affected by status button click only
    if (reset)
    {
        $('StatusButton').value = 'get status';
        $('StatusButton').style.backgroundColor = colorPreset;
    }
    else
    {    
        if (status_button_click)
        {
            button_label = $('StatusButton').retrieve('label', null);
            button_color = $('StatusButton').retrieve('color', null);

            if (button_label === null || button_label.length == 0)
            {
                // depends on the disposition of the response
                if (endpoint_status === 'StatusCode.REQUEST_PROCESSING' || endpoint_status === 'StatusCode.REQUEST_QUEUED' || endpoint_status === 'StatusCode.REQUEST_QUEUED_DEBUG')
                {
                    button_label = 'get status';
                }
                else if (endpoint_status === 'ErrorCode.REQUEST_FATAL_ERROR')
                {
                    button_label = 'FAILURE...';
                }
                else if (endpoint_status === 'ErrorCoce.REQUEST_NOT_ONLINE')
                {
                    button_label = 'timed out';
                }
            }

            if (button_label === null || button_label.length == 0)
            {
                if ($('StatusButton').retrieve('ajax-state', 'pre-click') === 'ajax-running')
                {
                    button_label = 'wait...';
                }
                else
                {
                    if ($('StatusButton').retrieve('error', false))
                    {
                        button_label = 'FAILURE...';
                    }
                    else
                    {
                        button_label = 'get status';
                    }
                }
            }

            if (button_color === null || button_color.length == 0)
            {
                if ($('StatusButton').retrieve('ajax-state', 'pre-click') === 'ajax-running')
                {
                    button_color = colorPink;
                }
                else
                {
                    if ($('StatusButton').retrieve('error', false))
                    {
                        button_color = colorDarkPink;
                    }
                    else
                    {
                        button_color = colorPreset;
                    }
                }
            }

            $('StatusButton').value = button_label;
            $('StatusButton').style.backgroundColor = button_color;
        }
    }

    if ($('ExportNotify').retrieve('valid', false) && $('StatusRequestID').value.trim().length > 0)
    {
        // disable status button
        $('StatusButton').disabled = false;
    }
    else
    {
        // enable status button
        $('StatusButton').disabled = true;
    }

    // row 2, col 2 (message to the right of button) - affected by both export and status button clicks
    if (reset)
    {
        if ($('ExportNotify').retrieve('valid', false) && $('StatusRequestID').value.trim().length > 0)
        {
            message = 'click for export status';
        }
        else
        {
            message = 'enter RequestID and registered email address (in Notify, above)'
        }

        $('StatusButtonMsg').store({ "message" : null, "error" : null });
    }
    else
    {    
        message = $('StatusButtonMsg').retrieve('message', null);
        if (message === null || message.length == 0)
        {
            // depends on the disposition of the response
            if (endpoint_status === 'StatusCode.REQUEST_PROCESSING' || endpoint_status === 'StatusCode.REQUEST_QUEUED' || endpoint_status === 'StatusCode.REQUEST_QUEUED_DEBUG')
            {
                message = 'processing';
            }
            else if (endpoint_status === 'ErrorCode.REQUEST_FATAL_ERROR')
            {
                if (error_message !== null && error_message.length > 0)
                {
                    message =  error_message;
                }
            }
            else if (endpoint_status === 'ErrorCoce.REQUEST_NOT_ONLINE')
            {
                message = 'timed out; export no longer online';
            }
        }

        if (message === null || message.length == 0)
        {
            if (endpoint_status_wordy !== null && endpoint_status_wordy.length > 0)
            {
                message = endpoint_status_wordy;
            }
        }

        if (message === null || message.length == 0)
        {
            if ((status_button_click && $('StatusButton').retrieve('ajax-state', 'pre-click') === 'ajax-running') || (export_button_click && $('ExportButton').retrieve('ajax-state', 'pre-click') === 'ajax-running'))
            {
                message = 'processing status request';
            }
            else
            {
                if ((export_button_click && export_button_error) || (status_button_click && status_button_error))
                {
                    message = 'error';
                }
                else
                {
                    if ($('ExportNotify').retrieve('valid', false) && $('StatusRequestID').value.trim().length > 0)
                    {
                        message = 'click for export status';
                    }
                    else
                    {
                        message = 'enter RequestID and registered email address (in Notify, above)'
                    }
                }
            }
        }
    }

    $('StatusButtonMsg').innerHTML = message;

    // row 2, col 3 (more info, 'List formats...') - affected by status click only 
    if (reset)
    {
       $('StatusOther').innerHTML = ''; 
    }
    else
    {
        if (status_button_click)
        {
            message = $('StatusOther').retrieve('message', null);
            if (message === null || message.length == 0)
            {
                // depends on the disposition of the response
                if (endpoint_status === 'StatusCode.REQUEST_COMPLETE')
                {
                    message = 'list formats are index.html, index.json, and index.txt<br>export script file is ' + request_id + '.drmsrun';
                }
                else if (endpoint_status === 'StatusCode.REQUEST_PROCESSING' || endpoint_status === 'StatusCode.REQUEST_QUEUED' || endpoint_status === 'StatusCode.REQUEST_QUEUED_DEBUG')
                {
                    message = '';
                }
                else if (endpoint_status === 'ErrorCode.REQUEST_FATAL_ERROR')
                {
                    if (error_message !== null && error_message.length > 0)
                    {
                        message = error_message;
                    }
                }
                else if (endpoint_status === 'ErrorCoce.REQUEST_NOT_ONLINE')
                {
                    message = 'export is no longer online'
                }
            }

            if (message === null || message.length == 0)
            {
                if (endpoint_status_wordy !== null && endpoint_status_wordy.length > 0)
                {
                    message = endpoint_status_wordy;
                }
            }

            if (message === null || message.length == 0)
            {
                if (status_button_error)
                {
                    message = 'error';
                }
                else
                {
                    message = '';
                }
            }

            $('StatusOther').innerHTML = message; 
        }
    }

    // row 4, col 2 (yet again more disposition info, data ready, etc.) - affeced by status click only
    if (reset)
    {
        $('StatusStatus').innerHTML = '';
        $('StatusStatus').style.backgroundColor = colorYellow;
        $('StatusStatus').disabled = true;
    }
    else
    {
        if (status_button_click)
        {
            message = $('StatusStatus').retrieve('message', null);
            if (message === null || message.length == 0)
            {
                // depends on the disposition of the response
                if (endpoint_status === 'StatusCode.REQUEST_COMPLETE')
                {
                    message = 'data ready, size ' + payload_size + ' MB';
                }
                else if (endpoint_status === 'StatusCode.REQUEST_PROCESSING' || endpoint_status === 'StatusCode.REQUEST_QUEUED' || endpoint_status === 'StatusCode.REQUEST_QUEUED_DEBUG')
                {
                    message = 'processing export; estimated size, ' + payload_size + ' MB';
                    if (seconds_elapsed !== null && seconds_elapsed.length > 0)
                    {
                        message = 'processing export; payload size, ' + payload_size + ' MB; seconds since request initiated, ' + seconds_elapsed;
                    }
                    else
                    {
                        message = 'processing export; payload size, ' + payload_size + ' MB';
                    }
                }
                else if (endpoint_status === 'ErrorCode.REQUEST_FATAL_ERROR')
                {
                    if (error_message !== null && error_message.length > 0)
                    {
                        message =  error_message;
                    }
                }
                else if (endpoint_status === 'ErrorCode.REQUEST_NOT_ONLINE')
                {
                    message = 'timed out; export no longer online';
                }
            }

            if (message === null || message.length == 0)
            {
                if (endpoint_status_wordy !== null && endpoint_status_wordy.length > 0)
                {
                    message = endpoint_status_wordy;
                }
            }

            if (message === null || message.length == 0)
            {
                if ($('StatusButton').retrieve('error', false))
                {
                    message = 'error';
                }
                else
                {
                    message = '';
                }
            }

            $('StatusStatus').innerHTML = message;
        }
    }

    // row 5, col 2 (base url of export) - affected by status click only
    if (reset)
    {
        $('StatusLocation').innerHTML = '';
        $('StatusLocation').style.backgroundColor = colorYellow;
        $('StatusLocation').disabled = true;
    }
    else
    {
        if (status_button_click)
        {
            if (sums_directory !== null && sums_directory.length > 0)
            {
                if (access !== null && access.toLowerCase() === 'ftp')
                {
                    data_base_url = "ftp://pail.stanford.edu/export" + sums_directory + "/";
                }
                else
                {
                    data_base_url = "http://jsoc.stanford.edu" + sums_directory + "/";
                }

                link_element = "<a href='" + data_base_url + "' target='_blank'>" + data_base_url + "<\/a>";
            }

            if (link_element === null)
            {
                link_element = '';
            }

            $('StatusLocation').innerHTML = link_element;
        }
    }

    // row 6, col 2 - affected by status click only
    if (reset)
    {
        $('TarFileLocation').innerHTML = '';
        $('TarFileLocationRow').style.display = 'none';
    }
    else 
    {
        if (status_button_click)
        {
            // row 6, col 2
            if (data_package !== null && data_package.type !== null && data_package.type.toLowerCase() === 'tar')
            {

                alert('data packae type ' + data_package.type);
                $('TarFileLocation').innerHTML = "<a href='" + data_package.file_name + "'>" + data_package.file_name + "<\/a>";
                $('TarFileLocationRow').style.display = 'table-row';
            }
            else
            {
                $('TarFileLocation').innerHTML = '';
                $('TarFileLocationRow').style.display = 'none';
            }
        }
    }

    // row 7, col 2 - affected by status click only
    if (reset)
    {
        $('KeywordFileLocation').innerHTML = '';
        $('KeywordFileLocationRow').style.display = 'none';
    }
    else
    {
        if (status_button_click)
        {
            // row 7, col 2
            if (file_format !== null && file_format.toLowerCase() == 'as-is' && keywords !== null && keywords.length > 0)
            {
                $('KeywordFileLocation').innerHTML = "<a href='" + keywords + "' target='_blank'>" + keywords + "<\/a>";
                $('KeywordFileLocationRow').style.display = 'table-row';
            }
            else
            {
                $('KeywordFileLocation').innerHTML = '';
                $('KeywordFileLocationRow').style.display = 'none';
            }
        }
    }

    // row 8 (table of urls)
    if (reset)
    {
        //$('StatusDataLocation').innerHTML = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;';
        $('StatusDataLocation').innerHTML = '';
    }
    else
    {
        if (status_button_click)
        {
            alert('creating url table');
            // only an status button click should create the url table in the lower/status section
            if (export_data !== null)
            {
                alert('got data - ' + JSON.stringify(export_data));
                $('StatusDataLocation').innerHTML = CreateDataTable(export_data, data_package) + '<br>';
            }
            else
            {
                alert('no got data');
                $('StatusDataLocation').innerHTML = '';
            }
        }
    }

    // re-export
    if (endpoint_status === 'ErrorCode.REQUEST_NOT_ONLINE')
    {
        $('ReRequestID').value = request_id_resolved;
        $('ReExportDiv').style.display = 'block';
    }
    else
    {
        $('ReRequestID').value = '';
        $('ReExportDiv').style.display = 'none';
    }

    // export buttons
    if (endpoint_status === 'StatusCode.REQUEST_COMPLETE')
    {
        if (export_button_click)
        {
            $('ExportButton').store({ "error" : false, "label" : "complete" });
            $('ExportButtonMsg').store({ "message" : null });
        }
    }
    else if (endpoint_status === 'StatusCode.REQUEST_PROCESSING' || endpoint_status === 'StatusCode.REQUEST_QUEUED' || endpoint_status === 'StatusCode.REQUEST_QUEUED_DEBUG')
    {
        if (export_button_click)
        {
            $('ExportButton').store({ "error" : false, "label" : "wait..." });
            $('ExportButtonMsg').store({ "message" : null });
        }
    }
    else if (endpoint_status === 'ErrorCode.REQUEST_FATAL_ERROR')
    {
        if (export_button_click)
        {
            $('ExportButton').store({ "error" : true, "label" : "bad export" });
            $('ExportButtonMsg').store({ "message" : error_message });
        }
    }
    else if (endpoint_status === 'ErrorCode.REQUEST_NOT_ONLINE')
    {
        // status-button click also modifies export button label and message too
        $('ExportButton').store({ "error" : true, "label" : "timeout" });
        $('ExportButtonMsg').store({ "message" : error_message });
    }

    update_export_buttons();

    if (reset)
    {
        $('StatusButton').store({ "reset" : false });
    }
}
// tester success
</script>
<script type="text/javascript">


function ProcessRequestStatusResponse(mr_response_obj)
{
    var endpoint_status = null;
    var endpoint_status_wordy = null;
    var request_id = null;
    var payload_size = null;
    var seconds_elapsed = null;
    var sums_directory = null;
    var number_records = null;
    var number_files = null;
    var access = null;
    var data_package = null;
    var file_format = null;
    var keywords_file = null;
    var export_data = null;
    var contact = null;
    var error_message = null;
    var interval_fn_timer = null;
    var interval_fn_timeout = null;
    var export_button_click = null;

    if (mr_response_obj !== null)
    {
        endpoint_status = mr_response_obj.drms_export_status;
        endpoint_status_wordy = mr_response_obj.drms_export_status_description;

        if (mr_response_obj.hasOwnProperty('request_id'))
        {
            request_id = mr_response_obj.request_id;
        }

        if (mr_response_obj.hasOwnProperty('mb_exported') && mr_response_obj.mb_exported !== null)
        {
            payload_size = mr_response_obj.mb_exported.toString();
        }

        if (mr_response_obj.hasOwnProperty('wait') && mr_response_obj.wait !== null)
        {
            seconds_elapsed = mr_response_obj.wait.toString();
        }

        if (mr_response_obj.hasOwnProperty('sums_directory'))
        {
            sums_directory = mr_response_obj.sums_directory;
        }

        if (mr_response_obj.hasOwnProperty('number_records') && mr_response_obj.number_records !== null)
        {
            number_records = mr_response_obj.number_records.toString();
        }

        if (mr_response_obj.hasOwnProperty('number_files') && mr_response_obj.number_files !== null)
        {
            number_files = mr_response_obj.number_files.toString();
        }

        if (mr_response_obj.hasOwnProperty('access'))
        {
            access = mr_response_obj.access;
        }

        if (mr_response_obj.hasOwnProperty('package'))
        {
            alert('got package ' + JSON.stringify(mr_response_obj.package));
            data_package = mr_response_obj.package;
        }

        if (mr_response_obj.hasOwnProperty('file_format'))
        {
            file_format = mr_response_obj.file_format;
        }

        if (mr_response_obj.hasOwnProperty('keywords_file'))
        {
            keywords_file = mr_response_obj.keywords_file;
        }

        if (mr_response_obj.hasOwnProperty('export_data'))
        {
            export_data = mr_response_obj.export_data;
        }

        if (mr_response_obj.hasOwnProperty('error_message') && mr_response_obj.error_message !== null && mr_response_obj.error_message.length > 0)
        {
            error_message = JSON.stringify(mr_response_obj.error_message);
        }

        if (mr_response_obj.hasOwnProperty('contact'))
        {
            contact = mr_response_obj.contact;
        }

        alert('extracted response values');
    }
    else
    {
        error_message = 'failure obtaining export status';
        endpoint_status = 'ErrorCode.REQUEST_FATAL_ERROR';
    }
    
    if ($('ExportButton').retrieve('ajax-state', 'pre-click') !== 'pre-click')
    {
        export_button_click = true;
    }
    else 
    {
        // assume this was a lower/status click by default
        export_button_click = false;
    }

    Cookie.setData("state", 2);

    if (endpoint_status === 'StatusCode.REQUEST_NOT_ONLINE')
    {
        // error - maybe the user really waited a week to get status on an export
        if (export_button_click)
        {
            update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);
            Cookie.setData('state', 0);
        }
        else
        {
            // clear out info from the request section - passing a null request id will do that
            update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, null, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);

            update_status_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);
            Cookie.setData('state', 2);
        }

        set_eb_state_disabled(true);
    }
    else if (endpoint_status === 'StatusCode.REQUEST_FATAL_ERROR')
    {
        if (export_button_click)
        {
            update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);
            Cookie.setData('state', 0);
        }
        else
        {
            update_status_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);
            Cookie.setData('state', 2);
        }

        set_eb_state_disabled(true);
    }
    else if (endpoint_status === 'StatusCode.REQUEST_PROCESSING' || endpoint_status === 'StatusCode.REQUEST_QUEUED' || endpoint_status === 'StatusCode.REQUEST_QUEUED_DEBUG')
    {
        if (export_button_click)
        {
            // updates $('StatusRequestID') too since request_id is not null
            update_status_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_reccords, number_files, access, data_package, file_format, keywords_file, export_data, contact);
            
            update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);
            Cookie.setData('requestid', request_id);
            Cookie.setData('state', 3);

            file_upload_on_complete();
        }
        else
        {
            update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);
            Cookie.setData('state', 1);
        }
    }
    else if (endpoint_status === 'StatusCode.REQUEST_COMPLETE')
    {
        alert('complete, no error');

        if (export_button_click)
        {
            Cookie.setData('requestid', '');
            Cookie.setData('state', 0);

            // export-button click changes EB state (but status-button click does not) back to disabled
            if ($('ExportButton').retrieve('state', EB_STATE_DISABLED) === EB_STATE_PATH)
            {
                // before we change the state to disabled, we need to ensure that the interval function is no longer running
                // (due to a race condition, it may still be running (interval sets to EB_STATE_PATH, then this code here
                // runs, which changes state to EB_STATE_DISABLED before interval function has a chance to clear itself))
                set_eb_state_disabled(false);
            }
            else
            {
                // error
                alert('unexpected eb state');
            }

           update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact); 
        }
        else
        {
            alert('updating upper');
            // need to update $('RequestIdPlace'), $('ExportStatus'), but NOT $('ExportLocation')
            update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);

            alert('updating lower')
            update_status_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);

            Cookie.setData('state', 1);
        }

        file_upload_on_complete();
        Cookie.setData("state", 1);
    }
    else if (endpoint_status.search(/errorcode/i) == 0)
    {
        // error
        if (export_button_click)
        {
            update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);
            Cookie.setData('state', 0);
        }
        else
        {
            update_status_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);
            Cookie.setData('state', 2);
        }

        set_eb_state_disabled(true);
    }
    else
    {
        // some other status code (not expected, like TOO_MANY or NOT_QUEUED)
        error_message = 'unexpected endpoint status ' + endpoint_status;
        endpoint_status = 'ErrorCode.REQUEST_FATAL_ERROR';

        if (export_button_click)
        {
            update_request_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);
            Cookie.setData('state', 0);
        }
        else
        {
            update_status_section_ui(endpoint_status, endpoint_status_wordy, error_message, request_id, payload_size, seconds_elapsed, sums_directory, number_records, number_files, access, data_package, file_format, keywords_file, export_data, contact);
            Cookie.setData('state', 2);
        }

        set_eb_state_disabled(true);
    }
}

// tester success
</script>
<script type="text/javascript">


function GetStatus()
{
    var export_app_arguments = null;
    var options = null;
    var origin = null;
    var db_host = null;
    var address = null;
    var request_id = null;
    var on_failure = null;

    // if a status check is currently running, bail (an onClick() and an onChange() will be called when 
    // a user changes the request ID andajax_ then clicks the `request status` button)
    if ($('StatusButton').retrieve('ajax_state', 'pre-click') != 'ajax-running')
    {
        address = $('ExportNotify').value.trim();
        request_id = $('StatusRequestID').value.trim();
        if (request_id.length == 0)
        {
            alert("You must provide a RequestID");
            return;
        }

        origin = ExportOrigin(request_id);

        if (origin[0] == 'extServer')
        {
            db_host = EXTERNAL_SERVER;
        }
        else
        {
            db_host = INTERNAL_SERVER;
        }

        // An external user can check status on certain internal requests. These requests originated from the external site,
        // but they were passed-through to the internal site because they involved at least one internal series that
        // was whitelisted for external access. The request IDs of those requests contains an 'X':
        //
        // JSOC_20161225_1254_X_IN

        // there are two boolean attributes describing the origin of an export request:
        // 1. the request was submitted from the external website (EXTERNAL_WEBSERVER) or the internal website (INTERNAL_WEBSERVER)
        // 2. the request was for the export of a db-external data series (the request ID ends in '_IN') or a db-internal data series (the request ID does not end in '_IN')
        //
        // the internal server can serve requests for db-internal series only; the external server can serve requests for either
        // db-external series (the request ID does not end in '_IN'), or db-internal series initiated from the external server
        // (the request ID ends in '_X_IN')
        if (origin[1] == 'invalidRequestID')
        {
            if (origin[0] == 'extServer')
            {
                alert('The request ID ' +  $("StatusRequestID").value + ' is accessible from http://' + INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN +' only. Please use a request ID generated by a request made on the http://' + EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN +' webserver (which has a format of JSOC_YYYYMMDD_NNN or JSOC_YYYYMMDD_NNN_X_IN).');
                return;
            }
            else if (origin[0] == 'intServer')
            {
                alert('The request ID ' +  $("StatusRequestID").value + ' is accessible from http://' + EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + ' only. Please use a request ID generated by a request made on the http://' + INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + ' webserver (which has a format of JSOC_YYYYMMDD_NNN_IN).');
                return;
            }
            else
            {
                return;
            }
        }

        export_app_arguments = { "address" : address, "db-host" : db_host, "request-id" : request_id };

        options =
        {
            method: 'get',
            onSuccess: function(response)
            {
                alert('success');
                var mr_response_obj = response.responseJSON;

                $('StatusButton').store({ "ajax-state" : "post-click" });

                if (mr_response_obj !== null)
                {
                    alert('got response');
                    ProcessRequestStatusResponse(mr_response_obj);
                }
            },
            onFailure: function(response)
            {
                var error_message = "failuring getting export status: " + JSON.stringify(response.responseJSON.error_message);

                $('StatusButton').store({ "ajax-state" : "post-click" });

                ProcessRequestStatusResponse({ "error_message" : error_message });
            },
            on428: function(response)
            {
                var error_message = "invalid arguments to pending-request-status endpoint: " + JSON.stringify(response.responseJSON.error_message);

                $('StatusButton').store({ "ajax-state" : "post-click" });

                ProcessRequestStatusResponse({ "error_message" : error_message });
            },
            onComplete: function()
            {
                $('StatusButton').store({ "ajax-state" : "post-click" });
            }
        };

        $("StatusLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
        $("TarFileLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
        $("KeywordFileLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
        $("StatusDataLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
        $("StatusStatus").innerHTML = "";
        $("StatusValue").innerHTML = "";
        $("StatusOther").innerHTML = "";
        $("StatusButtonMsg").innerHTML = "Processing status request ...";
        $("StatusButton").value = "Processing ...";

        options['parameters'] = export_app_arguments;

        $('StatusButton').store({ "ajax-state" : "ajax-running" });
        update_status_section_ui(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);

        alert('starting ajax');

        new Ajax.Request(window.location.origin + PENDING_REQUEST_STATUS_PATH, options);
    }
}

</script>

</head>
<body bgcolor="#E0F0FF" onload="OnLoadInit();" >
<div id="header">
  <a href ="http://jsoc.stanford.edu" id="header_logo"><img src="http://hmi.stanford.edu/images/web/JSOC_120.gif"
    style="vertical-align:middle;height:60px;border:0" alt="JSOC logo"></a>
&nbsp;&nbsp;&nbsp;
<b><big style="vertical-align:middle">&nbsp;&nbsp;JSOC Data Export</big></b>
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
<input id="ResetPageButton" type="button" value="reset page" onClick="ReInitPage();" disabled>
&nbsp;&nbsp;&nbsp;
<input id="TipsOnOffButton" type="button" value="Turn Help Off" onClick="ToggleHelp();" >
&nbsp;&nbsp;<span id="AjaxBusy">0</span> Active HTTP Requests
<!-- <br clear=all> -->
<hr>
</div> <!-- end div header -->
<div id="ExportRequestDiv">
<br><b>JSOC Data Export Request Generation</b>

<!-- Start Message of the Day -->
<div id="MOTD">
<!--#include virtual="JSOC_MOTD.html" -->
</div> <!-- end MOTD div -->
<!-- END MODT DIV -->

<span id="RecordSetExample">
&nbsp; &nbsp;
<a href="exportdata.d/ExportDataErrorHelp.html" target="JSOC_Help">Help with Error Messages</a>
&nbsp;
<a href="http://jsoc.stanford.edu/doc/exports/exportdata_lookdata_release_notes.txt" target="JSOC_Help">Release Notes</a>
</span>
<p>
If the Method is changed from "url_quick" or "url_direct" you will have additional options to specify.
"url-direct" is temporarily disabled.
<p>
After the request is submitted
for Methods of "url", "ftp", "url-tar" or "ftp-tar" you will recieve ON THIS PAGE a "Request_ID" that will be used
to access the data when it is ready.
<p>
If you enter an email address you will be notified when the data is ready.
If you do not provide an email address you must leave this page open or save the Request_ID in order to
access the data.
<p>

<!-- Load bulk of html code here -->
<span id="ExportRequestForm"></span>

<div id="iframeHideDiv" style="display:none;">
  <iframe id="FileUploadFrame" onload="process_file_upload_response();" src="" style="height:0px;width:0px;border:0px solid #fff;"></iframe>
</div>

<div id="SubmitResponseDiv">
<table>
  <tr>
    <td style="width:11em">RequestID</td>
    <td><input type="text" id="RequestIdPlace" name="RequestIdPlace" style="width:15em;background-color:#FFF8DC;" value=""></td>
    <td id="RequestIDDesc"></td>
  </tr>

  <tr>
    <td style="width:11em">Status</td>
    <td><input type="text" id="ExportStatus" name="ExportStatus" style="width:15em;background-color:#FFF8DC;" value=""></td>
  </tr>

  <tr>
    <td id="DataLocation" style="width:11em">Data Location</td>
    <td><input type="text" id="ExportLocation" name="ExportLocation" style="width:15em;background-color:#FFF8DC;" value=""></td>
  </tr>

</table>
</div>
<hr>
<div id="ExportDataDiv"  style="background-color:#C0E0FF;">
<b>JSOC Data Export Status and Retrieval</b>
<p>
<table>
  <tr>
    <td style="width:11em" >RequestID</td>
    <td><input type="text" id="StatusRequestID" name="StatusRequestID" style="width:15em;background-color:#FFF8DC;" value="" onChange="GetStatus();"></td>
    <td>This is the ID tag for your export request.</td>
    <td><span id="StatusValue">&nbsp;</span></td>
  </tr>

  <tr>
    <td colspan="2" align="center" >
      <input id="StatusButton" type="button" value="get status" style="background-color:#D8D8D8" onClick="GetStatus();" ></td>
    <td><span id="StatusButtonMsg">Please only click once for status request.</span ></td>
    <td rowspan="3"><span id="StatusOther">&nbsp;</span></td>
  </tr>

  <tr>
    <td colspan="2" align="center" >
      <input id="ClearButton" type="button" value="Clear Request" style="background-color:#D8D8D8" onClick="ClearStatus();" ></td>
    <td>Clear old status RequestID</td>
  </tr>

  <tr>
    <td>Status</td>
    <td><input type="text" id="StatusStatus" name="StatusStatus" style="width:15em;background-color:#FFF8DC;" value=""></td>
  </tr>

  <tr>
    <td>Data Location</td>
    <td><input type="text" id="StatusLocation" name="StatusLocation" style="width:15em;background-color:#FFF8DC;" value=""></td>
  </tr>

  <tr id="TarFileLocationRow" style="display:none;">
    <td>Tar File Location</td>
    <td colspan="3"><span id="TarFileLocation"  style="background-color:#FFF8DC;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span ></td>
  </tr>

  <tr id="KeywordFileLocationRow" style="display:none;">
    <td>Keyword File Location</td>
    <td colspan="3"><span id="KeywordFileLocation"  style="background-color:#FFF8DC;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span ></td>
  </tr>

  <tr>
  <td colspan="4"><span id="StatusDataLocation" style="background-color:#FFF8DC;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span ></td>
  </tr>

</table>
</div> <!-- id="ExportRequestDiv" -->

<div id="ReExportDiv" style="display:none">
<HR>
Use this section to request a renewal/repeat of a prior export for which the data online-retention time has expired.
<table>

  <tr>
    <td style="width:10em" >RequestID</td>
    <td><input type="text" id="ReRequestID" name="ReRequestID" style="background-color:#FFF8DC;" value="" onChange="ExportNop();"></td>
    <td>Enter RequestID for repeat or prior export</td>
    <td><span id="ReStatusValue">&nbsp;</span></td>
  </tr>

  <tr id="ReNotifyRow">
    <td>Notify</td>
    <td><input id="ReExportNotify" type="text" name="Renotify" value="" onChange="ExportNop();" ></td>
    <td colspan="2">
      Provide your email address for notification.
    </td>
  </tr>

  <tr id="AjaxReExportRequestRow">
    <td colspan="4">
      re-<input id="ReExportButton" type="button" value="Submit Export Request" style="background-color:#D8D8D8" onClick="GetReExport();" >
    <span id="ReExportButtonMsg">Please only click once for re-export request.</span >
    </td>
  </tr>

</table>
</div> <!-- id="ReExportDiv" -->
</div>

<HR>
<P style="height:1px">
<div id="footer" style="vertical-align:bottom;text-align:center;">
<I>Home page for:</I>
<a href = "http://jsoc.stanford.edu/" id="footer_link"><b>SDO-JSOC</b></a>
</div>

<script type="text/javascript">
$("ExportRequestForm").innerHTML = "";
// The onload function is called after this. It calls ProcessingInit() and ProcessingEnabled(). Don't do that here as well.
</script>

<div class="export-include-html" file-resource="request-form.html" target-element="ExportRequestForm"></div>

</body>
</html>
