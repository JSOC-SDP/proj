<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta HTTP-EQUIV="Content-Type" content="text/html; charset=iso-8859-1">
<title>JSOC Export Data</title>

<!--
<script type="text/javascript" src="js/prototype-1.6.0.3.js"></script>
-->
<script type="text/javascript" src="js/prototype-1.6.1.js"></script>
<script type="text/javascript" src="js/cookies.js"></script>
<script type="text/javascript" src="js/prototip.js"></script>
<link rel="stylesheet" type="text/css" href="css/prototip.css" >

<script type="text/javascript">
// Global variables and initialize page locations
var exportdata = location.pathname.sub(".html","");
</script>
<script type="text/javascript">
document.write('<base id="basepath" href="'+exportdata+'/"><\/base>');
</script>

<script type="text/javascript">

// Set CGI-BIN and include targets

// Eventually this should be put into a common file loaded by all the html web pages. To do that
// we need to copy code from exportdata.html to here that sets the base directory that is used
// when loading files with the <script> tag. Then we need to put the common file in that
// base directory, and we need to read it here. But for now, just hard-code this needed map.
var INTERNAL_SERVER = 'hmidb'
var EXTERNAL_SERVER = 'hmidb2'
var INTERNAL_WEBSERVER = 'jsoc2'
var EXTERNAL_WEBSERVER = 'jsoc'
var STANFORD_DOMAIN = 'stanford.edu'

// EB states
var EB_STATE_DISABLED = 'disabled';
var EB_STATE_ENABLED = 'enabled';
var EB_STATE_SUBMIT_ENABLED = 'submit_enabled';
var EB_STATE_SUBMIT = 'submit';
var EB_STATE_CANCEL_ENABLED = 'cancel_enabled';
var EB_STATE_PATH = 'path';
var EB_STATE_CANCEL = 'cancel';
var EB_STATE_CANCELED = 'canceled';
var EB_STATE_TIMEOUT = 'timeout';

var KEYWORD_CTYPE1 = 'CTYPE1';
var KEYWORD_CTYPE2 = 'CTYPE2';
var KEYWORD_LVL_NUM = 'LVL_NUM';
var AIA_SCALE_CTYPE1 = 'HPLN-TAN';
var AIA_SCALE_CTYPE2 = 'HPLT-TAN';
var KEYWORD_SPEC = '*spec*';
var KEYWORD_ONLINE = '*online*';
var KEYWORD_SIZE = '*size*';
var AIA_NAMESPACE = 'aia';
var NA = 'na';
var AIA_SCALE_NAXES = 2;
var AIA_LEV1P5 = 'aia.lev1p5';

var serverMap = new Array();
serverMap[EXTERNAL_WEBSERVER] = EXTERNAL_SERVER;
serverMap[EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN] = EXTERNAL_SERVER;
serverMap[INTERNAL_WEBSERVER] = INTERNAL_SERVER;
serverMap[INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN] = INTERNAL_SERVER;

var JSOCEXTINFO = 'jsocextinfo';
var JSOC_INFO = 'jsoc_info';
var JSOCEXTFETCH = 'jsocextfetch';
var JSOC_FETCH = 'jsoc_fetch';
var DRMS_EXPORT = 'drms-export.sh';
var SERIES_INFO = 'series_info';
var PARSE_RECSET = 'drms_parserecset';
var LOOKDATA = "lookdata";
var MANAGE_EXPORT_CGI = 'manage-request.sh';

// manage-request operations
var MR_OPERATION_CHECK = 'check';
var MR_OPERATION_CANCEL = 'cancel';

// manage-requests status codes
var MR_STATUS_UNKNOWN = 0;
var MR_STATUS_NOT_PENDING = 1;
var MR_STATUS_PENDING = 2;
var MR_STATUS_REQUEST_CANCELED = 3;

var HTML_REQUESTID_DESC = 'This is your request ID; enter it below and click on "request status" to obtain the link to the data.'


</script>
<!-- Add html for processing and protocol options  -->
<!-- The sourced file contains: escaped_html='...'  -->
<script type="text/javascript" src="exportdata.d/export_request_form.htmlesc"></script>

<!-- Add functions for export processing and protocol options  -->
<script type="text/javascript" src="exportdata.d/processing.js"></script>
<script type="text/javascript" src="exportdata.d/protocols.js"></script>

<!-- Add list of seriesnames for which processing on export is not suportted -->
<script type="text/javascript" src="exportdata.d/no_processing.js"></script>

<!-- Add export email checking code. -->
<script type="text/javascript" src="exportdata.d/export_email_verify.js"></script>

<style type="text/css">

#body { margin:0; padding:0; }
#header { position:relative; top:0; left:0; width:100%; background:#eee; }
#footer { position:fixed; bottom:0; left:0; width:100%; background:#eee; }
#ExportRecordSet { width:40em; font-size:100%; }
span.tip { background-color:blue;font-family:verdana;color:white;font-size:1em;font-weight:bold;}
.prototip { font:0.8em Arial, Helvetica, sans-serif; }
</style>

<script type="text/javascript">

// Protect page from accidental BACK button
var ON_BEFORE_UNLOAD_FXN = function()
{
    if ($('FileUploadFormID').retrieve('beforeunloadOverride', false))
    {
        $('FileUploadFormID').store({ 'beforeunloadOverride' : false })
        window.onbeforeunload = null;
    }

    if ($('FileUploadFormID').retrieve('beforeunloadEnabled', false))
    {
        // this message will never display - all browsers disallow this now;
        // return "Did you really mean to leave exportdata? Use CANCEL to stay here";
        window.onbeforeunload = function() { return 'this does not matter - never gets executed'; };
    }
};

var UPDATE_HTTP_REQUEST_COUNT = function()
{
    $("AjaxBusy").innerHTML = Ajax.activeRequestCount;

    if (Ajax.activeRequestCount == 0)
    {
        $("AjaxBusy").style.color = colorDarkGreen;
    }
    else
    {
        $("AjaxBusy").style.color = colorDarkRed;
    }
}

var MANAGE_REQUEST_ON_SUCCESS_INTERVAL = function(op, callback_fn)
{
    var success_fn = function(response)
    {
        var mr_status_obj = response.responseJSON;

        if (mr_status_obj !== null)
        {
            var status = mr_status_obj.status;
            var state = $("ExportButton").retrieve('state', EB_STATE_DISABLED);
            var interval_fn_timer = $("ExportButton").retrieve('interval', null);
            var clear_interval_fn_timer = false;
            var interval_fn_timeout = $("ExportButton").retrieve('interval_timeout', null);
            var error = false;

            if (status < 0)
            {
                // error calling MR - do nothing (don't change state)
                $("ExportButtonMsg").innerHTML = mr_status_obj.msg;
                error = true;
            }
            else if (state == EB_STATE_TIMEOUT)
            {
                // do not do anything; set_eb_state_disabled() will take care of stopping the interval function
            }
            else if (op == MR_OPERATION_CHECK)
            {
                // action depends on state and status
                if (status == MR_STATUS_NOT_PENDING)
                {
                    if (state == EB_STATE_ENABLED)
                    {
                        state = EB_STATE_SUBMIT_ENABLED;
                    }
                    else if (state == EB_STATE_SUBMIT_ENABLED)
                    {
                        // no change
                        state = EB_STATE_SUBMIT_ENABLED;
                    }
                    else if (state == EB_STATE_SUBMIT)
                    {
                        state = EB_STATE_SUBMIT;
                    }
                    else if (state == EB_STATE_CANCEL_ENABLED)
                    {
                        state = EB_STATE_PATH;
                    }
                    else if (state == EB_STATE_PATH)
                    {
                        // do nothing
                        state = EB_STATE_PATH;

                        // stop interval function
                        clear_interval_fn_timer = true;
                    }
                    else if (state == EB_STATE_CANCEL)
                    {
                        // stop interval function
                        clear_interval_fn_timer = true;

                        // successful cancelation (or failure to cancel, followed by natural completion);
                        // back to the original pre-check-for-parameters state
                        state = EB_STATE_CANCELED;
                    }
                    else
                    {
                        // error
                        $("ExportButtonMsg").innerHTML = 'bad export button state[1] ' + state;
                        error = true
                    }
                }
                else if (status == MR_STATUS_PENDING)
                {
                    if (state == EB_STATE_ENABLED)
                    {
                        // cancel short-cut taken
                        state = EB_STATE_CANCEL_ENABLED;

                        if (interval_fn_timer === null)
                        {
                            // start-up interval
                            internal_fn = CHECK_FOR_PENDING_REQUEST(true);
                            interval_fn_timer = setInterval(internal_fn, 1000);
                            $("ExportButton").store('interval', interval_fn_timer);
                        }

                        // do not allow the pending-request check to last forever (EB is in EB_STATE_CANCEL_ENABLED); 86400000 ==> 1 day
                        // reset the timeout if it is already set
                        if (interval_fn_timeout !== null)
                        {
                            clearTimeout(interval_fn_timeout);
                        }

                        interval_fn_timeout = setTimeout(function () { $("ExportButton").store('state', EB_STATE_TIMEOUT); set_eb_state_disabled(false);}, 86400000);
                        $("ExportButton").store('interval_timeout', interval_fn_timeout);
                    }
                    else if (state == EB_STATE_SUBMIT_ENABLED)
                    {
                        // error - can't happen
                        $("ExportButtonMsg").innerHTML = 'bad export button state[2] ' + state;
                        error = true
                    }
                    else if (state == EB_STATE_SUBMIT)
                    {
                        state = EB_STATE_SUBMIT;
                    }
                    else if (state == EB_STATE_CANCEL_ENABLED)
                    {
                        // no change
                        state = EB_STATE_CANCEL_ENABLED;
                    }
                    else if (state == EB_STATE_PATH)
                    {
                        // error - can't happen
                        $("ExportButtonMsg").innerHTML = 'bad export button state[3] ' + state;
                        error = true
                    }
                    else if (state == EB_STATE_CANCEL)
                    {
                        // do nothing - wait for cancelation (or natural completion) to occur
                        state = EB_STATE_CANCEL;
                    }
                    else
                    {
                        // error
                        $("ExportButtonMsg").innerHTML = 'bad export button state[4] ' + state;
                        error = true
                    }
                }
                else
                {
                    // error
                    $("ExportButtonMsg").innerHTML = 'unexpected manage-request status ' + status.toString();
                    error = true;
                }
            }
            else if (op == MR_OPERATION_CANCEL)
            {
                if (state != EB_STATE_CANCEL_ENABLED)
                {
                    $("ExportButtonMsg").innerHTML = 'bad export button state[5] ' + state;
                    error = true;
                }
                else if (status == MR_STATUS_REQUEST_CANCELED)
                {
                    $("ExportButtonMsg").innerHTML = 'unexpected manage-request status ' + status.toString();
                    error = true;
                }
            }
            else
            {
                // bad operation
                $("ExportButtonMsg").innerHTML = 'bad manage-request operation ' + op;
                error = true;
            }

            if (error)
            {
                // stop interval function
                clear_interval_fn_timer = true;

                state = EB_STATE_DISABLED;
            }

            if (state == EB_STATE_DISABLED)
            {
                // either state WAS EB_STATE_CANCEL, or error; call special function to initialize states
                // back to the beginning
                set_eb_state_disabled(false);
            }
            else
            {
                if (interval_fn_timer !== null && clear_interval_fn_timer)
                {
                    clearInterval(interval_fn_timer);
                    $("ExportButton").store('interval', null);

                    if (interval_fn_timeout !== null)
                    {
                        clearTimeout(interval_fn_timeout);
                        $("ExportButton").store('interval_timeout', null);
                    }
                }

                $("ExportButton").store('state', state);
                update_export_buttons();
            }
        }

        if (callback_fn)
        {
            callback_fn();
        }
    }

    return success_fn;
}

// handles only a subset of all EB states since on-demand checks are used only in
// certain circumstances
var MANAGE_REQUEST_ON_SUCCESS_ON_DEMAND = function(callback_fn)
{
    var success_fn = function(response)
    {
        var mr_status_obj = response.responseJSON;

        if (mr_status_obj !== null)
        {
            var status = mr_status_obj.status;
            var state = $("ExportButton").retrieve('state', EB_STATE_DISABLED);
            var error = false;

            if (status < 0)
            {
                // error calling MR - do nothing (don't change state)
                $("ExportButtonMsg").innerHTML = mr_status_obj.msg;
                error = true;
            }
            else if (state != EB_STATE_ENABLED && state != EB_STATE_DISABLED)
            {
                // for enabled, disabled state only
                $("ExportButtonMsg").innerHTML = 'unexpected export-button state ' + state.toString();
                error = true;
            }
            else
            {
                // action depends on status
                if (status == MR_STATUS_NOT_PENDING)
                {
                    if (state == EB_STATE_ENABLED)
                    {
                        state = EB_STATE_SUBMIT_ENABLED;
                    }
                }
                else if (status == MR_STATUS_PENDING)
                {
                    if (state == EB_STATE_ENABLED)
                    {
                        state = EB_STATE_CANCEL_ENABLED;
                    }
                    else if (state == EB_STATE_DISABLED)
                    {
                        // set the EB state to EB_STATE_CANCEL_ENABLED (the user has a pending export request)
                        state = EB_STATE_CANCEL_ENABLED;
                    }
                    else
                    {
                        $("ExportButtonMsg").innerHTML = 'bad export button state ' + state;
                        error = true
                    }
                }
                else
                {
                    // unexpected status
                    $("ExportButtonMsg").innerHTML = 'unexpected manage-request status ' + status.toString();
                    error = true;
                }
            }

            $("ExportButton").store('state', state)
            update_export_buttons();
        }

        if (callback_fn)
        {
            callback_fn();
        }
    }

    return success_fn;
}

var MANAGE_REQUEST_XHR = function(address, op, interval, callback_fn)
{
    // we have to deal with the db-server pass-through stuff
    var web_server = Host.toLowerCase();
    var db_host = null;
    var on_success = null;

    origin = ExportOrigin(null, web_server);

    if (origin[0] == 'extServer')
    {
        // the request ID was an external one (no "_IN")
        db_host = EXTERNAL_SERVER;
    }
    else
    {
        // the request ID was an internal one (has "_IN" OR "_IN_X")
        db_host = INTERNAL_SERVER;
    }

    if (interval === null || interval === undefined)
    {
        // do nothing on success; the caller does not want to check on results
        on_success = function() { if (callback_fn) callback_fn(); };
    }
    else if (interval)
    {
        on_success = MANAGE_REQUEST_ON_SUCCESS_INTERVAL(op, callback_fn);
    }
    else
    {
        on_success = MANAGE_REQUEST_ON_SUCCESS_ON_DEMAND(callback_fn);
    }

    new Ajax.Request('http://' + Host + '/cgi-bin/ajax/' + MANAGE_EXPORT_CGI,
    {
        method: 'get',
        parameters: { "address" : address, "operation" : op, "H" : db_host },
        onSuccess: on_success,
        onFailure: function()
        {
            alert('unable to check for a pending export request');

            // true ==> do not allow the user to change email address (must reload to do that)
            set_eb_state_disabled(true);

            if (callback_fn !== null && callback_fn !== undefined)
            {
                callback_fn();
            }
        },
        onComplete: function()
        {
        }
     });
}

// export button (EB) states:
// 1. DISABLED - the Check Params for Export button (CPE) has not yet been clicked; interval function (XHR) not running OR
//               failure of any kind anywhere in state graph OR CANCEL + IF "not pending"
// 2. ENABLED - CPE clicked, parameters ready, interval function (IF) running
// 3. SUBMIT_ENABLED - ENABLED + IF "not pending"
// 4. CANCEL_ENABLED - ENABLED + IF "pending"
// 5. CANCEL - SUBMIT_ENABLED + EB clicked
// 6. PATH - CANCEL_ENABLED + IF "not pending"
//
// EB labels
// 1. "not ready" - for DISABLED OR ENABLED
// 2. "submit" - for SUBMIT_ENABLED
// 3. "cancel" - for CANCEL_ENABLED
// 4. "wait" - for CANCEL
// 5. "get path" - for PATH
var CHECK_FOR_PENDING_REQUEST = function(interval)
{
    // the user has already clicked on the Check Params for Export button; the 'submit' button is currently disabled
    var manage_export_fn = function(callback_fn)
    {
        var address = $("ExportNotify").value;
        var op = MR_OPERATION_CHECK;
        var xhr = MANAGE_REQUEST_XHR;

        xhr(address, op, interval, callback_fn);
     }

     return manage_export_fn;
}

// states (the button label); destination states at arrow head
//   disabled: check params not clicked yet
//      not called
//   submit:
//      not called
//   cancel:
//      --> disabled
//   path:
//      not called
var CANCEL_PENDING_REQUEST = function(interval)
{
    var manage_export_fn = function(callback_fn)
    {
        var address = $("ExportNotify").value;
        var op = MR_OPERATION_CANCEL;
        var xhr = MANAGE_REQUEST_XHR;

        xhr(address, op, interval, callback_fn);
     }

     return manage_export_fn;
}

function OnEnterKey(evt,action)
  {
  var keynum;
  var keychar;
  if(window.event) // IE
    keynum = evt.keyCode;
  else if(evt.which) // Netscape/Firefox/Opera
    keynum = evt.which;
  if(keynum == 13)
    action();
  keychar = String.fromCharCode(keynum);
  return keychar;
  }

var previousSeries = "";
function NotifyProcessingCode()
  {
  // called when RecordSet is changed.
  // Set flags to alert processing or method options here.
  // variables here will usually be defined in exportdata.d/processing.js
  // or exportdata.d/export_request_form.html

  // SeriesName is determined asynchronously.
  if (SeriesName == previousSeries)
    SetProcessing(-1, null); // Do not initialize all processing options to their defaults.
  else
    {
    SetProcessing(-2, null); // Init all processing options to their defaults.
    ProtocolOptionsSet = 0;
    }
  previousSeries = SeriesName;
  }

// Global vars
var Host = location.host;
var Internal = 0;
var SeriesName;
var SeriesInfo;
var AiaLev1AttributesGlobal = null; // set in GetDefaultFormat()
var AiaLev1KeywordsGlobal = null; // set in GetDefaultFormat()
var firstRealSegment;
var RequestID;
var RecordLimit;
var RecordCount = null; // Initialized in initVars(), Modified in GetRSCount()
var ExportQueryOK;
var ExportRecordSetOK;
var ExportFromFileList;
var ExportMethodOK;
var ExportFilenameFmtOK;
var ExportProcessingOptions;
var ExportUserOK;
var TipsEnabled;
var TipsCreated = 0;
var args;
var state=0;
var uploadOndoneAction = 0;
var ExportProcessingArgs = "";
var ProcessingAllowed = 1;
var ExportMethodValue = "url_quick";

// Export processing globals.
var ExportProcessingArgsPoll = null;
var ExportProcessingOK = null;

// Protocol global vars
var ExportCompressOK;
var ExportProtocolOK;
var ExportCompressValue = "";
var ExportProtocolValue = "FITS";
var ProtocolOptionsSet = 0;
var protocol_args
var ExportProtocolArgs = "";
var ExportProtocolArgsOK;
var protocolEnable;

// Misc vars
var firstTimePrime;
var expURL;
var IsAia = null;
var IsAiaLev1 = null; // is true, then we need to use the default file format string for aia.lev1p5

// Colors
var colorNeutral = "#D4D0C8";
var colorPreset = "D8D8D8";
var colorOptionSet = "#FFCC66";
var colorPink = "#FFD8D8";
var colorDarkPink = "#FFB0B0";
var colorRed = "#D88080";
var colorDarkRed = "#C00000";
var colorRealRed = "#FF0000";
var colorDarkishRed = "#FF8080";
var colorBrightOrange = '#F9441F';
var colorDarkBlue = "#0000B0";
var colorWhite = "#FFFFFF";
var colorBlack = "#000000";
var colorGreen = "#80FF80";
var colorDarkGreen = "#009000";
var colorYellow = "#FFF8DC";


function initVars()
  {
  Host = location.host;
  if (Host == "jsoc2.stanford.edu")
    Internal = 1;
  else
    Internal = 0;
  SeriesName = "";
  RequestID = "";
  RecordCount = null;
  $('ExportRecordSet').store({ 'count': RecordCount });
  RecordLimit = 0;
  ExportRecordSetOK = 0;
  ExportQueryOK = 0;
  ExportFromFileList = 0;
  ExportMethodOK = 1;
  ExportFilenameFmtOK = 1;
  ExportUserOK = 0;
  TipsEnabled = 1;
  uploadOndoneAction = 0;
  firstTimePrime = "";
  ProcessingAllowed = 1;

  // Init processing
  ExportProcessingArgs = "";
  ExportProcessingOK = null;
  ExportProcessingArgsPoll = null;

  // Init protocols
  ExportProtocolOK = 1;
  ExportCompressOK = 1;
  ExportProtocolArgs = "";
  protocolEnable = 0;
  ProtocolOptionsSet = 0;

    // If the page is being loaded, then exportdataLoaded is true. If the reset page button was clicked, then
    // exportdataLoaded is true as well. So, there is no need to check for a true value for exportdataLoaded.
    ProcessingInit();
    ProcessingEnabled()
    ProtocolOptionsInit();

    // Enable the reset button, now that the page has completed loaded.
    $("ResetPageButton").disabled = false;

  // if (state < 2)
  // Form init
    {
    $("ExportRequestor").value = "";
    $("RequestIdPlace").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("StatusLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("TarFileLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("ExportStatus").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("StatusDataLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("ExportRecordSet").value = "";
    $("ExportCheckMsg").innerHTML = "";
    $("ExportCheckMsg").style.color = colorRealRed;
    // Processing
    $("ProcessRow").style.display="none";
    $("ExportProcessingHidden").value = "no_op";
    $("ProcessingCheckbox").checked = 0;
    // Protocols
    $("ProtocolRow").style.display="none";
    $("ExportProtocol").selectedIndex = 1;
    $("ExportProtocolHidden").value = "FITS";
    $("ExportCompress").selectedIndex = 0;
    $("CompressRow").style.display="none";
    $("ProtocolImageOptions").style.display="none";

    $("ExportMethod").selectedIndex = 2;
    $("ExportFilenameFmt").value = "{seriesname}.{recnum:%lld}.{segment}";
    $("ExportButton").value = "Submit Export Request";
    $("ExportButtonMsg").innerHTML = "Please only click once for export request.";
    $("ExportButton").style.backgroundColor = colorRed;
    $("ExportButton").disabled = true;
    $("RecordSetRow").style.display="table-row";
    $("RecordCountRow").style.display="table-row";
    $("FilenameFmtRow").style.display="none";
    $("RequestorRow").style.display="none";
    $("NotifyRow").style.display="none";
    $("FileUploadCheckbox").checked = 0;
    $("ExportOpID").value = "exp_request";
    $("ReRequestID").value = "";
    $("ReExportDiv").style.display = "none";
    $("TarFileLocationRow").style.display = "none";
    $("KeywordFileLocationRow").style.display = "none";
    $("ShowQueryCheckbox").checked = 0;
    $("StatusRequestID").value = "";
    SetExportMethod(1);
    }

    // removes all registration statuses
    email_initVars($("ExportNotify"), $("ExportRequestor"));

    set_eb_state_disabled(false);

    update_export_buttons();

    FileUploadCleanup();
}

function getargs()
{
    // as far as I can tell, state never equals anything but 0 here; it gets set to 2 in GetExport() - called when user clicks 'submit',
    // it gets set to 2 in GetReExport, it gets touched in ProcessExportResponse() - that function first sets to 3 then to 0, setting to
    // 0 always, and it gets set to either 2 (error jsoc_fetch status) or 1 (non-error jsoc_fetch status) after jsoc_fetch op=status returns
    // but that state never gets used anywhere; the state is only read here, and it is always 0
    //
    // it seems as if 2 means something is asynchronously evaluating whether or not the URL is going to be 'good', 1 means
    // we have a good URL stored in `search`, and 0 means get the URL from the browser address box; so, this function
    // will clear-out jsoc_fetch args if we don't know the status of the existing args, it will use the known-to-be-good
    // args if we have good args stored in `search`, and it will get the args from the URL otherwise, overwriting the
    // `search` args stored in the cookie; but the other functions will force the last option by setting the state to 0, even
    // if we have good args in the `search` attribute
    state = Cookie.getData("state");

    if (state == 1)
    {
        // the export-request record-set is stored in the 'search' cookie attribute; the limit and requestid might also be stored
        var exportargs = Cookie.data["search"];

        if (exportargs != undefined)
        {
            exportargs = decodeURIComponent(exportargs);
            exportargs = exportargs.substr(1);
            exportargs = exportargs.replace(/\?/g,"QUESTIONMARK");
            args = exportargs.toQueryParams();
            if (args.ds == undefined)
            {
                args.ds = "";
            }

            args.ds = args.ds.replace(/QUESTIONMARK/g, "?");
        }
        else
        {
            args = new Object;
            args.ds = "";
        }
    }
    else if (state > 1)
    {
        args = new Object;
        args.ds = "";
        args.requestid = "";
        args.limit= "none";
    }
    else
    {
        // cookie state 0 - attempt to get the record-set specification (ds) from the exportdata.html URL
        var exportargs = location.search;

        exportargs = decodeURIComponent(exportargs);
        exportargs = exportargs.substr(1);
        exportargs = exportargs.replace(/\?/g,"QUESTIONMARK");
        args = exportargs.toQueryParams();
        if (args.ds == undefined)
        {
            args.ds = "";
        }

        args.ds = args.ds.replace(/QUESTIONMARK/g, "?");
        state = 1;
        Cookie.setData("state", state);
        Cookie.setData("search", location.search);
    }

    // load email address and username from cookie
    email_getargs($("ExportNotify"), $("ExportRequestor"));

    return args;
}

// cookie state is 0
function OnLoadInit()
  {
  var needcount = 0;
  Cookie.init({name:exportdata, expires:14});
  initVars(); // This call runs code that requires RecordSet to be set. However, that is not true
              // before it is set below [ $("ExportRecordSet").value = args.ds ]
  if (Internal)
    {
    $("header_logo").href="http://jsoc2.stanford.edu";
    $("footer_link").href="http://jsoc2.stanford.edu";
    }
  state = 0;
  Cookie.setData("state", state);
  args = getargs();

  if (args.ds)
    {
    $("ExportRecordSet").value = args.ds;
    needcount = 1;
    }
  if (args.id)
    {
    RequestID = args.id;
    }
  if (args.limit)
    {
    $("ExportRecordLimit").value = args.limit;
    if (args.limit == "none") RecordLimit = 0;
    else RecordLimit = args.limit;
    }
  if (needcount && $("ExportRecordSet").value != "")
    {
    if (GetRSCount(null))
    {
        $("ExportCheckMsg").innerHTML = "Invalid record-set specification";
    }
    GetDefaultFormat();
    }

  CreateTips();
  $("TipsOnOffButton").value = "Turn Help Off";

  $('RSCountPlace').up().setStyle({ 'max-width': '22em', 'overflow-wrap': 'break-word', 'word-wrap': 'break-word', 'word-break': 'break-all' });

    // make a handler for the form-changed event; if the form changes, we want to set a flag that enables the beforeunload handler;
    // initially disable the beforeunload handler
    $('FileUploadFormID').observe('change', function(event) { $('FileUploadFormID').store({ 'beforeunloadEnabled': true }); });
    $('FileUploadFormID').store({ 'beforeunloadEnabled': false });

    // protect from back button
    setInterval(ON_BEFORE_UNLOAD_FXN, 500);

    // start periodic function to update active HTTP requests counter
    setInterval(UPDATE_HTTP_REQUEST_COUNT, 500);

    set_eb_state_disabled(false);
    check_for_cancel_enabled_shortcut();

  window.focus();
  }

function ReInitPage()
  {
  Cookie.setData("state", 0);
  OnLoadInit();
  }

function MainTips(tipstyle)
  {
  if (TipsCreated == 0)
    {
    new Tip('RecordFromFileHelp','Allows user to provide a RecordSet list in a file.  ' +
        'The file should contain recordSet specifiers in the format allowed by drms_open_records include files.  ' +
        'See http://jsoc.stanford.edu/jsocwiki/AllAboutJsocNames.',tipstyle);
    new Tip('RecordSetHelp','RecordSet to be exported. May be imported on call and/or may be entered directly here. ' +
        'May be filled in by series select in Im_patch processing option.',tipstyle);
    new Tip('CallLookdataHelp','Start lookdata.html in a different tab/window with RecordSet given.  ' +
        'If a JSOC Lookdata window already exists, the first one will be replaced by this call.',tipstyle);
    new Tip('RecordLimitHelp','RecordSet record limit. Max number of records to export.  Modifies RecordSet. ' +
        'Value should be "none" or a number. Number > 0 counts from start of RecordSet.  Negative number counts ' +
        'from high end of RecordSet.  0 means no limit',tipstyle);
    new Tip('RecordCountHelp','RecordSet record count.  Update this to repeat export with new method, email, etc.  ' +
        'There is presently a limit to the memory space allocated for record queries which restricts AIA lev1 ' +
        'requests to about 15,000 records and HMI X_45s or X_720s data to about 32,000 records.  ' +
        'The limit depends on number of keywords in each record.  This limit will be eased in the future.',tipstyle);
    new Tip('MethodHelp','Handshake method to be used in the process of doing the export and to fetch the data files. ' +
        '"url-quick" is the fastest but can only be used if the data is online and will be exported "as-is". ' +
        '"url-direct" is has the constraints of url_quick with the limit of one file per request but it will ' +
        'automatically do the postprocessing specified in the "protocol" instruction. For "url_direct" the file ' +
        'is returned directly to your browser rather than returning to the export page.  If you have the ' +
        'set to load some fits reader program when the mime-ype "fits" is encountered you will see the image promptly. ' +
        '"url" will result in a temporary directory being created and the URL to that directory be returned to you after ' +
        'a handshake process using the RequestID provided. ' +
        '"ftp" is like "url" but the returned links will be to an ftp directory. ' +
        ' A "-tar" suffix will cause a tar of all files in the request to be included with the separate files. ' +
        'NOTE: do not use "-tar" unless you really need it since that will generate an extra copy of the data.',tipstyle);
    new Tip('FilenameFmtHelp','Filename format to be used in the process of doing the export.  ' +
        'The filename format is a template used to construct a filename for each segment of each record requested.  ' +
        'The template consists of literal characters and substitution tokens enclosed in "{}".  ' +
        'The special words: seriesname, recnum, and segment are replaced with the series_name, the record number, ' +
        'or the segment name.  The element {#} will generate an increasing number, ' +
        'with optional layout e.g. default is {#:%05d}. ' +
        'Any keyword in the record may also be used.  Optional layout may be provided after a ":".' +
        'Special format options are available for type TIME keywords: A leading "A" will strip "." and ":" from the time and ' +
        'a "D" will strip the "." and ":" but will insert "@" around the date components to allow easy scripts ' +
        'to move the exported files into date structured directory trees. ' +
        'It is wise to include enough of the "prime-keys" to make a unique filename.  ' +
        'The default format template is made from series structure.',tipstyle);
    new Tip('ProcessingHelp','Processing to be done to the data prior to export. ' +
        ' Select from drop-down list for details.',tipstyle);
    new Tip('ProtocolHelp','Data storage protocol for data files to be fetched.  ' +
        '<br>"Fits" causes the data to be converted to full fits files with header information filled from the DRMS records.  ' +
        '<br>"As-is" leaves the data as it is used inside the JSOC DRMS system, ' +
        'with the header metadata stored in the database rather than with the data file.  ' +
        '"As-is" is faster since the data does not need to be rewritten.  In as-is mode the header data is ' +
        'provided in a tab-delimited file named {RequestID}.keywords.txt. <br> The "jpeg" option will ' +
        ' yield  jpeg images of the data and the <br>"mpg" or "mp4" options will ' +
        ' yield a movie along with the jpeg images that make up the frames in the movie.<br> ' +
        'Default colortables and scaling for protocols making images are provided but may be altered.',tipstyle);
    new Tip('CompressHelp','Compression parameters to be used by the cfitsio library.  ' +
        'One comma separated string for each segment name in your export will be generated. ' +
        'Use "**NONE**" to indicate uncompressed FITS files desired. ' +
        'Note that e.g. AIA data can be more than 5 times larger if not compressed.  Do not request uncompressed ' +
        'exports for more than a few files.',tipstyle);
    new Tip('RequestorHelp','Optional place for your name, this will be used later when we have a way of saving your ' +
        'preferred export options.  This value will be saved in a Cookie if allowed.',tipstyle);
    new Tip('NotifyHelp','Email address to be used to notify you when the export is complete and ready to be ' +
        'fetched using the RequestID. NOTE - an email address is required for exports from jsoc2.',tipstyle);
    new Tip('SendFileHelp','This action will submit the export request with the RecordSet specified in the upload file.',tipstyle);
    new Tip('CheckParamHelp','This button is required to verify all fields used to specify the export request ' +
        'have been filled in in a consistent way.  If all is OK, the Submit button will be enabled.  A new Check ' +
        'button press is required before each export request.',tipstyle);
    new Tip('SubmitHelp','This button does the actual export request submission.  After a submit request the button ' +
        'action is changed to a Status Request which can be used to get the response from JSOC.  For all but url-direct and ' +
        'url-quick methods a RequestID tag will be returned a few seconds after a submit request.  ' +
        'This tag will be used to identify ' +
        'your export request inside JSOC and may be used at a later time to request the processing status and to ' +
        'obtain a link to your data.',tipstyle);
    new Tip('FetchCheckboxHelp','When this box is checked, the URL string that will be sent to the JSOC jsoc_fetch ' +
        'command will be shown when the "Check Params for Export" button is pressed.  This string can be used to ' +
        'help you develop script driven exports and to see how exportdata functions.',tipstyle);
    }
  };

</script>
<script type="text/javascript" src="exportdata.d/addOnTips.js"></script>
<script type="text/javascript">

function CreateTips()
  {
  var tipstyle =
    {
    style:'protoblue',
    hook:{target:'topRight',tip:'bottomLeft'},
    stem:'bottomLeft',
    closeButton:false,
    hideAfter:5,
    hideOn:'click',
    showOn:'click',
    border:3,
    radius:3,
    width:300,
    };

  MainTips(tipstyle);
  AddOnTips(tipstyle, Tip);
  TipsCreated = 1;
  $$("span.tip").each(function(showspan){showspan.show();});
  }

function HideTips()
  {
  $$("span.tip").each(function(hidespan){hidespan.hide();});
  Tips.hideAll();
  }

function ToggleHelp()
  {
  if (TipsEnabled)
    {
    HideTips();
    $("TipsOnOffButton").value = "Turn Help On";
    TipsEnabled = 0;
    }
  else
    {
    CreateTips();
    $("TipsOnOffButton").value = "Turn Help Off";
    TipsEnabled = 1;
    }
  }

// Check list of seriesnames for which processing options are not available for SeriesName spec given
function CheckNoProcessingList()
  {
  var n = NoProcessingList.length;
  var i;
  var result = 1;
  var prior = ProcessingAllowed;
  for (i=0; i<n; i++)
    {
        if (SeriesName == NoProcessingList[i])
        {
            result = 0;
            break;
        }
    }
  ProcessingAllowed = result;
  if (ProcessingAllowed != prior)
    ProcessingEnabled();
  }

function FileUploadCleanup()
  {
  ExportQueryOK = 0;
  $("ExportRecordSet").value = "";
  ExportRecordSetOK = 0;
  ExportFromFileList = 0;
  $("FileUploadCheckbox").checked = 0;
  $("RSCountPlace").innerHTML = "";
  $("ExportButton").value = "Submit Export Request";
  $("AjaxExportRequestRow").style.display="table-row";
  $("FileUploadInfoRow").style.display="none";
  $("RecordSetRow").style.display="table-row";
  $("RecordCountRow").style.display="table-row";
  $("ExportOpID").value = "exp_request";
  }

function FileUploadWanted()
{
    // dirty since last time the CP button was clicked
    set_eb_state_disabled(true);

    ExportQueryOK = 0;
    if (ExportFromFileList == 0)
    {
        $("ExportRecordSet").value = "*file*";
        ExportRecordSetOK = 1;
        ExportFromFileList = 1;
        $("FileUploadCheckbox").checked = 1;
        $("RecordSetRow").style.display="none";
        $("RecordCountRow").style.display="none";
        $("ExportOpID").value = "exp_request";
        $("FileUploadRow").style.display="table-row";
        $("FileUploadInfoRow").style.display="none";
        $("AjaxExportRequestRow").style.display="none";
    }
    else
    {
        $("FileUploadInfoRow").style.display="none";
        FileUploadCleanup();
        FinishFileUpload();
    }
}

function insertOption(list,text,note)
  {
  var y=document.createElement('option');
  y.value=text;
  if (note.length)
    y.text = text + "  --- " + note;
  else
    y.text = text;
  var x = $(list);
  try
    {
    x.add(y,null); // standards compliant
    }
  catch(ex)
    {
    x.add(y); // IE only
    }
  }

function MakeFileUploadRequest()
  {
  if (CheckExportParams() == 0)
    return;
  uploadOndoneAction = 1;
// XXXX fix compression here
  $("FileUploadFormID").action = 'http://' + Host + '/cgi-bin/ajax/' + JSOC_FETCH;
  $("FileUploadFormID").submit();
  }

function uploadDone()
  { //Function will be called when iframe is loaded
  if (uploadOndoneAction == 1)
    {
    var response = window.frames[0].document.getElementsByTagName("body")[0].innerHTML;
    var status = ProcessExportResponse(response);
    var op = "exp_upload";
    uploadOndoneAction = 0;
    }
  }

function FinishFileUpload()
  {
  window.frames[0].document.getElementsByTagName("body")[0].innerHTML = "";
  $("FileUploadRow").style.display="none";
  uploadOndoneAction = 0;
  }

function CallLookdata()
  {
  var recset = $("ExportRecordSet").value;
  var posbracket = recset.indexOf("[");
  var posRbracket = recset.lastIndexOf("]");
  var posCurlbracket = recset.indexOf("{");
  var firstbracket = posbracket>=0 ? posbracket : posCurlbracket;
  var seriesname = (firstbracket == -1 ? recset : recset.substring(0,firstbracket));
  var recfilt = (posbracket >=0 ? recset.substring(posbracket,posRbracket+1) : "");
  var lookdataargs="ds="+seriesname;

  if (recfilt.length > 0)
    {
        // This is the filter used to select a series in lookdata.html, step 1.
        lookdataargs += "&rs=" + recfilt
    }

    // I guess the RecordCount can never be negative.
    if (RecordCount !== null && RecordCount > 0)
    {
        lookdataargs += "&n=" + RecordCount.toString();
    }

  LookdataWindow=window.open("http://" + Host + "/ajax/" + LOOKDATA + ".html?" + encodeURIComponent(lookdataargs), "JSOC Lookdata");
  LookdataWindow.window.focus();
  }

var RSCountActiveMSg = "Getting count - wait...";

// Class
function WlSeriesInfo()
{
}

// Parse record-set specification (spec) to get a list of all series names in the spec. This function sends that list to the WlSeriesInfo.getServer() method.
// THAT method finds out which database server contains the DRMS series information.
// To use extract names, do this.
// This callback assumes that you want to call the getServer method in the 'this' object (an instance of the WlSeriesInfo class).
// So if you want to call extractSnames from outside of the 'this' object, you have to create a wrapper in WlSeriesInfo, then
// instantiate it (outside of 'this') with var wlInfo = new WlSeriesInfo(), then call the wrapper wlInfo.wrapper(args).
// So put the following into WlSeriesInfo.prototype.wrapper:
// var getServerFnArgs = {};
// getServerFnArgs.cbfn = callback;
// getServerFnArgs.cbargs = callbackArgs;
// var extractSnamesFnArgs = {};
// extractSnamesFnArgs.cbfnobj = this;
// extractSnamesFnArgs.cbfnobjmeth = 'getServer';
// extractSnamesFnArgs.cbargs = getServerFnArgs;
// extractSnamesFnArgs.args = [spec];
// this.extractSnames(extractSnamesFnArgs);
WlSeriesInfo.prototype.extractSnames = function(args)
{
    var spec = args.args[0];
    var callbackObj = args.cbfnobj;
    var callbackObjMeth = args.cbfnobjmeth; // getServer
    var callbackArgs = args.cbargs;
    var snames = [];

    new Ajax.Request('http://' + Host + '/cgi-bin/' + PARSE_RECSET,
    {
        method: 'get',
        parameters: { "spec" : spec },
        onSuccess: function(transport, json)
        {
            var response = transport.responseText || null;
            var parseInfo = response.evalJSON();

            if (parseInfo.subsets.length > 0)
            {
                for (var iset = 0; iset < parseInfo.subsets.length; iset++)
                {
                    snames[snames.length] = parseInfo.subsets[iset].seriesname;
                }
            }
            else
            {
                alert("Invalid record-set specification: '" + spec + "'.")
            }

            callbackArgs.args = [spec, snames];
            callbackObj[callbackObjMeth](callbackArgs);
        },
        onFailure: function() { alert('Unable to parse record-set specficiation ' + "'" + spec + "'."); },
        onComplete: function() { }
     });
};

function CreateParseSpecResponse(processSpec)
{
    var parseSpecResponseCallback = processSpec;

    var ParseSpecResponse =
        function(transport)
        {
            var response = transport.responseText;
            var data = null;
            var errMsg = null;

            if (response && response.length)
            {
                data = response.evalJSON();
            }
            else
            {
                data = { 'status' : 1, 'errMsg' : 'invalid parserecset response' };
                errMsg = 'invalid parserecset response';
            }

            // data contains parsed spec data; use it
            // callback closure
            if (parseSpecResponseCallback !== null)
            {
                parseSpecResponseCallback(errMsg, data);
            }
        };

    return ParseSpecResponse;
}

function ParseSpec(spec, processSpec)
{
    var onSuccess = CreateParseSpecResponse(processSpec);
    var url = null;
    var origin = null;

    origin = ExportOrigin(null, Host.toLowerCase())

    if (origin[0] == 'extServer')
    {
        url = 'http://' + EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + '/cgi-bin/' + PARSE_RECSET;
    }
    else
    {
        url = 'http://' + INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + '/cgi-bin/' + PARSE_RECSET;
    }

    new Ajax.Request(url,
    {
        'method' : 'get',
        'parameters' : { 'spec' : spec },
        'onSuccess' : onSuccess,
        'onFailure' : function() { $("RSCountPlace").innerHTML = 'ERROR - unable to parse record-set specification ' + spec; $('ExportRecordSet').disabled = false; set_eb_state_disabled(true); },
        'onComplete' : function() { }
    });
}

// callback is processRecordCount
function CreateRequestRSInfoCallback(callback, lastRecord)
{
    var processRSInfo =
        function(transport)
        {
            var response = transport.responseText;

            if (response && response.length)
            {
                var data = response.evalJSON();

                if (!data || !data.hasOwnProperty('status') || data.status != 0)
                {
                    errMsg = 'failure running jsoc_info';
                    if (data.hasOwnProperty('error'))
                    {
                        errMsg = data.error;
                    }
                    RecordCount = null; // global
                    $('ExportRecordSet').store({ 'count': RecordCount });
                    $("RSCountPlace").innerHTML = errMsg;
                    ExportRecordSetOK = 0; // global
                    SeriesName = ''; // global

                    if (callback !== null)
                    {
                        callback(errMsg);
                    }
                }
                else
                {
                    var aiaScaleCompatibilityChecked = false;

                    RecordCount = data.count; // global
                    $('ExportRecordSet').store({ 'count': RecordCount });
                    $("RSCountPlace").innerHTML = data.count;
                    ExportRecordSetOK = 1; // global

                    aiaScaleCompatibilityChecked = ($('OptionAiaScale').retrieve('disabled_state', null) !== null);

                    // check for compatibility with aia_scale processing

                    // aia_scale compatibility has not yet been determined; check now
                    // loop through all records, checking the keyword criteria; jsoc_info
                    // does not provide hash-accessibility to keyword info, so must
                    // loop through all keywords
                    var compatible = null;
                    var online = null;
                    var size = null;

                    if (data.hasOwnProperty('keywords'))
                    {
                        var ctype1Checked = false;
                        var ctype2Checked = false;

                        if (aiaScaleCompatibilityChecked)
                        {
                            ctype1Checked = true;
                            ctype2Checked = true;
                        }
                        else
                        {
                            compatible = true;
                        }

                        for (var index = 0; index < data.keywords.length; index++)
                        {
                            // we are assured that the CTYPE keywords will be in the jsoc_info results,
                            // even if the series does not have those keywords; if a keyword
                            // does not exist in the series, jsoc_info prints 'Invalid Keylink'
                            // for the keyword value (as long as the keyword is specified in the keys argument
                            // to jsoc_info)
                            if (compatible && !ctype1Checked && data.keywords[index].name.strip().toLowerCase() == KEYWORD_CTYPE1.toLowerCase())
                            {
                                for (var valIndex = 0; compatible && valIndex < data.keywords[index].values.length; valIndex++)
                                {
                                    // loop over records
                                    if (data.keywords[index].values[valIndex] != AIA_SCALE_CTYPE1)
                                    {
                                        compatible = false;
                                        break;
                                    }
                                }

                                ctype1Checked = true;
                            }

                            if (compatible && !ctype2Checked && data.keywords[index].name.strip().toLowerCase() == KEYWORD_CTYPE2.toLowerCase())
                            {
                                for (var valIndex = 0; compatible && valIndex < data.keywords[index].values.length; valIndex++)
                                {
                                    // loop over records
                                    if (data.keywords[index].values[valIndex] != AIA_SCALE_CTYPE2)
                                    {
                                        compatible = false;
                                        break;
                                    }
                                }

                                ctype2Checked = true;
                            }

                            // check to see if all SUs are online
                            if (online === null && data.keywords[index].name.strip().toLowerCase() == KEYWORD_ONLINE.toLowerCase())
                            {
                                online = true;

                                for (var valIndex = 0; valIndex < data.keywords[index].values.length; valIndex++)
                                {
                                    // loop over records
                                    if (data.keywords[index].values[valIndex].toLowerCase() != 'y')
                                    {
                                        online = false;
                                        break;
                                    }
                                }
                            }

                            if (size === null && data.keywords[index].name.strip().toLowerCase() == KEYWORD_SIZE.toLowerCase())
                            {
                                size = 0;

                                for (var valIndex = 0; valIndex < data.keywords[index].values.length; valIndex++)
                                {
                                    // loop over records
                                    size += data.keywords[index].values[valIndex];
                                }
                            }

                            if (ctype1Checked && ctype2Checked && online !== null && size != null)
                            {
                                break;
                            }
                        }
                    }
                    else if (!aiaScaleCompatibilityChecked)
                    {
                        // no keyword information was returned by jsoc_info, so we cannot tell if this series;
                        // this happens if no rows were returned
                        compatible = false;
                    }

                    if (!aiaScaleCompatibilityChecked)
                    {
                        // we definitively know whether or not aia_scale processing should be disabled
                        if (compatible)
                        {
                            $('OptionAiaScale').store({ 'disabled_state' : false });
                        }
                        else
                        {
                            $('OptionAiaScale').store({ 'disabled_state' : true });
                        }
                    }

                    if (online)
                    {
                        $('ExportRecordSet').store({ 'allSUsOnline' : true });
                    }
                    else
                    {
                        $('ExportRecordSet').store({ 'allSUsOnline' : false });
                    }

                    $('ExportRecordSet').store({ 'sizeSU' : size });

                    if (!$('OptionAiaScale').retrieve('disabled_state', false))
                    {
                        // this series' first segment has a 2D-image with a CTYPE1 value of 'HPLN-TAN' and a CTYPE2 value of 'HPLT-TAN' so
                        // it is compatible with aia_scale processing; the code to determine this is split between processSeriesSelection and
                        // processRSInfo

                        // this should remain disabled until all asynchronous processing completes
                        $('OptionAiaScaleLabel').innerHTML = 'aia_scale - Scale image to 0.6 arcsec/pixel';
                        $('OptionAiaScaleLabel').setStyle({ color: 'black' });

                        // the determination of which aia_scale proc to use was already determined; in processSeriesSelection()
                        // a check of the LVL_NUM keyword was performed; this keyword must be constant, since a series cannot be
                        // a mix of levels
                        if (IsAiaLev1 === null && IsAia)
                        {
                            if (data.hasOwnProperty('keywords'))
                            {
                                for (var index = 0; index < data.keywords.length; index++)
                                {
                                    // loop over keywords
                                    if (data.keywords[index].name.strip().toLowerCase() == KEYWORD_LVL_NUM.toLowerCase())
                                    {
                                        IsAiaLev1 = true;

                                        for (var valIndex = 0; valIndex < data.keywords[index].values.length; valIndex++)
                                        {
                                            // loop over records (one value element per DRMS record)
                                            var lvlnumString = data.keywords[index].values[valIndex];
                                            var lvlnum = null;

                                            // the series has a LVL_NUM constant keyword
                                            // round so we can compare floats
                                            lvlnum = Math.floor(10 * (parseFloat(lvlnumString) + 0.02)); // level numbers should be much farther apart than 0.02

                                            if (lvlnum != 10)
                                            {
                                                /* this is NOT an aia lev1 series */
                                                IsAiaLev1 = false;
                                                break;
                                            }
                                        }

                                        break; // look only at the LVL_NUM keyword
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        // not compatible with aia_scale processing

                        // this should remain disabled until all asynchronous processing completes
                        $('OptionAiaScaleLabel').innerHTML = 'aia_scale - Scale image to 0.6 arcsec/pixel (compatible with 2D dataseries with CTYPE1 == HPLN-TAN and CTYPE2 == HPLT-TAN only)'
                        $('OptionAiaScaleLabel').setStyle({ color: 'grey' });

                        // uncheck the aia_scale checkbox if it is currently checked
                        if ($('OptionAiaScale').checked)
                        {
                            $('OptionAiaScale').checked = false;
                        }
                    }

                    // if the user has specified the current record with [$], then replace [$] with the record-specification
                    if (lastRecord && data.hasOwnProperty('keywords'))
                    {
                        for (var index = 0; index < data.keywords.length; index++)
                        {
                            if (data.keywords[index].name.strip().toLowerCase() == '*spec*' && data.keywords[index].values.length == 1)
                            {
                                $("ExportRecordSet").value = data.keywords[index].values[0];
                                break;
                            }
                        }
                    }
                }
            }
            else
            {
                errMsg = 'invalid jsoc_info response';
                RecordCount = null;
                $('ExportRecordSet').store({ 'count': RecordCount });
                $("RSCountPlace").innerHTML = errMsg;
                ExportRecordSetOK = 0; // global
                SeriesName = ''; // global

                if (callback !== null)
                {
                    callback(errMsg);
                }
            }

            if (callback !== null)
            {
                var errMsg = null;

                if (!ExportRecordSetOK)
                {
                    errMsg = $("RSCountPlace").innerHTML;
                }

                callback(errMsg);
            }
        };

    return processRSInfo;
}

// callback is processRecordCount
function CreateObtainFastRecordCountCallback(callback)
{
    // assuming that we have not already gotten the record count
    var obtainFastRecordCount =
        function(transport)
        {
            var response = transport.responseText;

            if (response && response.length)
            {
                var data = response.evalJSON();

                if (!data || !data.hasOwnProperty('status') || data.status != 0)
                {
                    errMsg = 'failure running jsoc_info';
                    if (data.hasOwnProperty('error'))
                    {
                        errMsg = data.error;
                    }

                    RecordCount = null; // global
                    $('ExportRecordSet').store({ 'count': RecordCount });
                    $("RSCountPlace").innerHTML = errMsg;
                    ExportRecordSetOK = 0; // global

                    if (callback !== null)
                    {
                        callback(errMsg);
                    }
                }
                else
                {
                    RecordCount = data.count; // global
                    $('ExportRecordSet').store({ 'count': RecordCount });
                    $("RSCountPlace").innerHTML = data.count;
                    ExportRecordSetOK = 1; // global
                }
            }
            else
            {
                errMsg = 'invalid jsoc_info response';
                RecordCount = null;
                $('ExportRecordSet').store({ 'count': RecordCount });
                $("RSCountPlace").innerHTML = errMsg;
                ExportRecordSetOK = 0; // global

                if (callback !== null)
                {
                    callback(errMsg);
                }
            }

            if (callback !== null)
            {
                var errMsg = null;

                if (!ExportRecordSetOK)
                {
                    errMsg = $("RSCountPlace").innerHTML;
                }

                callback(errMsg);
            }
        };

    return obtainFastRecordCount;
}

// if errMsg, then do not call jsoc_info, but we still have to call the callback (which is processRecordCount)
function ObtainFastRecordCount(errMsg, spec, callback)
{
    var arguments = null;
    var jsocinfoCGI = null;
    var host = null;

    if (errMsg && errMsg.length != 0)
    {
        if (callback !== null)
        {
            callback(errMsg);
        }
    }
    else
    {
        // if this is the external host, then use jsocinfointext; this CGI will choose the correct db server to handle the series;
        // if this is the internal host, then use jsoc_info, which will use the internal db server; Host, RecordLimit and EXTERNAL_SERVER
        // are globals
        host = Host.toLowerCase();
        if (serverMap[host] == INTERNAL_SERVER)
        {
            jsocinfoCGI = JSOC_INFO;
            arguments = { 'ds' : spec, 'n' : RecordLimit, 'op' : 'rs_summary' };
        }
        else
        {
            jsocinfoCGI = JSOCEXTINFO;
            arguments = { 'dbhost' : EXTERNAL_SERVER, 'ds' : spec, 'n' : RecordLimit, 'op' : 'rs_summary' };
        }

        // callback is processRecordCount
        var onSuccess = CreateObtainFastRecordCountCallback(callback);

        new Ajax.Request('http://' + host + '/cgi-bin/ajax/' + jsocinfoCGI,
        {
            'method': 'get',
            'parameters': arguments,
            'onSuccess': onSuccess,
            'onFailure': function() { RecordCount = null; $('ExportRecordSet').store({ 'count': RecordCount }); $("RSCountPlace").innerHTML = 'ERROR - failure calling jsoc_info'; ExportRecordSetOK = 0; SeriesName = ''; $('ExportRecordSet').disabled = false; set_eb_state_disabled(true); },
            'onComplete': function() { }
        });
    }
}

// if errMsg, then do not call jsoc_info, but we still have to call the callback (which is processRecordCount)
function RequestRSInfo(errMsg, spec, lastRecord, callback)
{
    var arguments = null;
    var jsocinfoCGI = null;
    var host = null;

    if (errMsg && errMsg.length != 0)
    {
        if (callback !== null)
        {
            callback(errMsg);
        }
    }
    else
    {
        // if this is the external host, then use jsocinfointext; this CGI will choose the correct db server to handle the series;
        // if this is the internal host, then use jsoc_info, which will use the internal db server; Host, RecordLimit and EXTERNAL_SERVER
        // are globals
        host = Host.toLowerCase();
        if (serverMap[host] == INTERNAL_SERVER)
        {
            jsocinfoCGI = JSOC_INFO;
            arguments = { 'ds' : spec, 'n' : RecordLimit, 'op' : 'rs_list', 'key' : KEYWORD_CTYPE1 + ',' + KEYWORD_CTYPE2 + ',' + KEYWORD_LVL_NUM + ',' + KEYWORD_SPEC + ',' + KEYWORD_ONLINE + ',' + KEYWORD_SIZE };
        }
        else
        {
            jsocinfoCGI = JSOCEXTINFO;
            arguments = { 'dbhost' : EXTERNAL_SERVER, 'ds' : spec, 'n' : RecordLimit, 'op' : 'rs_list', 'key' : KEYWORD_CTYPE1 + ',' + KEYWORD_CTYPE2 + ',' + KEYWORD_LVL_NUM + ',' + KEYWORD_SPEC + ',' + KEYWORD_ONLINE + ',' + KEYWORD_SIZE };
        }

        var onSuccess = CreateRequestRSInfoCallback(callback, lastRecord);

        new Ajax.Request('http://' + host + '/cgi-bin/ajax/' + jsocinfoCGI,
        {
            'method': 'get',
            'parameters': arguments,
            'onSuccess': onSuccess,
            'onFailure': function() { RecordCount = null; $('ExportRecordSet').store({ 'count': RecordCount }); $("RSCountPlace").innerHTML = 'ERROR - failure calling jsoc_info'; ExportRecordSetOK = 0; SeriesName = ''; $('ExportRecordSet').disabled = false; set_eb_state_disabled(true); },
            'onComplete': function() { }
        });
    }
}

// called after the click on "Submit Export Request" button when url_direct is the selected export method
function CreateExportDownloadLink(err, callback)
{
    // extract arguments
    var args = $('ExportRecordSet').retrieve('exportArgs', null);
    var argsStr = null;
    var host = null;
    var drmsexportCGI = null;
    var url = null;
    var linkUrl = null;
    var errMsg = null;

    if (err && err.length > 0)
    {
        errMsg = err;
    }
    else if (args === null)
    {
        errMsg = 'arguments to drms-export CGI missing';
    }
    else
    {
        // XXX check to see if count is null - if so, then run requestRSInfo()
        var count = $('ExportRecordSet').retrieve('count', null);
        var sizeSU = $('ExportRecordSet').retrieve('sizeSU', null);

        Cookie.setData("state", 0);
        Cookie.setData("requestid", "");

        $("ExportButtonMsg").innerHTML = 'Please use the link below to download data prior to initiating a new request';
        $("ExportButton").value = 'Submit Export Request'; // if user clicks, then export-complete message displays
        $("ExportButton").style.backgroundColor = "#D8D8D8"; // grey

        RequestID = 'N/A';
        $("RequestIdPlace").update(RequestID);
        $("RequestIDDesc").update("");
        $("ExportStatus").update("Download size = " + Math.round(10 * sizeSU/1024/1024) / 10 + " MB");

        host = Host.toLowerCase();
        args.dbhost = serverMap[host];
        args.webserver = host;

        argsStr = Object.keys(args).map(function(key) { return key + '=' + encodeURIComponent(args[key]); }).join('&');
        url = 'http://' + host + '/cgi-bin/' + DRMS_EXPORT + '?' + argsStr;

        // make an href - when the user clicks on this link, either a save-file dialog will display or, if the user
        // has set-up their mime-type file association, the file will display in a viewer like ds9
        $('DataLocation').update('Download');

        // disable the beforeunload event handler
        $('ExportLocation').observe('click', function(event) { window.onbeforeunload = null; $('FileUploadFormID').store({ 'beforeunloadOverride' : true }); });
        // make an href - when the user clicks on this link, either a save-file dialog will display or, if the user
        // has set-up their mime-type file association, the file will display in a viewer like ds9
        linkUrl = new Element('a', { 'href' : url } ).update(args.spec);
        $('ExportLocation').update(linkUrl);
    }

    if (callback !== null)
    {
        callback(errMsg);
    }
}

// callback is requestRSInfo
function CreateProcessSeriesSelection(spec, series, seriesNs, callback)
{
    var processSeriesSelection =
        function(transport)
        {
            var response = transport.responseText;

            if (response && response.length)
            {
                var data = response.evalJSON();
                var errMsg = null;

                // check for suitability for aia_scale processing
                if (!data || !data.hasOwnProperty('errMsg'))
                {
                    // unexpected response from seriesinfo.py
                    errMsg = 'unexpected response to series-info request';
                }
                else if (data.errMsg !== null)
                {
                    errMsg = data.errMsg;
                }

                if (errMsg)
                {
                    RecordCount = null; // global
                    $('ExportRecordSet').store({ 'count': RecordCount });
                    $("RSCountPlace").innerHTML = errMsg;
                    ExportRecordSetOK = 0; // global
                    SeriesName = ''; // global

                    // need to call GetRSCount callback by calling the series-selection callback (with an error message)
                    if (callback !== null)
                    {
                        callback(errMsg);
                    }
                }
                else
                {
                    // successfully obtained series info
                    var compatible = null;
                    var keywordsObj = null;

                    for (var segment in data[series.toLowerCase()].segments)
                    {
                        if (data[series.toLowerCase()].segments.hasOwnProperty(segment))
                        {
                            if ((parseInt(data[series.toLowerCase()].segments[segment]['segment-number']) == 0) &&
                                 (parseInt(data[series.toLowerCase()].segments[segment]['number-axes']) != 2))
                            {
                                // we know that aia_scale should definitely be disabled; store that information now so we can skip
                                // the secondary check in processRSInfo
                                $('OptionAiaScale').store({ 'disabled_state' : true });
                                compatible = false;
                                break;
                            }
                        }
                    }

                    keywordsObj = data[series.toLowerCase()].keywords;

                    if (compatible === null)
                    {
                        // compatibility not yet determined
                        if (!keywordsObj.hasOwnProperty(KEYWORD_CTYPE1.toLowerCase()) || !keywordsObj.hasOwnProperty(KEYWORD_CTYPE2.toLowerCase()))
                        {
                            compatible = false;
                        }
                        else
                        {
                            if ((keywordsObj[KEYWORD_CTYPE1.toLowerCase()]['constant-value'] != AIA_SCALE_CTYPE1 &&
                                 keywordsObj[KEYWORD_CTYPE1.toLowerCase()]['constant-value'] != NA) ||
                                (keywordsObj[KEYWORD_CTYPE2.toLowerCase()]['constant-value'] != AIA_SCALE_CTYPE2 &&
                                 keywordsObj[KEYWORD_CTYPE2.toLowerCase()]['constant-value'] != NA))
                            {
                                // we know that aia_scale should definitely be disabled; store that information now so we can skip
                                // the secondary check in
                                $('OptionAiaScale').store({ 'disabled_state' : true });
                                compatible = false;
                            }
                        }
                    }

                    // we can also determine compatibility with the MPT-selection check box
                    if (seriesNs.toLowerCase() == AIA_NAMESPACE)
                    {
                        $('AiaScaleUseMptCheckbox').disabled = false;
                        $('AiaScaleUseMptCheckboxLabel').innerHTML = 'Use a master pointing table to scale images (instead of keyword values)&nbsp';
                        $('AiaScaleUseMptCheckboxLabel').setStyle({ color: 'black' });
                    }
                    else
                    {
                        $('AiaScaleUseMptCheckbox').disabled = true;
                        $('AiaScaleUseMptCheckboxLabel').innerHTML = 'Use a master pointing table to scale images (instead of keyword values - compatible with AIA series only)&nbsp';
                        $('AiaScaleUseMptCheckboxLabel').setStyle({ color: 'grey' });
                    }

                    // finally, if KEYWORD_LVL_NUM is constant in an AIA series, then set the aia_scale processing flag that determines
                    // which aia_scale proc is used
                    if (seriesNs.toLowerCase() == AIA_NAMESPACE)
                    {
                        IsAia = true;

                        if (keywordsObj.hasOwnProperty(KEYWORD_LVL_NUM.toLowerCase()))
                        {
                            var lvlnumString = keywordsObj[KEYWORD_LVL_NUM.toLowerCase()]['constant-value'];
                            var lvlnum = null;

                            if (lvlnumString != NA)
                            {
                                // the series has a LVL_NUM constant keyword
                                // round so we can compare floats
                                lvlnum = Math.floor(10 * (parseFloat(lvlnumString) + 0.02)); // level numbers should be much farther apart than 0.02

                                if (lvlnum == 10)
                                {
                                    /* this is an aia lev1 series */
                                    IsAiaLev1 = true;
                                }
                            }
                        }
                    }

                    if (callback !== null)
                    {
                        callback(null);
                    }
                }
            }
            else
            {
                errMsg = 'unable to obtain series information';
                RecordCount = null; // global
                $('ExportRecordSet').store({ 'count': RecordCount });
                $("RSCountPlace").innerHTML = errMsg;
                ExportRecordSetOK = 0; // global
                SeriesName = ''; // global

                // need to call GetRSCount callback by calling the series-selection callback (with an error message)
                if (callback !== null)
                {
                    callback(errMsg);
                }
            }
        };

    return processSeriesSelection;
}

function RequestSeriesInfo(series, callback)
{
    var onSuccess = callback;
    var url = null;
    var origin = null;

    origin = ExportOrigin(null, Host.toLowerCase())

    if (origin[0] == 'extServer')
    {
        url = 'http://' + EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + '/cgi-bin/' + SERIES_INFO;
    }
    else
    {
        url = 'http://' + INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + '/cgi-bin/' + SERIES_INFO;
    }

    new Ajax.Request(url,
    {
        'method': 'get',
        'parameters': { 'series' : series, 'atts' : 1, 'keys' : '*', 'segs' : '*' },
        'onSuccess': onSuccess,
        'onFailure': function() { RecordCount = null; $('ExportRecordSet').store({ 'count': RecordCount }); SeriesName = ''; ExportRecordSetOK = 0; $("RSCountPlace").innerHTML = 'ERROR - failure calling series-info'; $('ExportRecordSet').disabled = false; set_eb_state_disabled(true); },
        'onComplete': function() { }
    });
}

// callback - called after record-set specification has been successfully parsed (this does not mean that the
// series is valid - it just means the specification has valid syntax); callback is generally processRecordCount
function CreateProcessSpec(spec, fastCallback, callback)
{
    var processSpec =
        function(errMsg, data)
        {
            var errMsgActual = null;
            prefix = 'ERROR - unable to parse record-set specification';

            if (data && data.hasOwnProperty('errMsg') && data.errMsg && data.errMsg.length != 0)
            {
                errMsgActual = prefix + ': ' + data.errMsg;
            }
            else if (errMsg && errMsg.length != 0)
            {
                errMsgActual = prefix + ': ' + errMsg;
            }

            if (errMsgActual)
            {
                RecordCount = null;
                $('ExportRecordSet').store({ 'count': RecordCount });
                ExportRecordSetOK = 0;
                $('RSCountPlace').innerHTML = errMsgActual;

                // if an error occurred, we still need to call the callback callback
                callback(errMsgActual);
            }
            else
            {
                // set SeriesName
                var series = data.subsets[0].seriesname;
                var seriesNs = data.subsets[0].seriesns;
                var validSpec = data.subsets[0].spec;
                var lastRecord = false;

                SeriesName = series; // global
                if (!data.hasfilts && RecordLimit == 0)
                {
                    validSpec = series + '[$]' + (data.subsets[0].segments === null ? '' : data.subsets[0].segments);
                    lastRecord = true;
                }
                else if (data.hasfilts)
                {
                    if (data.subsets[0].filter == '[$]')
                    {
                        lastRecord = true;
                    }
                }

                // store this determination for use later when determining the disabledState of processing steps
                $("ExportRecordSet").store({ 'last_record' : lastRecord });
                $("ExportRecordSet").value = validSpec;

                // use the parsed series name to call the jsocInfoCGI to get the series information;
                // disable the aia_scale processing option if the series selected is not suitable for that
                // processing option; NOTE: the series info might not be sufficient to make this determination;
                // if this is the case, then we need to consult the actual record metadata to do so; check
                // series info first since this is a simpler, quicker test;
                //
                // series suitable for the aia_scale processing option have these properties:
                //   1. They are 2-D time series
                //   2. CTYPE1 == 'HPLN-TAN'
                //   3. CTYPE2 == 'HPLT-TAN'
                //
                // the RequestSeriesInfo callback needs to call RequestRSInfo with callback as the callback

                // if we want the callback to return results quickly, then we need to skip running requestRSInfo() since
                // that could be a slow asynchronous call;
                var actualCB = null;

                if (fastCallback)
                {
                    // we only need to do this if the record count has not yet been obtained
                    actualCB = function(errMsg) { ObtainFastRecordCount(errMsg, validSpec, callback); };

                    // if we have skipped the requestRSInfo callback, then we need to do that later
                }
                else
                {
                    // gets record count too, but could be slow async call
                    actualCB = function(errMsg) { RequestRSInfo(errMsg, validSpec, lastRecord, callback); };
                }

                var processSeriesSelection = CreateProcessSeriesSelection(validSpec, series, seriesNs, actualCB);
                RequestSeriesInfo(series, processSeriesSelection);
            }
        };

    return processSpec;
}

// Internal-DB pass-through.
// If the user is accessing the external website, the database source of the series information could be the internal database.
// External users have access to a sanctioned list of internal data series. So, we do not necessarily want to use the 'Host'
// variable to identify the jsoc_info CGI. If the user is accessing a sanctioned internal series, then we need to use the jsoc_info
// CGI hosted on jsoc2.stanford.edu, not the one on 'Host' (which is jsoc.stanford.edu).
// The callback is optional. Many functions require jsoc_info to have returned before they can continue.
//
// IF THE CALLBACK IS NOT null THEN IT MUST BE CALLED, EVEN ON ERROR; OTHERWISE, CERTAIN GLOBAL VARIABLES
// WILL NOT BE SET APPROPRIATELY
function GetRSCount(countCallback)
{
    ExportQueryOK = 0;
    ExportRecordSetOK = 0;
    SeriesName = "";
    SeriesAttributesGlobal = null;
    $('ExportFilenameFmt').store({ 'originalFormat' : null }); // we have neither determined the original format nor the aia.lev1p5-format yet
    IsAia = null;
    IsAiaLev1 = null;

    var recset = $("ExportRecordSet").value;

    if (recset.length == 0)
    {
        $("RSCountPlace").innerHTML = "ERROR - missing record-set specification.";
        return(1);
    }

    $("RSCountPlace").innerHTML = RSCountActiveMSg;
    // we need not only the series name, but we need the CTYPE1 and CTYPE2 keyword values so that
    // we can determine if the series is suitable for aia_scale processing; from recset, we can
    // extract the seriesname
    var cb = CreateProcessSpec(recset, true, countCallback);
    ParseSpec(recset, cb);

    RecordCount = null; // To indicate that the RecordCount has not been set yet.
    $('ExportRecordSet').store({ 'count': RecordCount });

    return(0);
}

function GetCompatibleFormat(series, attributes, keywords)
{
    var format = null;
    var ipkey;
    var extPrime;
    var dataType;

    if (attributes && keywords)
    {
        format = series;

        for (ipkey = 0; ipkey < attributes.drmsprimekey.length; ipkey++)
        {
            // loop on prime keywords (remove _index from keyword name to HACKILY convert from internal name to external name)
            extPrime = attributes.drmsprimekey[ipkey].replace(/_index/i, '');
            dataType = keywords[extPrime.toLowerCase()]['data-type'].toLowerCase();

            if (dataType == 'time')
            {
                format = format + '.' + '{' + extPrime + ':A}';
            }
            else
            {
                format = format + '.' + '{' + extPrime + '}';
            }
        }

        format = format + '.' + '{segment}';
    }

    return format;
}

function GetDefaultFormat()
{
	// $("RSCountPlace").innerHTML = RSCountActiveMSg; why?
	// RecordCount = null; why?
	var RecordSet = $("ExportRecordSet").value;

	var doInfoReqFn = function()
	{
		var arguments = null;
		var jsocinfoCGI = null;

		// If this is the external host, then use jsocinfointext. This CGI will choose the correct db server to handle the series.
		// If this is the internal host, then use jsoc_info, which will use the internal db server.
		if (serverMap[Host.toLowerCase()] == INTERNAL_SERVER)
		{
			jsocinfoCGI = JSOC_INFO;
			arguments = {"ds" : RecordSet, "op" : "series_struct", "l" : 1 };
		}
		else
		{
			jsocinfoCGI = JSOCEXTINFO;
			arguments = {"dbhost" : EXTERNAL_SERVER, "ds" : RecordSet, "op" : "series_struct", "l" : 1 };
		}

		new Ajax.Request('http://' + Host + '/cgi-bin/ajax/' + jsocinfoCGI,
		{
			method: 'get',
			parameters: arguments,

			onSuccess: function(transport, json)
			{
				var response = transport.responseText || "no response text";
				SeriesInfo = response.evalJSON();
				if (SeriesInfo.status == 0)
				{
					var nprimes = SeriesInfo.primekeysinfo.length;
					var nkeys = SeriesInfo.keywords.length;
					if (nprimes == 0)
					{
						$("ExportFilenameFmt").value = SeriesName + ".{recnum:%lld}.{segment}";
					}
					else
					{
						var newfmt = SeriesName + ".";
						var i;
						for (i=0; i<nprimes; i++)
						{
							var thisprime = SeriesInfo.primekeys[i];
							var j;
							for  (j=0; j<nkeys; j++)
							{
								var thiskey = SeriesInfo.keywords[j].name;
								if (thiskey === thisprime)
								{
									if (SeriesInfo.keywords[j].type === "time")
									{
										newfmt = newfmt + "{" + thisprime + ":A}.";
										if (firstTimePrime ==="") firstTimePrime = thisprime; // firstTimePrime is global
									}
									else
									newfmt = newfmt + "{" + thisprime + "}.";
									break;
								}
							}
						}
						newfmt = newfmt + "{segment}";
						$("ExportFilenameFmt").value = newfmt;
					}
					firstRealSegment = "";
					var nsegs = SeriesInfo.segments.length;
					var recset = $("ExportRecordSet").value;
					var posCurlbracket = recset.indexOf("{");
					var posCurlRbracket = recset.lastIndexOf("}");
					var seglist = ((posCurlbracket >=0 && posCurlRbracket > 0) ? recset.substring(posCurlbracket+1,posCurlRbracket) : "");
                                        var seglistLength = seglist.length;
					var WantedSegments = [];
					if (seglistLength > 0)
					    WantedSegments = seglist.split(",");
					for (var iseg=0; iseg<nsegs; ++iseg)
					    {
                                            if (seglistLength > 0)
                                                {
                                                var thisname = SeriesInfo.segments[iseg].name;
                                                var thisnamearray = [thisname];
                                                var jointnames = WantedSegments.intersect(thisnamearray)
                                                if (jointnames.length == 0)
                                                    continue;
                                                }
					    var thisProtocol = SeriesInfo.segments[iseg].protocol;
						if (thisProtocol === "fits")
						    {
						    firstRealSegment = SeriesInfo.segments[iseg].name;
						    break;
						    }
					    }
				}
				else
				{
					alert('Unable to retrieve series information for record-set ' + RecordSet + '. ' + SeriesInfo.error)
				}
			},
			onFailure: function() { alert('[ GetDefaultFormat ] Something went wrong...'); set_eb_state_disabled(true); },
			onComplete: function() { }
		});
	};

    // Just call the function. It will determine if it should use the internal or external version of the CGI.
    doInfoReqFn();

    if (IsAiaLev1 && (!AiaLev1AttributesGlobal || !AiaLev1KeywordsGlobal))
	{
        // now we have to get the default format information for aia.lev1p5; we only use this information
        // if there is an aia_scale processing step, but do it now since we do not know if the user
        // will check the aia_scale checkbox or not
        var url = null;
        var origin = null;

        origin = ExportOrigin(null, Host.toLowerCase())

        if (origin[0] == 'extServer')
        {
            url = 'http://' + EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + '/cgi-bin/' + SERIES_INFO;
        }
        else
        {
            url = 'http://' + INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + '/cgi-bin/' + SERIES_INFO;
        }

        new Ajax.Request(url,
        {
            'method': 'get',
            'parameters': { 'series' : AIA_LEV1P5, 'atts' : 1, 'keys' : '*' },
            'onSuccess': function(transport)
                         {
                            var response = transport.responseText;

                            if (response && response.length)
                            {
                                var data = response.evalJSON();
                                var errMsg = null;

                                // check for suitability for aia_scale processing
                                if (!data || !data.hasOwnProperty('errMsg'))
                                {
                                    // unexpected response from seriesinfo.py
                                    errMsg = 'unexpected response to series-info request';
                                }
                                else if (data.errMsg !== null)
                                {
                                    errMsg = data.errMsg;
                                }

                                if (errMsg)
                                {
                                    // don't do anything; let the process of getting the aia.lev1p5 format fail
                                    AiaLev1AttributesGlobal = null;
                                    AiaLev1KeywordsGlobal = null;
                                }
                                else
                                {
                                    AiaLev1AttributesGlobal = data[AIA_LEV1P5.toLowerCase()].attributes;
                                    AiaLev1KeywordsGlobal = data[AIA_LEV1P5.toLowerCase()].keywords;
                                }
                            }
                            else
                            {
                                AiaLev1AttributesGlobal = null;
                                AiaLev1KeywordsGlobal = null;
                            }
                        },
            'onFailure': function() { AiaLev1AttributesGlobal = null; AiaLev1KeywordsGlobal = null; set_eb_state_disabled(true); },
            'onComplete': function() { }
        });
    }
}

function CreateDataTable(data, valuetable)
  {
  // valuetable = "";
  // var count = data.count;
  var count = data.data.length;
  valuetable = "<table id='ResultsTable' border='1'>";
  valuetable = valuetable + "<tr><td>File<\/td><td>Record<\/td><td>Filename<\/td><\/tr>";
  for (ifile=0; ifile < count; ifile++)
    {
    valuetable = valuetable + "<tr>";
    valuetable = valuetable +  "<td>" + (ifile + 1) + "<\/td>";
    valuetable = valuetable +  "<td>" + data.data[ifile].record + "<\/td>";
    thisfile = data.data[ifile].filename;
    if (data.method.indexOf("tar") > 0)
      valuetable = valuetable +  "<td>" + thisfile + "<\/td><\/tr>";
    else
      {
      if (data.method.indexOf("ftp") >= 0)
        expURL = "ftp://pail.stanford.edu/export" + data.dir + "/" + thisfile;
      else
        expURL = "https://jsoc1.stanford.edu" + data.dir + "/" + thisfile;
      tmp = "<a href='" + expURL + "' target='_blank'>" + thisfile + "<\/a>";
      valuetable = valuetable +  "<td>" + tmp + "<\/td><\/tr>";
      }
    }
  valuetable = valuetable + "<\/table>";
  return valuetable;
  }

function delete_data_table()
{
    // var su_link = $("StatusDataLocation").select('a')[0];

    // the top section
    $("ExportLocation").innerHTML = "";

    // the table in the lower section ("JSOC Data Export Status and Retrieval")
    $("StatusDataLocation").innerHTML = "";

    $("StatusLocation").innerHTML = "";

    // if (su_link !== null && su_link !== undefined)
    //{
    //    alert('dub');
//
  //      su_link.remove();
    //}
}

function ExportNop()
  {
  }

function ExportRSChanged()
{
    // dirty since last time the CP button was clicked
    set_eb_state_disabled(true);

    ExportQueryOK = 0;
    RecordCount = null; // This will cause the record-count global to be updated later.
    $('ExportRecordSet').store({ 'count': RecordCount });
    $("CountButton").style.backgroundColor = colorYellow;
    ExportNewRS(); // to fix operator not pressing enter or count
  }

// called after the record count is complete (always gets called when the user changes the record-set specification)
function ProcessRSChange(error)
{
    var option_index;
    var processing_option_id;
    var disabled_state_rec_dep;
    var need_rs_info = false;

    // GetDefaultFormat() starts another jsoc_info asnchronously. It sets firstTimePrime. firstTimePrime is used in processing.js.
    // GetDefaultFormat() requires SeriesName, which is set in the first jsoc_info.
    // ProcessRSChange() is now not called until the first jsoc_info has completed.
    if (!error)
    {
        firstTimePrime = ""; // Used in GetDefaultFormat()
        GetDefaultFormat();

        CheckNoProcessingList();
        // NotifyProcessingCode requires the first jsoc_info to have completed (the one started by SetRecordLimit()).
        // It also requires that SetProcessing() has completed its asynchronous running.
        NotifyProcessingCode();

        // check each export processing step's disabled_state (except for processing option 0 - that is no_op)
        for (option_index = 1; option_index < ExportProcessingOptions.length; option_index++)
        {
            processing_option_id = ExportProcessingOptions[option_index].id;
            disabled_state_rec_dep = $(processing_option_id).retrieve('disabled_state_rec_dep', false);

            if (disabled_state_rec_dep)
            {
                // SET disabled state (if it is not set already - null means that true/false value has not yet been determined); the
                // way we do this is to get rs info
                if ($(processing_option_id).retrieve('disabled_state', null) === null)
                {
                    // start asynchronous call to determine the processing option's disabledState value; the record-set will have
                    // already been entered, and the [$] resolved into an actual record specification; this asynchronous call
                    // could take a long time to complete
                    RequestRSInfo('', $("ExportRecordSet").value, $("ExportRecordSet").retrieve('last_record', false), function(errMsg) { $('ProcessingCheckbox').disabled = false; $('ProcessingCheckboxLabel').style.color = 'black'; $('ProcessingCheckboxLabel').style['font-weight'] = 'normal'; $('ProcessingWaitMessage').style.display = 'none'; });
                    need_rs_info = true;
                    break; // call RequestRSInfo 1x
                }
                else
                {
                    $('ProcessingCheckboxLabel').style.color = 'black';
                    $('ProcessingCheckboxLabel').style['font-weight'] = 'normal';
                    $('ProcessingWaitMessage').style.display = 'none';
                }
            }
        }

        if (!need_rs_info)
        {
            // we don't have to wait to enable 'enable processing' checkbox
            $('ProcessingCheckbox').disabled = false;
        }
    }
    else
    {
        // something went wrong; uncheck any processing check boxes that are checked and hide the processing UI
        for (iProc = 0; iProc < ExportProcessingOptions.length; iProc++)
        {
            var ExpOpt = ExportProcessingOptions[iProc];

            $(ExpOpt.id).checked = false;
            if (ExpOpt.id != 'OptionNone' && ExpOpt.hasOwnProperty('rowid'))
            {
                // the 'none' processing step has no processing UI html element
                $(ExpOpt.rowid).style.display = "none";
            }
        }
    }

    update_export_buttons();

    // Re-enable the RecordSet text box.
    $('ExportRecordSet').disabled = false;

    // must set to false every time the user enters a specification, even on error, otherwise the user will never
    // be able to enter a new specification
    newRSRunning = false;
}

// Called when record-set changes, when user clicks on Recount button, when user clicks on enter key in RecordSet field;
var newRSRunning = false;
function ExportNewRS()
{
    // This took forever to figure out. JS event handlers CAN interrupt each other at alert()s.
    // ExportRecordSet has both an onchange and an onclick handler that fire when you click on the Recount
    // button after you enter a record-set specification. As a result, ExportNewRS() is called twice.
    // IFF you have an alert anywhere between the checking for newRSRunning and the setting of
    // newRSRunning in ExportNewRS(), then the onchange handler
    // will be interrupted at the alert() statement, and the onclick handler will run.
    var old_set = null;
    var set_changed = true;

    if (newRSRunning)
    {
        return;
    }
    // NO alert()!
    newRSRunning = true;

    // figure out if the user actually changed the record-set specification
    old_set = $('ExportRecordSet').retrieve('old_set', null);
    if (old_set != null && old_set == $('ExportRecordSet').value)
    {
        set_changed = false;
    }
    else
    {
        // update old_set
        $('ExportRecordSet').store({ 'old_set' : $('ExportRecordSet').value });
    }

    if (set_changed)
    {
        $('OptionAiaScale').store({ 'disabled_state' : null }); // means aia_scale compatibility not determined yet; also
                                                                // means that $('OptionAiaScale') has a disabledState property;
                                                                // changing record-set invalidates the existing validation
    }

    // disable the 'Enable Processing' checkbox - will be enabled once the record-set has been examined for processing-step checkbox
    // disabled state
    $('ProcessingCheckbox').disabled = true;
    $('ProcessingCheckboxLabel').style.color = 'grey';

    // close the processing checkboxes
    $("ProcessingCheckbox").checked = false;
    ProcessingEnabled();

    // display a message notifying user that we are working on enabling processing options (must examine all records)
    $('ProcessingWaitMessage').style.color = colorBrightOrange;
    $('ProcessingWaitMessage').style['font-weight'] = 'bold';
    $('ProcessingWaitMessage').style.opacity = 1.0;
    $('ProcessingWaitMessage').innerHTML = 'Determining applicable processing steps...please wait...';
    $('ProcessingWaitMessage').style.display = 'table-row';

    // disable processing step checkboxes for now, since we are about to change the record-set, and some processing steps
    // need the record-set to be present
    for (iProc = 0; iProc < ExportProcessingOptions.length; iProc++)
    {
        var ExpOpt = ExportProcessingOptions[iProc];
        $(ExpOpt.id).disabled = true;
    }

    SeriesName = "";
    ExportQueryOK = 0;
    $("CountButton").style.backgroundColor = colorNeutral;

    // Disable RecordSet text edit while the asynchronous stuff runs for the newly set record-set.
    $('ExportRecordSet').disabled = true;

    // we changed the record-set - clear out record count
    RecordCount = null
    $('ExportRecordSet').store({ 'count' : null });

    // this is the text after RequestID in the upper section; we just changed the input parameters, so get rid of this
    $("RequestIdPlace").innerHTML = "";

    // remove requestid so that the CP and EB buttons and messages will get reset correctly
    $("StatusRequestID").value = "";

    // get rid of the results tables in the upper and lower sections
    delete_data_table();

    // SetRecordLimit() starts jsoc_info asynchronously (via GetRSCount()).
    if (SetRecordLimit(ProcessRSChange))
    {
        return; // SetRecordLimit calls GetRSCount(), non-zero on RS syntax error
    }
}

function SetRecordLimit(callbackAfterJsocinfo)
{
    var newLimit;

    // dirty since last time the CP button was clicked
    set_eb_state_disabled(true);

    newLimit = 1 * $("ExportRecordLimit").value;
    if (isNaN(newLimit))
    {  // newlimit is a non-numeric string
        newLimit = $("ExportRecordLimit").value;
        if (newLimit == "none")
        {
            RecordLimit = 0;
        }
        else
        {
            $("ExportRecordLimit").style.backgroundColor = colorRed;
            alert("RecordLimit must be a number or 'none'");
            RecordLimit = 0;
        }
    }
    else
    {
        if (newLimit == 0)
        {
            $("ExportRecordLimit").value = "none";
        }

        RecordLimit = newLimit;
    }

    $("ExportRecordLimit").style.backgroundColor = colorWhite;
    return (GetRSCount(callbackAfterJsocinfo));
}

function SetExportMethod(byWhom)
{
    // dirty since last time the CP button was clicked
    set_eb_state_disabled(true);

    // byWhom = 0 for user click, else 1
    if (byWhom == 0)
    {
        ExportQueryOK = 0;
    }

    $("RequestIdPlace").update("");
    $("ExportStatus").update("");
    $("DataLocation").update("Data Location");
    $("ExportLocation").update("");

    ExportMethodValue = $("ExportMethod").options[$("ExportMethod").selectedIndex].value;

    if (ExportMethodValue == "url_direct" || ExportMethodValue == "url_quick")
    {
        ExportMethodOK = 1;

        $("ProcessRow").style.display="none";
        $(ExportProcessingOptions[0].id).checked = true;

        for (var iProc=1; iProc < ExportProcessingOptions.length; iProc++)
        {
            $(ExportProcessingOptions[iProc].id).checked = false;
            $(ExportProcessingOptions[iProc].rowid).style.display = "none";
        }

        if (ExportMethodValue == "url_direct")
        {
            $("ProtocolRow").style.display="table-row";

            // hide export status section - we will display a link only in the SubmitResponseDiv.ExportLocation span
            $('ExportDataDiv').hide()
        }
        else
        {
            $("ProtocolRow").style.display="none";
        }

        $("FilenameFmtRow").style.display="none";
        ExportProtocolValue = "as-is";
        $("ExportProtocol").selectedIndex = 0;
        ExportCompressValue = "";
        $("CompressRow").style.display="none";
        $("RequestorRow").style.display="table-row";
        $("NotifyRow").style.display="table-row";
    }
    else if (ExportMethodValue == "url" || ExportMethodValue == 'ftp' || ExportMethodValue == "url-tar" || ExportMethodValue == 'ftp-tar')
    {
        ExportMethodOK = 1;
        $("ProcessRow").style.display="table-row";
        $("ProtocolRow").style.display="table-row";
        $("FilenameFmtRow").style.display="table-row";
        $("RequestorRow").style.display="table-row";
        $("NotifyRow").style.display="table-row";
        // PHS turn off compression option
        // if(ExportProtocolValue == "FITS")
           // $("CompressRow").style.display="table-row";

        // show export status section
        $('ExportDataDiv').show();

        if (byWhom == 0)
        {
            $("ExportCompress").selectedIndex = 0;
        }
    }
    else
    {
        alert("Please set Method to url_quick, url_direct,  url, or ftp");
        ExportMethodOK = 0;
    }
}


function SetExportFilenameFmt()
{
    // dirty since last time the CP button was clicked
    set_eb_state_disabled(true);

    ExportQueryOK = 0;

    if ($("ExportFilenameFmt").value.length != 0)
    {
        ExportFilenameFmtOK = 1;
    }
    else
    {
        alert("Please set non-empty name for FilenameFmt");
        ExportFilenameFmtOK = 0;
    }
}

// Called after user clicks on 'Enable Processing' checkbox; check the disabledState for all processing steps that
// use the disabledState property
function ProcessingEnabled()
{
    var option_index = 0;
    var processing_option = null;
    var disabled_state = null;

    ExportQueryOK = 0;

    if ($("ProcessingCheckboxHide").checked)
    {
        $("ProcessingCheckbox").checked = false;
    }

    if ($("ProcessingCheckbox").checked)
    {
        // The user enabled processing
        if ($("ExportRecordSet").value == "" || $("ExportRecordSet").value == "[$]")
        {
            $("ProcessingWaitMessage").style.display = "table-row";
            $("ProcessingCheckbox").checked = false;
            return;
        }

        $("ProcessingWaitMessage").style.display = "none";
        $("ProcessingCheckboxHide").checked = false;
        $("ProcessingShowCheckbox").style.display = "none";
        $("ExportProcessing").style.display = "table-row";

        // enable the processing step checkboxes that should be enabled
        for (option_index = 0; option_index < ExportProcessingOptions.length; option_index++)
        {
            processing_option_id = ExportProcessingOptions[option_index].id;

            // if disabled-state metadata do not exist, then set disabled to false (the second arg to retrieve() is the default)
            $(processing_option_id).disabled = $(processing_option_id).retrieve('disabled_state', false);
        }
    }
    else
    {
        // The user disabled processing.
    $(ExportProcessingOptions[0].id).checked = true; // Enable the none processing option.
    $("ExportProcessing").style.display = "none";
    if (ProcessingAllowed == 0)
      {
      $("ProcessingWaitMessage").style.display = "table-row";
      $("ProcessingWaitMessage").innerHTML = "Processing not available for series " + SeriesName;
      $("ProcessingCheckboxHide").checked = true;
      $("ProcessingShowCheckbox").style.display = "none";
      }
    else
      {
      $("ProcessingWaitMessage").style.display = "none";
      $("ProcessingCheckboxHide").checked = false;
      $("ProcessingShowCheckbox").style.display = "table-row";
      }
    SetProcessing(0, null); // Pretend the user clicked on the none processing option.
    }
  }

var SizeRatio;

// Called when a processing-option checkbox has changed, or the record-set query has changed.
// Make the ExportProcessingArgs string (a |-separated list of processing steps).

var setProcessingRunning = false;
var setProcessingQueue = [];

function runSetProcessing(intervalFn, spCallback)
{
    // 0 if no procesing enabled (Enable Processing is not checked),  -1 if same seriesname, -2 if series has changed between export processing requests.
    // ichecked > 0 if the user clicks on/off a processing-step checkbox.
    if (setProcessingRunning)
    {
        // do not clear interval, this will continue to run until it is safe to run the code in the rest of the function
		return;
	}

    // No alerts in here.
	setProcessingRunning = true;

    ichecked = setProcessingQueue.shift()

	if (typeof ichecked == 'undefined')
	{
		// nothing to do; should not get here because each function instance handles one SetProcessing() call
		clearInterval(intervalFn);
		setProcessingRunning = false;
		return;
	}

    ExportQueryOK = 0;

    if (ProcessingAllowed == 0)
    {
        $(ExportProcessingOptions[0].id).checked = true;
    }
    if (ichecked > 0)
    {
        $(ExportProcessingOptions[0].id).checked = false; // Disable the 'none' processing step.
    }

    ExportProcessingOK = null;

    // Add recordLimit FIRST always. Could change when user changes RecordSet specification.
    ExportProcessingArgs = "n=" + RecordLimit;
    var isok = 1;
    var nchecked = 0;
    var iProc = 0;
    var nProcs = ExportProcessingOptions.length;
    SizeRatio = 1.0;

    if ($(ExportProcessingOptions[0].id).checked) // no_op case must be first
    {
        // no_op - none processing checkbox is checked
        nchecked++;
        for (iProc=1; iProc<nProcs; iProc++)
        {
            var ExpOpt = ExportProcessingOptions[iProc];
            $(ExpOpt.id).checked = false;
            $(ExpOpt.rowid).style.display = "none";

            if (ExpOpt.id != "OptionImPatch")
            {
                ExpOpt.Init(1);
            }
        }

        ExportProcessingArgs += "|no_op";
    }
    else
    {
        // no_op - none is NOT checked
        for (iProc=1; iProc<nProcs; iProc++)
        {
            // ExportProcessingOptions is a list of all processing options. The command to perform
            // any given option is sent to jsoc_fetch only if ExportProcessingOptions[iProc].id.checked is true.
            // So, the order of the processing steps is the order they appear in ExportProcessingOptions,
            // which is determined in ProcessingInit() in processing.js.
            var ExpOpt = ExportProcessingOptions[iProc];

            if ($(ExpOpt.id).checked)
            {
                nchecked++;
                $(ExportProcessingOptions[0].id).checked = false; // Do not send the 'none' processing option to jsoc_fetch.

                if (ichecked == -2)
                {
                    // This is the on-load case, where we want to initialize all processing parameters to their defaults.
                    ExpOpt.Init(1);
                    $(ExpOpt.rowid).style.display="table-row";
                    isok = 0;

                    // We need to run the check function for each checked option since we changed the record-set; the
                    // Check() functions always run synchronously; they return the arguments to the processing program;

                    if (ExpOpt.hasOwnProperty('Check') && ExpOpt.Check && typeof ExpOpt.Check === 'function')
                    {
                        ExpOpt.paramsValid = null; // blow-away the cache so Check() can actually do the check and generate the command-line arguments.
                        args = ExpOpt.Check(true);

                        if (args == 'error')
                        {
                            // Error that requires the checkbox to be unchecked.
                            $(ExpOpt.id).checked = false;
                            $(ExpOpt.rowid).style.display = 'none';
                            nchecked--;
                        }
                    }
                }
                else
                {
                    $(ExpOpt.rowid).style.display="table-row";
                    // This is the case where we do not want to reset the processing parameters to the default.
                    ExpOpt.Init(0); // 0 initializes globals needed by Check() functions; initialization is asynchronous, so
                                    // we run a setInterval function below, waiting for completion; the Check() functions can modify the UI
                }
            }
            else
            {
                $(ExpOpt.rowid).style.display="none";

                // keep existing argument values for ImPatch only (the other processing options have no way
                // of resetting them to default values, so we have to do that here if the user has unchecked
                // the option's checkbox
                if (ExpOpt.id != "OptionImPatch")
                {
                    ExpOpt.Init(1);
                }
            }
        }

        if (nchecked > 0)
        {
            // The Set() functions can run asynchronously. We have at least one Set() function that succeeded (which means
            // there could be AJAX running).
            ExportProcessingArgsPoll = setInterval(function(){ GetExportProcessingArguments(spCallback); }, 50);

            // Disable all processing-step checkboxes, until GetExportProcessingArguments() resolves.
            for (iProc = 0; iProc < nProcs; iProc++)
            {
                var ExpOpt = ExportProcessingOptions[iProc];
                $(ExpOpt.id).store({ 'disabled_state' : $(ExpOpt.id).disabled })
                $(ExpOpt.id).disabled = true;
            }
        }
    }

    // it is possible that the aia_scale box was unchecked; in this case, we must restore the original
    // filename format (but only if it indeed was changed to one compatible with aia.lev1p5)
    var originalFormat = $('ExportFilenameFmt').retrieve('originalFormat', null);
    if (originalFormat !== null)
    {
        // the originalFormat value data has been set, so the original format was changed to one compatible with aia.levp5;
        // restore the original if the aia_scale check box is no longer checked
        if ($('OptionAiaScale').checked == false)
        {
            $('ExportFilenameFmt').value = originalFormat;
        }

        // blow away the args-ready state so that Check() is run the next time the user checks the aia_scale checkbox
        ExportProcessingOptions[AiaScaleOption].paramsValid = null;
    }

  if (nchecked == 0)
    {
    $(ExportProcessingOptions[0].id).checked = true; // Set no-op processing step.

    // Hide the non-no-op steps.
    for (iProc=1; iProc<nProcs; iProc++)
    {
        var ExpOpt = ExportProcessingOptions[iProc];
        $(ExpOpt.rowid).style.display = "none";
    }

    ExportProcessingArgs += "|no_op";
    }
  $("ExportSizeRatio").value = SizeRatio;

  $("ExportProcessingHidden").value = ExportProcessingArgs;

    clearInterval(intervalFn);

    if (ExportProcessingArgsPoll)
    {
        // We don't know if export processing is OK yet.
        ExportProcessingOK = false;
        // do not clear the setProcessingRunning flag
    }
    else
    {
        if (isok)
        {
            ExportProcessingOK = true;
        }
        else
        {
            ExportProcessingOK = false;
        }

        setProcessingRunning = false;

        if (spCallback)
        {
            spCallback();
        }
    }
}

// the processing.js code defines SetProcessing as the onChange function for the processing checkboxes
function SetProcessing(ichecked, spCallback)
{
  	var intervalFn;

    // dirty since last time the CP button was clicked
    set_eb_state_disabled(true);

  	setProcessingQueue.push(ichecked)
  	intervalFn = setInterval(function(){ runSetProcessing(intervalFn, spCallback); }, 100);
}

// Cannot determine the arguments at the time that SetProcessing() is called because there might be
// asynchronous processes running (AJAX calls) that need to complete before the arguments can be
// finalized.

// Polling function
function GetExportProcessingArguments(spCallback)
{
    var ExpOpt = null;
    var args = null;
    var iProc = 0;
    var SizeRatio = 1.0;
    var oneChecked = false;

    if (!ExportProcessingArgsReady())
    {
        // Wait till all the Set() procs for each processing step have completed their asynchronous processing.
        return;
    }

    for (iProc = 1; iProc < ExportProcessingOptions.length; iProc++)
    {
        ExpOpt = ExportProcessingOptions[iProc];

        if ($(ExpOpt.id).checked)
        {
            args = ExportProcessingOptions[iProc].Check(true);

            if (args === null)
            {
                // a Set() function is pending; wait until it has completed
                return;
            }

            if (args == 'error')
            {
                // Error that requires the checkbox to be unchecked.
                $(ExpOpt.id).checked = false;
                $(ExpOpt.rowid).style.display = 'none';
                continue;
            }

            oneChecked = true;

            // At this point, we know for sure if there is an error with the export options chosen. If so,
            // ignore that processing step, and uncheck its checkbox.
            if (args.length > 0)
            {
                // args contains all the processing args. ExportProcessingArgs will have n=X already.
                ExportProcessingArgs += "|" + args;
                SizeRatio *= ExpOpt.Size;
            }
        }
    }

    if (!oneChecked)
    {
        $(ExportProcessingOptions[0].id).checked = true; // Set no-op processing step.

        // Hide the non-no-op steps.
        for (iProc = 1; iProc < ExportProcessingOptions.length; iProc++)
        {
            var ExpOpt = ExportProcessingOptions[iProc];
            $(ExpOpt.rowid).style.display = "none";
        }

        ExportProcessingArgs += "|no_op";
    }

    // Re-enable all processing-step checkboxes, until GetExportProcessingArguments() resolves.
    for (iProc = 0; iProc < ExportProcessingOptions.length; iProc++)
    {
        var ExpOpt = ExportProcessingOptions[iProc];

        $(ExpOpt.id).disabled = $(ExpOpt.id).retrieve('disabled_state', false);
    }

    $("ExportSizeRatio").value = SizeRatio;
    $("ExportProcessingHidden").value = ExportProcessingArgs; // Not used.

    clearInterval(ExportProcessingArgsPoll);
    ExportProcessingArgsPoll = null;
    ExportProcessingOK = true; // This means that everything that is going to modify the export arguments has completed
                               // modifying said parameters. It does NOT mean that the parameter values are acceptable.

    setProcessingRunning = false;

    if (spCallback)
    {
        spCallback();
    }
}

function SetExportProtocol(byWhom)
{
    // dirty since last time the CP button was clicked
    set_eb_state_disabled(true);

    // byWhom = 0 for user click, else 1
    if (byWhom == 0)
      ExportQueryOK = 0;
    var ExportProtocolIndex = $("ExportProtocol").selectedIndex;
    ExportProtocolValue = $("ExportProtocol").options[ExportProtocolIndex].value;

    if (ExportProtocolValue == "as-is" || ExportProtocolValue == "FITS")
      { // Handle file protocols
      if (ExportProtocolValue == "as-is")
        {
        ExportProtocolOK = 1;
        $("CompressRow").style.display="none";
        $("ExportProtocolHidden").value = "as-is";
        ExportCompressValue = "";
        }

      else if (ExportProtocolValue == "FITS")
        {
        ExportProtocolOK = 2;
        // PHS hide compression option row
        // $("CompressRow").style.display="table-row";
        $("ExportProtocolHidden").value = "FITS";
        if (byWhom == 0)
          $("ExportCompress").selectedIndex = 0;
        var ExportCompressIndex = $("ExportCompress").selectedIndex;
        ExportCompressValue = $("ExportCompress").options[ExportCompressIndex].value;
        }
      $("ProtocolImageOptions").style.display="none";
      }
    else
      { // Handle image protocols
      if (ExportProtocolValue == "MPEG")
        {
        ExportProtocolOK = 4;
        $("ProtocolImageOptions").style.display="table-row";
        $("CompressRow").style.display="none";
        $("ExportProtocolHidden").value = "mpg";
        }
      else if (ExportProtocolValue == "MP4")
        {
        ExportProtocolOK = 4;
        $("ProtocolImageOptions").style.display="table-row";
        $("CompressRow").style.display="none";
        $("ExportProtocolHidden").value = "mp4";
        }
      else if (ExportProtocolValue == "JPEG")
        {
        ExportProtocolOK = 3;
        $("ProtocolImageOptions").style.display="table-row";
        $("CompressRow").style.display="none";
        $("ExportProtocolHidden").value = "jpg";
        }
      // ProtocolOptionsSet: 0 if need to set defaults, 1 if defaults, 2 if user changed
      if (ProtocolOptionsSet == 0)
        ProtocolImageInit();
      if (ProtocolOptionsSet > 0)
        ProtocolImageCheck();
      }
}

// This function gets called when the Notify field gets modified [exportdata.html only]
function SetExportNotify(clickedByUser)
{
    var address = $("ExportNotify").value.trim();;
    var requestor = $("ExportRequestor").value.trim();
    var snail_address = null; // no UI yet
    var doValidation = true;
    var valid = false;
    var registration_callback = function()
    {
        update_export_buttons();
        check_for_cancel_enabled_shortcut();
    };

    // dirty since last time the CP button was clicked
    set_eb_state_disabled(true);

    // invalidate address
    $("ExportNotify").store('valid', null);
    $("RequestorMessage").innerHTML = "Provide an optional identifier."
    $("ExportCheckMsg").store('cp_message', null);
    $("ExportNotify").store('error_msg', null);

    if (doValidation)
    {
        valid = ValidateNotificationAddress($("ExportNotify"));
        if (valid)
        {
            $("ExportNotify").store('valid', true);

            // disable the CP button since we are actively checking on the address
            update_export_buttons();

            // check_for_cancel_enabled_shortcut() - see if we can go straight to EB_STATE_CANCEL_ENABLED if
            // the user already has a request pending
            // false --> do registration
            // ART
            // register_address(address.slice(0), requestor, snail_address, $("ExportNotify"), $("ExportCheckMsg"), update_export_buttons, registration_callback);

            check_registration(address, requestor, snail_address, $("ExportNotify"), $("ExportCheckMsg"), update_export_buttons, registration_callback);
        }
    }
}

// SetExportUser is called from change in either the Requester or Notify input text boxes.
// There is no call made to check the validity of the notification email address provided
// however. Instead, the user must click on the "Check Params for Export" button.
// [register_email.html only]
function SetExportUser(clickedByUser)
{
    var requestor = null;
    var address = null;
    var newAddress = null;
    var valid = false;

    // invalidate requestor
    $("ExportRequestor").store('valid', null);

    requestor = $("ExportRequestor").value.trim();
    address = $("ExportNotify").value.trim();

    valid = ValidateExportRequestor($("ExportRequestor"));
    if (valid)
    {
        // used to do spd stuff
    }
}

function SetExportCompress()
  {
  ExportQueryOK = 0;
  var protocolparam = ExportProtocolValue;
  if (protocolparam == "FITS" || protocolparam == "as-is")
    {
    if (ExportRecordSetOK)
      {
      var ExportCompressIndex = $("ExportCompress").selectedIndex;
      ExportCompressValue = $("ExportCompress").options[ExportCompressIndex].value;
      for (var i=0; i < SeriesInfo.segments.length; i++)
        {
        var segtype = SeriesInfo.segments[i].type;
        if (ExportCompressValue == "compress Rice" &&  protocolparam == "FITS" && (segtype == "float" || segtype == "double"))
          protocolparam = protocolparam  + ",**NONE**";
        else if (protocolparam == "FITS")
          // PHS do not allow uncompressed.  13 Nov 2014
          // protocolparam = protocolparam  + "," + ExportCompressValue;
          protocolparam = protocolparam  + "," + "compress Rice";
        }
      $("ExportProtocolHidden").value = protocolparam;
      ExportCompressOK = 1;
      }
    else
      {
      ExportCompressOK = 0;
      }
    }
  }

// Notify and Requestor checking is now in the email registration js script.

function ExportShowQuery()
{
    var args = null;
    var paramString = null;

    if ($("ShowQueryCheckbox").checked)
    {
        args = $('ExportRecordSet').retrieve('exportArgs', null);

        if (args != null)
        {
            paramString = decodeURIComponent(Object.toQueryString(args));
            if (paramString)
            {
                $("ExportParameters").innerHTML = paramString.replace(/&/g,"&amp;");
            }
        }
    }
    else
    {
        $("ExportParameters").innerHTML = "";
    }
}

function disable_input()
{
    $("FileUploadCheckbox").disabled = true;
    $("ExportRecordSet").disabled = true;
    $("ExportRecordLimit").disabled = true;
    $("CountButton").disabled = true;
    $("ExportMethod").disabled = true;
    $("ExportFilenameFmt").disabled = true;
    $("ProcessingCheckbox").disabled = true;
    $("ExportProtocol").disabled = true;
    $("ExportNotify").disabled = true;
}

function enable_input(address_too)
{
    $("FileUploadCheckbox").disabled = false;
    $("ExportRecordSet").disabled = false;
    $("ExportRecordLimit").disabled = false;
    $("CountButton").disabled = false;
    $("ExportMethod").disabled = false;
    $("ExportFilenameFmt").disabled = false;
    $("ProcessingCheckbox").disabled = false;
    $("ExportProtocol").disabled = false;
    if (address_too)
    {
        $("ExportNotify").disabled = false;
    }
}

function set_eb_state_disabled(make_dirty)
{
    var state = null;
    var interval_fn_timer = null;
    var interval_fn_timeout = null;

    if (make_dirty)
    {
        // do not allow the user to change email address at this point (do that on reload)
        $("ExportCheckButton").store({ 'dirty' : true });
    }
    else
    {
        $("ExportCheckButton").store({ 'dirty' : false });
    }

    // the only acceptable states are EB_STATE_DISABLED, EB_STATE_SUBMIT_ENABLED, EB_STATE_PATH, EB_STATE_CANCEL
    state = $("ExportButton").retrieve('state', EB_STATE_DISABLED);

    if (state == EB_STATE_DISABLED)
    {

    }
    else if (state == EB_STATE_SUBMIT_ENABLED || state == EB_STATE_PATH || state == EB_STATE_CANCEL || state == EB_STATE_CANCELED || statue == EB_STATE_TIMEOUT)
    {
        // EB_STATE_SUBMIT_ENABLED - user wants to change input instead of clicking on `submit`
        // EB_STATE_PATH - export request complete, time to reset for the next request
        // EB_STATE_CANCEL - user clicked on `cancel` button, and the export request was canceled
        // EB_STATE_CANCELED - user clicked on `continue` button, and the canceled export request was cleared
        // EB_STATE_TIMEOUT - the export button interval function ran for too long without user intervention,
        //                    (like clicking on the button)

        // clear interval
        interval_fn_timer = $("ExportButton").retrieve('interval', null);
        if (interval_fn_timer !== null)
        {
            clearInterval(interval_fn_timer);
            $("ExportButton").store('interval', null);
        }

        interval_fn_timeout = $("ExportButton").retrieve('interval_timeout', null);;
        if (interval_fn_timeout !== null)
        {
            clearTimeout(interval_fn_timeout);
            $("ExportButton").store('interval_timeout', null);
        }

        $("ExportButton").store('state', EB_STATE_DISABLED);
        // $("ExportCheckMsg").store({ 'cp_message' : '' });
        $("ExportCheckMsg").store('cp_message', null);
    }
    else
    {
        $("ExportCheckMsg").store({ 'cp_message' : 'Cannot change input while state is ' + state });
    }

    update_export_buttons();
}

// update label, color, disabled
function update_export_buttons()
{
    var state = $("ExportButton").retrieve('state', EB_STATE_DISABLED);
    var check_message = $("ExportCheckMsg").retrieve('cp_message', null);
    var addresses = $("ExportNotify").retrieve('addresses', {});
    var address = $("ExportNotify").value.trim();
    var address_valid = null;
    var requestor = $("ExportRequestor").value.trim();
    var requestor_valid = null;
    var error_msg = $("ExportNotify").retrieve('error_msg', null);
    var registration_status = null;
    var checking_registration = null;
    var registration_pending = null;
    var address_registered = null;
    var eb_dirty = $("ExportCheckButton").retrieve('dirty', false); // dirty == false ==> page was reset

    if (state == EB_STATE_DISABLED)
    {
        if (addresses !== null && address.length > 0 && Object.prototype.hasOwnProperty.call(addresses, address) && Object.prototype.hasOwnProperty.call(addresses[address], 'registration_status'))
        {
            registration_status = addresses[address].registration_status;
        }

        if (address.length > 0)
        {
            // after ValidateNotificationAddress(), `valid` element attribute is always set
            address_valid = ($("ExportNotify").retrieve('valid', null) === null) ? ValidateNotificationAddress($("ExportNotify")) : $("ExportNotify").retrieve('valid', false);
        }

        if (requestor.length > 0)
        {
            // after ValidateExportRequestor(), `valid` element attribute is always set
            requestor_valid = ($("ExportRequestor").retrieve('valid', null) === null) ? ValidateExportRequestor($("ExportRequestor")) : $("ExportRequestor").retrieve('valid', false);
        }

        if (address.length > 0 && !address_valid)
        {
            check_message = error_msg;
        }
        else if (requestor.length > 0 && !requestor_valid)
        {
            check_message = requestor_error_msg;
        }

        checking_registration = (registration_status == 'checking') ? true : false
        registration_pending = (registration_status == 'registering' || registration_status == 'pending') ? true : false;
        address_registered = (registration_status !== null && (typeof(registration_status) === 'boolean') && registration_status) ? true : false;

        if ($("ExportCheckButton").retrieve('on_demand', null))
        {
            // on_demand pending-request check happening
            // auto-checking for pending-request to allow user to cancel it before entering a new record-set
            $("ExportCheckButton").style.backgroundColor = colorRed;
            $("ExportCheckButton").value = 'wait...';
            $("ExportCheckButton").disabled = true;
            $("ExportCheckMsg").style.color = colorRealRed;
            $("ExportNotify").disabled = true;
            $("ExportRequestor").disabled = true;

            if (check_message === null)
            {
                check_message = 'Checking for pending request...';
            }
            $("ExportCheckMsg").innerHTML = check_message;
        }
        else
        {
            // no on-demand registration check happening; a user-requested export could be happening, or no address registration/check
            // happening at all (could have completed already, or there never has been  one)
            $("ExportCheckButton").style.backgroundColor = colorYellow;
            // ART
            $("ExportCheckButton").value = address_registered ? 'check parameters' : 'register address';

            if (!address_valid && address.length > 0)
            {
                $("ExportCheckButton").disabled = true;
                $("ExportNotify").disabled = false;
            }
            else if (!requestor_valid && requestor.length > 0)
            {
                $("ExportCheckButton").disabled = true;
                $("ExportRequestor").disabled = false;
            }
            else if ((registration_status !== null && (typeof(registration_status) != 'boolean')) || (error_msg !== null && error_msg.length > 0))
            {
                // an error other than invalid address or requestor syntax
                $("ExportCheckButton").disabled = true;
                $("ExportNotify").disabled = true;
                $("ExportRequestor").disabled = true;

                if (!registration_pending && !checking_registration)
                {
                    $("ExportNotify").disabled = false;
                    $("ExportNotifyMsg").innerHTML = "REGISTRATION FAILURE";
                }
            }
            else
            {
                // no error
                if (registration_pending || checking_registration)
                {
                    $("ExportCheckButton").disabled = true;
                    $("ExportNotify").disabled = true;
                    $("ExportRequestor").disabled = true;
                    $("ExportNotifyMsg").style.color = colorDarkBlue;

                    if (registration_pending)
                    {
                        $("ExportNotifyMsg").innerHTML = "registering...";
                    }
                    else
                    {
                        $("ExportNotifyMsg").innerHTML = "checking...";
                    }
                }
                else
                {
                    $("ExportCheckButton").disabled = false;

                    if (address_registered)
                    {
                        $("ExportNotify").disabled = true;
                        $("ExportRequestor").disabled = true;
                    }
                    else
                    {
                      $("ExportNotify").disabled = false;
                      $("ExportRequestor").disabled = false;
                    }
                }
            }

            $("ExportCheckMsg").style.color = colorRealRed;
            if (check_message === null)
            {
                if (!address_registered)
                {
                    if (address.length == 0)
                    {
                        check_message = 'Please enter an email address in the Notify text box';
                    }
                    else
                    {
                        check_message = 'Click to register email address';
                    }
                }
                else if ($("ExportRecordSet").value.length == 0)
                {
                    check_message = 'Please enter a record-set specification';
                }
                else
                {
                    check_message = 'Click to check export parameters and continue';
                }
            }
            $("ExportCheckMsg").innerHTML = check_message;
        }

        $("ExportButton").style.backgroundColor = colorRed;
        $("ExportButton").value = "not ready"
        $("ExportButton").disabled = true;
        $("ExportButtonMsg").style.color = colorBlack;

        if ($("StatusRequestID").value.length == 0)
        {
            $("ExportButtonMsg").innerHTML = 'Click on "check parameters" first';
        }
        else
        {
            // still finishing a previous export request
            $("ExportButtonMsg").style.color = colorRealRed;
            $("ExportButtonMsg").innerHTML = "Fetch data from the URLs below before starting a new request";
        }

        // check for registration complete
        if (registration_status !== null)
        {
            if (typeof(registration_status) == 'boolean')
            {
                if (registration_status)
                {
                    $("ExportNotifyMsg").style.color = colorDarkGreen;
                    $("ExportNotifyMsg").innerHTML = "REGISTERED";
                    $("ExportNotify").disabled = true;
                    $("ExportRequestor").disabled = true;
                }
                else
                {
                    $("ExportNotifyMsg").style.color = colorDarkRed;
                    $("ExportNotifyMsg").innerHTML = "UNREGISTERED";
                    $("ExportNotify").disabled = false;
                    $("ExportRequestor").disabled = false;
                }
            }
            else if (registration_pending)
            {
                $("ExportNotifyMsg").style.color = colorDarkBlue;
                $("ExportNotify").disabled = true;
                $("ExportRequestor").disabled = true;
                $("ExportNotifyMsg").innerHTML = "registering...";
            }
        }

        enable_input(!eb_dirty && !address_registered);
    }
    else if (state == EB_STATE_ENABLED)
    {
        $("ExportCheckButton").disabled = true;
        $("ExportCheckMsg").style.color = colorBlack;
        if (check_message === null)
        {
            check_message = '';
        }
        $("ExportCheckMsg").innerHTML = check_message;

        $("ExportButton").value = "wait...";
        $("ExportButtonMsg").innerHTML = '';

        // the user has already selected all the export parameters; don't allow them to change them
        disable_input();
    }
    else if (state == EB_STATE_SUBMIT_ENABLED)
    {
        if (check_message === null)
        {
            check_message = '';
        }
        $("ExportCheckMsg").innerHTML = check_message;

        $("ExportButton").style.backgroundColor = colorGreen;
        $("ExportButton").value = "submit";
        $("ExportButton").disabled = false;
        $("ExportButtonMsg").style.color = colorRealRed;
        $("ExportButtonMsg").innerHTML = 'Click to submit export request (or modify input to cancel submission)';

        // allow the user to change the record set (but not the email address)
        enable_input();
    }
    else if (state == EB_STATE_SUBMIT)
    {
        $("ExportButton").value = "wait...";
        $("ExportButton").disabled = true;

        disable_input();
    }
    else if (state == EB_STATE_CANCEL_ENABLED)
    {
        $("ExportCheckButton").disabled = true;
        $("ExportCheckMsg").style.color = colorBlack;
        $("ExportCheckMsg").innerHTML = '';

        $("ExportButton").style.backgroundColor = colorGreen;
        $("ExportButton").value = "cancel";
        $("ExportButton").disabled = false;
        $("ExportButtonMsg").style.color = colorRealRed;
        $("ExportButtonMsg").innerHTML = 'An export request is pending; click to cancel, or wait for completion';

        disable_input();
    }
    else if (state == EB_STATE_PATH)
    {
        $("ExportButton").style.backgroundColor = colorGreen;
        $("ExportButton").value = "get path";
        $("ExportButton").disabled = false;
        $("ExportButtonMsg").innerHTML = 'Click to obtain URL path to exported data';

        disable_input();
    }
    else if (state == EB_STATE_CANCEL)
    {
        $("ExportButton").value = "Wait...";
        $("ExportButton").disabled = true;

        disable_input();
    }
    else if (state == EB_STATE_CANCELED)
    {
        $("ExportButton").style.backgroundColor = colorRed;
        $("ExportButton").value = "canceled";
        $("ExportButton").disabled = false;
        $("ExportButtonMsg").innerHTML = 'Export request canceled; click to continue';
    }
}

// This is a callback function. It is invoked after the email check has completed.
function SetExportParams()
{
    var notificationAddressOK = NotificationAddressRegistered($("ExportNotify"));
    var isOK = ExportRecordSetOK * ExportMethodOK * ExportFilenameFmtOK * ExportProtocolOK * notificationAddressOK;

    if ($("ProcessingCheckbox").checked)
    {
        isOK = isOK * (ExportProcessingOK ? 1 : 0) * (ProcessingOK() ? 1 : 0);
    }

    if (isOK)
    {
        // can set CPE to green and enable EB button
    }
    else
    {

    }

    update_export_buttons();
}

// returns boolean now
function is_ok_to_submit(element, attribute)
{
    var return_messages = false;
    var is_ok = true;
    var address = null;
    var message = null;

    if (element && element !== undefined && attribute && attribute !== undefined)
    {
        return_messages = true;
    }

    if (!NotificationAddressRegistered($("ExportNotify")))
    {
        address = $("ExportNotify").value.trim();
        if (address.length > 0)
        {
            message = 'Email address ' + address + ' is not registered';
        }
        else
        {
            message = 'Please enter email address';
        }

        is_ok = false;
    }

    if (is_ok)
    {
        if (!ExportRecordSetOK)
        {
            message = 'Please enter valid record-set specification';
            is_ok = false;
        }
    }

    if (is_ok)
    {
        if (!ExportMethodOK)
        {
            message = 'Please select export method';
            is_ok = false;
        }
    }

    if (is_ok)
    {
        if (!ExportFilenameFmtOK)
        {
            message = 'Please enter file-name format string';
            is_ok = false;
        }
    }

    if (is_ok)
    {
        if (!ExportProtocolOK)
        {
            message = 'Please select export protocol';
            is_ok = false;
        }
    }

    if (is_ok)
    {
        if ($("ProcessingCheckbox").checked && (!ExportProcessingOK || !ProcessingOK()))
        {
            message = 'Processing details not correct, fix and retry export request';
            is_ok = false;
        }
    }

    if (return_messages)
    {
        element.store(attribute, message);
    }

    return is_ok;
}

function check_for_cancel_enabled_shortcut()
{
    // this is an asyncrhonous check, so we need to have the CP button "wait..." while the check occurs
    // and then call this function back after completion; on_demand attribute:
    //   null/false --> no on_demand check occurring
    //   true --> on_demand check in progress
    if ($("ExportNotify").value.trim().length > 0 && !$("ExportCheckButton").retrieve('on_demand', null))
    {
        // not currently checking pending-user status (on_demand check); and
        // not making an interval check either since the CP button is disabled while that is occuring
        $("ExportCheckButton").store({ 'on_demand' : true });
        update_export_buttons();

        // most likely the email check is already done at this point, but if not, then ...
        // 1. if the email XHR has already begun, then the callback will be repeatedly called
        //    until resolution and caching of the registation status in $("ExportNotify").retrieve('addresses', {});
        // 2. if the email XHR has not already begun (not likely), then it will be started and then the
        //    callback will be executed as in 1.
        //
        // either way, call NotificationAddressRegistered() in the callback until we get an answer, at which point
        // we can then branch to code that either:
        // 1. sets the EB state to EB_STATE_CANCEL_ENABLED (if the email is registered and there is a pending update); we
        //    need to always check the record-set spec - if it is present, then do not change the EB state
        // 2. do not change EB state (the email is not registered - the user will see a message asking them to register one)

        // check for registered email address, then pending user request

        var check_registered_callback_fn = function()
        {
            var address = $("ExportNotify").value.trim();
            var addresses = null;
            var registration_status = null;
            var registered = null;
            var error_msg = null;

            if (!$("ExportCheckButton").retrieve('on_demand', null))
            {
                // we are done, but the callback is still being called by the email-check code
                update_export_buttons();
                return;
            }

            // email address is valid, but is it registered?
            addresses = $("ExportNotify").retrieve('addresses', {});

            if (addresses && addresses.hasOwnProperty(address))
            {
                registration_status = addresses[address].registration_status;
                if (typeof(registration_status) === 'string')
                {
                    if (registration_status == 'registering' || registration_status == 'pending')
                    {
                      alert('should not be here');
                        registered = null;
                    }
                    else if (registration_status == 'timed_out_server')
                    {
                        // registration process timeout (not timeout due to no response from AJAX call)
                        registered = false;
                        error_msg = $("ExportNotify").retrieve('error_msg', null);
                        $("ExportCheckMsg").store('cp_message', error_msg);
                    }
                    else if (registration_status == 'timed_out_client')
                    {
                        // registration process timeout (client did not respond to email in time)
                        registered = false;
                        error_msg = $("ExportNotify").retrieve('error_msg', null);
                        $("ExportCheckMsg").store('cp_message', error_msg);
                    }
                    else if (registration_status == 'error')
                    {
                        registered = false;
                        error_msg = $("ExportNotify").retrieve('error_msg', null);
                        $("ExportCheckMsg").store('cp_message', error_msg);
                    }
                    else
                    {
                        registered = false;
                        $("ExportCheckMsg").store('cp_message', 'Invalid registration status ' + registration_status);
                    }
                }
                else if (typeof(registration_status) === 'boolean')
                {
                    $("ExportCheckMsg").store('cp_message', null);
                    $("ExportNotify").store('error_msg', null);
                    registered = registration_status;
                }
                else
                {
                    registered = false;
                }
            }
            else
            {
                // unless there is some error, eventually addresses will be set
                registered = null;
            }

            update_export_buttons();

            if (registered !== null)
            {
                update_export_buttons();

                // we have an answer (email-registration check is no longer pending)
                if (registered)
                {
                    // now we can check for pending request (on_demand - not interval)
                    var check_pending_fn = CHECK_FOR_PENDING_REQUEST(false);

                    // finally, if the user has a pending request, then we can set up the
                    // normal interval function, starting with EB state EB_STATE_CANCEL_ENABLED
                    var update_state_callback_fn = function()
                    {
                        var state = null;
                        var internal_fn = null;
                        var interval_fn_timer = null;
                        var interval_fn_timeout = null;

                        // we're done performing an on_demand for a pending request
                        $("ExportCheckButton").store({ 'on_demand' : false });

                        state = $("ExportButton").retrieve('state', EB_STATE_DISABLED);;

                        // set-up interval function only if there was in fact a pending request
                        // (which is indicated by the EB state)
                        if (state == EB_STATE_CANCEL_ENABLED)
                        {
                            interval_fn_timer = $("ExportButton").retrieve('interval', null);
                            if (interval_fn_timer === null)
                            {
                                internal_fn = CHECK_FOR_PENDING_REQUEST(true);
                                interval_fn_timer = setInterval(internal_fn, 1000);
                                $("ExportButton").store('interval', interval_fn_timer);
                            }

                            // do not allow the pending-request check to last forever (EB is in EB_STATE_CANCEL_ENABLED)
                            if (interval_fn_timeout !== null)
                            {
                                clearTimeout(interval_fn_timeout);
                            }

                            if (interval_fn_timer !== null)
                            {
                                interval_fn_timeout = setTimeout(function () { $("ExportButton").store('state', EB_STATE_TIMEOUT); set_eb_state_disabled(false);}, 10000);
                                $("ExportButton").store('interval_timeout', interval_fn_timeout);
                            }

                        }
                        else
                        {
                            // tell user to provide record-set specification; this is the normal
                            // behavior that the CP function performs
                        }

                        update_export_buttons();
                    };

                    check_pending_fn(update_state_callback_fn);
                }
                else
                {
                    // we're done - the user is not registered, or an error occurred, so we can't check for a pending request
                    $("ExportCheckButton").store({ 'on_demand' : false });
                    update_export_buttons();
                }
            }
        };

        update_export_buttons();
        startEmailCheck($("ExportNotify"), $("ExportRequestor"), $("ExportCheckMsg"), update_export_buttons, check_registered_callback_fn);
    }
}
// This function is called when the user clicks on the "Check Params for Export"
// button.
// A lot of the calls in this function are asynchronous.
function CheckExportButtonOnClickAction()
{
    var isOK = null;

    // complete the SetProcessing part of this check
    // If there was an error in the processing options, then ExportProcessingOK is not true.
    // ProcessingOK() is synchronous.
    $("ExportCheckMsg").store({ 'cp_message' : null });

    // first deal with missing record-set specification; this is allowed if there is an email address provided
    if ($("ExportRecordSet").value.trim().length == 0 && $("ExportNotify").value.trim().length > 0)
    {
        // let's check for an existing request and allow the user to cancel it if one exists;
        check_for_cancel_enabled_shortcut();
        update_export_buttons();
        return 0; // there is no record-set, so the export parameters are incomplete
    }
    else if (RecordCount === null)
    {
        // deal with bad record-set specification
        $("ExportCheckMsg").store({ 'cp_message' : 'Still counting records; wait a second then retry' });
        update_export_buttons();
        return 0;
    }

    // we've dealt with record-set specification (and possibly email address registration); now deal with the rest;
    // use is_ok_to_submit() to get an error message to display in the CP button message

    // update the UI and internal variables with values the user has chosen
    SetExportMethod(1);
    SetExportFilenameFmt();
    SetExportProtocol(1);

    if ((ExportProtocolValue == "FITS" || ExportProtocolValue == "as-is") && ExportMethodValue != "url_quick")
    {
        SetExportCompress();
    }
    else if (protocolEnable)
    {
        ProtocolImageCheck();
    }

    // This is an asynchronous call, so we need to put the following "isOK" check into a
    // callback function. Return isOK == 0 since we do not know if it is OK to do an export
    // at this point.

    // this may or may not be an asynchronous call; $("ExportNotify").retrieve('valid', false) will either synchronously
    // return the acceptability of the notification address, or it will be updated when the asynchronous call completes;
    // if this is an asynchronous call, then $("ExportNotify").retrieve('valid', false) below will indicate that
    // the notification address is not acceptable, and the user will need to click on "Check Params for Export"
    // again
    if ($("ExportNotify").value.trim().length > 0)
    {
        update_export_buttons();
        startEmailCheck($("ExportNotify"), $("ExportRequestor"), $("ExportCheckMsg"), update_export_buttons, SetExportParams);

        // note - ExportQueryOK is missing here
    }

    // notificationAddressOK may be in the process of being updated asynchronously, in which case notificationAddressOK == false
    isOK = is_ok_to_submit($("ExportCheckMsg"), 'cp_message');
    update_export_buttons();

    if (isOK)
    {
        var args = {};
        var check_pending_fn = null;

        if ($("ExportMethod").options[$("ExportMethod").selectedIndex].value == 'url_direct')
        {
            // if export method == 'url_quick':
            //   1. make sure all SUs are online (use results of jsoc_info call used when the record-set was selected)
            //   2. determine if we want to stream a tar file (if num fits files > 1) or fits file (if num fits files == 1)
            //   3. call exportCGI, which calls drms-export-to-stdout with the arguments determined in #2,
            //      opening a pipe to receive results
            //   4. stream an HTTP header back to the export user
            //   5. stream the file (tar or fits)
            if ($('ExportRecordSet').retrieve('count', null) > 1)
            {
                $("ExportCheckMsg").store({ 'cp_message' : 'url_direct can only be used if exporting a single FITS file' });
                isOK = false;
            }
            else
            {
                if ($('ExportRecordSet').retrieve('allSUsOnline', false))
                {
                    // call drms-export-to-stdout CGI
                    // the tar file will have the name of the file; there will be only one image file in the tar file
                    args.skiptar = 'true';
                    args.spec = $('ExportRecordSet').value;
                    args.filename = $("ExportFilenameFmt").value;
                    // dbhost added to args when submit button clicked

                    // no compression - url_direct is for streaming a single FITS file, uncompressed
                    args.compression = 'none';
                }
            }
        }
        else
        {
            args.op = $("ExportOpID").value;
            args.ds = $("ExportRecordSet").value;
            args.sizeratio = $("ExportSizeRatio").value;
            args.process = ExportProcessingArgs;
            args.requestor = $("ExportRequestor").value;
            args.notify = $("ExportNotify").value;
            args.method = ExportMethodValue;
            args.filenamefmt = $("ExportFilenameFmt").value;
            args.format = "json";
            args.protocol = $("ExportProtocolHidden").value;
        }

        $('ExportRecordSet').store({ 'exportArgs' : args });
        $('ExportCheckMsg').store({ 'cp_message' : 'OK to submit export request' });
        update_export_buttons();
        ExportShowQuery();

        $("ExportButton").store('state', EB_STATE_ENABLED);
        update_export_buttons();

        // on-demand (check once, not in intervals); presents the user with an enabled 'submit'/'cancel' button
        // (it will be 'submit' because the call to check_for_cancel_enabled_shortcut() will have set the state
        // to 'cancel' if a request was pending and execution will never have gotten here).
        check_pending_fn = CHECK_FOR_PENDING_REQUEST(false);
        check_pending_fn();
    }
    else
    {

        $("ExportRecordSet").store({ 'exportArgs' : null });
    }

    if (isOK)
    {
        $("ExportCheckButton").store({ 'dirty' : false });
    }

    return isOK;
}

// called when user clicks on CPE button
function CheckExportParams()
{
    var addresses = $("ExportNotify").retrieve('addresses', {});
    var address = $("ExportNotify").value.trim();
    var requestor = $("ExportRequestor").value.trim();
    var snail_address = null; // no UI yet
    var registration_status = null;
    var address_registered = null;

    if (addresses !== null && address.length > 0 && Object.prototype.hasOwnProperty.call(addresses, address) && Object.prototype.hasOwnProperty.call(addresses[address], 'registration_status'))
    {
        registration_status = addresses[address].registration_status;
    }

    address_registered = (registration_status !== null && (typeof(registration_status) === 'boolean') && registration_status) ? true : false;

    if (address_registered)
    {
        // Up till now, SetProcessing() gets called whenever a processing option checkbox gets clicked.
        // But SetProcessing() does not get called when the user changes processing option values. Call it
        // now with -1 (which means the record-set spec has not changed).
        SetProcessing(-1, CheckExportButtonOnClickAction);  // asynchronous - can't do the rest until this asynchronous call completes.
    }
    else
    {
        // register the email address
        var registration_callback = function()
        {
            update_export_buttons();
            check_for_cancel_enabled_shortcut();
        };

        // we have to reset the registration status for this address; we previously checked its status which sets
        // the status to `false`; if we call register_address() without first resetting it, then we get the cached
        // value of `false` returned and the registration code is bypassed
        addresses[address].registration_status = null;
        register_address(address, requestor, snail_address, $("ExportNotify"), $("ExportCheckMsg"), update_export_buttons, registration_callback);
    }
}

function cancel_export()
{
    var address = $("ExportNotify").value.trim();
    var cancel_pending_fn = null;
    var internal_fn = null;
    var interval_fn_timer = null;
    var interval_fn_timeout = null;

    if (address !== null && address.length > 0)
    {
        $("StatusRequestID").value = ''; // remove export request ID from RequestID in lower section
        $("RequestIdPlace").innerHTML = ''; // remove export request ID from RequestID in upper section

        cancel_pending_fn = CANCEL_PENDING_REQUEST();

        // null -> do nothing on success; let interval function handle the resulting state changes
        cancel_pending_fn(null);

        interval_fn_timer = $("ExportButton").retrieve('interval', null);
        if (interval_fn_timer === null)
        {
            // start-up interval
            internal_fn = CHECK_FOR_PENDING_REQUEST(true);
            interval_fn_timer = setInterval(internal_fn, 1000);
            $("ExportButton").store('interval', interval_fn_timer);

            // do not allow the pending-request check to last forever (EB is in EB_STATE_CANCEL)
            interval_fn_timeout = setTimeout(function () { $("ExportButton").store('state', EB_STATE_TIMEOUT); set_eb_state_disabled(false);}, 30000);
            $("ExportButton").store('interval_timeout', interval_fn_timeout);
        }
    }
}

// this is the code executed when the user clicks on the ExportButton button
function ExportButtonOnClickAction()
{
    // if the use was able to click this button, then it was OK to submit an export request
    var EB_state = $("ExportButton").retrieve('state', EB_STATE_DISABLED);
    var internal_fn = null;
    var interval_fn_timer = null;
    var interval_fn_timeout = null;

    if (EB_state == EB_STATE_SUBMIT_ENABLED)
    {
        EB_state = EB_STATE_SUBMIT;
        $("ExportButton").store('state', EB_state);
        update_export_buttons();

        // call jsoc_fetch now
    }
    else if (EB_state == EB_STATE_CANCEL_ENABLED)
    {
        EB_state = EB_STATE_CANCEL;
        $("ExportButton").store('state', EB_state);
        update_export_buttons();

        // start up interval function (so we know when export request has been completely processed)
        interval_fn_timer = $("ExportButton").retrieve('interval', null);
        if (interval_fn_timer === null)
        {
            // start-up interval
            internal_fn = CHECK_FOR_PENDING_REQUEST(true);
            interval_fn_timer = setInterval(internal_fn, 1000);
            $("ExportButton").store('interval', interval_fn_timer);
        }

        // set or reset timeout timer
        interval_fn_timeout = $("ExportButton").retrieve('interval_timeout', null);
        if (interval_fn_timeout !== null)
        {
            // do not allow the pending-request check to last forever (EB is in EB_STATE_CANCEL); next state is EB_STATE_CANCELED
            // which should happen relatively quickly
              clearTimeout(interval_fn_timeout);
        }

        if (interval_fn_timer !== null)
        {
            interval_fn_timeout = setTimeout(function () { $("ExportButton").store('state', EB_STATE_TIMEOUT); set_eb_state_disabled(false);}, 15000);
            $("ExportButton").store('interval_timeout', interval_fn_timeout);
        }

        // this state transition is handled by calling manage-request, not jsoc_fetch (the code below
        // is all about jsoc_fetch); run this:
        // manage-request.py address=<foo>@<bar> operation=cancel
        // if this call fails for any reason, no worries, the export simply is not canceled, and
        // we get stuck in the EB_STATE_CANCEL state until it completes by natural causes
        cancel_export();

        // do not continue onto calling jsoc_fetch
        return;
    }
    else if (EB_state == EB_STATE_CANCELED)
    {
        set_eb_state_disabled(false);

        // do not continue onto calling jsoc_fetch
        return;
    }
    else if (EB_state == EB_STATE_PATH)
    {
        // change arguments to perform an exp_status request
        $('ExportRecordSet').store({ 'exportArgs' : { "op" : "exp_status", "requestid" : $("RequestIdPlace").innerHTML } })
    }
    else
    {
        EB_state = EB_STATE_DISABLED;
        $("ExportButton").store('state', EB_state);
        update_export_buttons();
        $("ExportButtonMsg").innerHTML = "Unexpected export button state";

        // do not continue onto calling jsoc_fetch
        return;
    }

    if ($('ExportMethod').options[$('ExportMethod').selectedIndex].value == 'url_direct')
    {
        // no need to process a full export request via jsoc_fetch
        if ($('ExportRecordSet').retrieve('count', null) > 1)
        {
            $("ExportLocation").innerHTML =  '<b>Multiple files were requested - use the url_direct export method to request a single file only.<\/b><p>';
        }
        else
        {
            CreateExportDownloadLink(null, null);
        }

        return;
    }

    var doFetchReqFn = function()
    {
    		var arguments = null;
    		var jsocfetchCGI = null;

        arguments = $('ExportRecordSet').retrieve('exportArgs', null);

    		// If this is the external host, then use jsocextfetch. This CGI will choose the correct db server to handle the series.
    		// If this is the internal host, then use jsoc_fetch, which will use the internal db server.
    		if (serverMap[Host.toLowerCase()] == INTERNAL_SERVER)
    		{
      			jsocfetchCGI = JSOC_FETCH;
    		}
    		else
    		{
      			jsocfetchCGI = JSOCEXTFETCH;

            if (arguments !== null)
            {
                arguments.dbhost = EXTERNAL_SERVER;
            }
    		}

        new Ajax.Request('http://' + Host + '/cgi-bin/ajax/' + jsocfetchCGI,
        {
            method: 'post',
            parameters: arguments,

            onSuccess: function(transport, json)
            {
                var response = transport.responseText || "no response text";
                var status = ProcessExportResponse(response);
                var op = $("ExportOpID").value;
            },
            onFailure: function()
            {
                $("ExportButtonMsg").innerHTML = "Export Failure, Problem at JSOC facility.";
                $("ExportButton").value = "FAILURE ...";
                $("ExportButton").style.backgroundColor = colorDarkPink;
                alert('[ GetExport ] Something went wrong...');

                set_eb_state_disabled(true);
            },
            onComplete: function() { }
        });
    };

    // Just call the function. It will determine if it should use the internal or external version of the CGI.
    doFetchReqFn();
}

// the name of the function in the html; this simply calls a function with a function name that denotes it is called
// when a button gets clicked
function GetExport()
{
    return ExportButtonOnClickAction();
}


function ExportOrigin(requestID, webserver)
{
    var retVal = [];

    if (webserver.toLowerCase() == EXTERNAL_WEBSERVER || webserver.toLowerCase() == EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN)
    {
        retVal.push('extServer');
    }
    else if (webserver.toLowerCase() == INTERNAL_WEBSERVER || webserver.toLowerCase() == INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN)
    {
        retVal.push('intServer');
    }
    else
    {
        retVal.push('invalidServer');
    }

    if (requestID)
    {
        if (retVal[0] != 'invalidServer')
        {
            // can't determine if request ID is valid or not
            retVal.push('invalidRequestID');
        }
        else
        {
            if ($("StatusRequestID").value.search("_IN") != -1)
            {
                // an internal request ID
                if (retVal[0] == 'extServer' && $("StatusRequestID").value.search("_X") == -1 ||
                    retVal[0] == 'intServer' && $("StatusRequestID").value.search("_X") != -1)
                {
                    // the external server can process internal request IDs, but only if there is an '_X_IN' in the ID
                    retVal.push('invalidRequestID');
                }
                else
                {
                    retVal.push('intRequestID');
                }
            }
            else
            {
                // an external request ID
                if (retVal[0] == 'intServer')
                {
                    // the internal server cannot process external request IDs
                    retVal.push('invalidRequestID');
                }
                else
                {
                    retVal.push('extRequestID');
                }
            }
        }
    }

    return retVal;
}

function GetReExport()
{
    var args = null;

  state = 2;
  Cookie.setData("state",state);
  $("ExportStatus").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("ExportLocation").innerHTML = "";
  $("ReExportButtonMsg").innerHTML = "Export request submitted, please wait...";
  $("ReExportButton").value = "Processing ...";
  $("ReExportButton").style.backgroundColor = colorPink;

    args = { "op" : "exp_repeat",
             "requestid" : $("ReRequestID").value,
             "format" : "json",
             "notify" : $("ReExportNotify").value };

  // Use JSOC_FETCH_X, which accesses the internal db, if needed. And this is needed if the request ID string ends in
  // 'X_IN'.
	var jsocfetchCGI = JSOC_FETCH;
	var is_IN = ($("ReRequestID").value.search("_IN") > 0);
    var isExtOrigin = ($("ReRequestID").value.search("_X_IN") > 0);

	if (is_IN && (Host.toLowerCase() == EXTERNAL_WEBSERVER || Host.toLowerCase() == EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN))
	{
		if (!isExtOrigin)
		{
			alert('The request ID ' +  $("ReRequestID").value + ' is accessible from http://' + INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN +' only. Please use a request ID generated by a request made on the http://' + EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + ' webserver (which has a format of JSOC_YYYYMMDD_NNN or JSOC_YYYYMMDD_NNN_X_IN).');
			return;
		}

		jsocfetchCGI = JSOCEXTFETCH;
	}
	else if ((!is_IN || isExtOrigin) && (Host.toLowerCase() == INTERNAL_WEBSERVER || Host.toLowerCase() == INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN))
	{
		alert('The request ID ' +  $("ReRequestID").value + ' is accessible from http://' + EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + ' only. Please use a request ID generated by a request made on the http://' + INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + ' webserver (which has a format of JSOC_YYYYMMDD_NNN_IN).');
		return;
	}

    new Ajax.Request('http://' + Host + '/cgi-bin/ajax/' + jsocfetchCGI,
    {
        method: 'post',
        parameters: args,

        onSuccess: function(transport, json)
        {
            var response = transport.responseText || "no response text";
            var status = ProcessExportResponse(response);
        },
        onFailure: function()
        {
            $("ReExportButtonMsg").innerHTML = "Export Failure, Problem at JSOC facility.";
            $("ReExportButton").value = "FAILURE ...";
            $("ReExportButton").style.backgroundColor = colorDarkPink;
            alert('[ GetReExport ] Something went wrong...');

            set_eb_state_disabled(true);
        },
        onComplete: function() { }
    });
  }


function ProcessExportResponse(response)
{
    var data = response.evalJSON();
    var interval_fn_timer = null;
    var interval_fn_timeout = null;

    // state gets set to 0 before leaving this function, so this statement has no effect
    state = 3;
    Cookie.setData("state",state);

    if (data.status == 7)
    {
        // pending request
        $("ExportCheckMsg").style.color = colorRealRed;
        $("ExportCheckMsg").innerHTML = data.error;
        $("ExportButton").value = "Wait";
        $("ExportButtonMsg").innerHTML = data.error;
        $("RequestIdPlace").innerHTML = "";
        $("ExportStatus").innerHTML = "Request Rejected";
        $("ExportLocation").innerHTML = "";
        state = 0;
        Cookie.setData("state",state);
    }
  else if (data.status == 6)
    {
    // email address was not registered, or export_manage not yet found request.
    $("ExportCheckMsg").innerHTML = "RequestID not found, status=6, error=" + data.error + "<br>Try again in a few seconds, may just be not ready to respond";
    $("ExportButton").value = "Retry";
    $("ExportButtonMsg").innerHTML = data.error;
    $("RequestIdPlace").innerHTML = "";
    $("ExportStatus").innerHTML = "RecordSet not found";
    $("ExportLocation").innerHTML = "";
    }
  else if (data.status == 5)
    {
    $("ExportCheckMsg").innerHTML = "Requested RequestID is too old, data no longer online, error=" + data.error;
    $("ExportButton").value = "Export timeout";
    $("ExportButtonMsg").innerHTML = data.error;
    $("RequestIdPlace").innerHTML = "";
    $("ExportStatus").innerHTML = "Export timeout";
    $("ExportLocation").innerHTML = "";
    state = 0;
    Cookie.setData("state",state);
    }
  else if (data.status == 4)
    {
    $("ExportCheckMsg").innerHTML = "Requested RecordSet not found or specification error, status=4, error=" + data.error +
      "<br>The export program failed.<br>" + "JSOC support see: jsoc/exports/tmp/" + data.requestid + ".runlog";
    $("ExportButton").value = "Bad RecordSet";
    $("ExportButtonMsg").innerHTML = data.error;
    $("RequestIdPlace").innerHTML = "";
    $("ExportStatus").innerHTML = "RecordSet not found";
    $("ExportLocation").innerHTML = "";
    state = 0;
    Cookie.setData("state",state);
    }
  else if (data.status == 3)
    {
    $("ExportCheckMsg").innerHTML = "Requested export size is too large: " + data.error + " Please contact the JSOC for help.";
    $("ExportButtonMsg").innerHTML = data.error;
    $("ExportButton").value = "Export Too Large";
    $("ExportButton").style.backgroundColor = "#D8D8D8";
    RequestID = data.requestid;
    $("RequestIdPlace").innerHTML = data.requestid;
    $("RequestIDDesc").update(HTML_REQUESTID_DESC);
    $("ExportStatus").innerHTML = "Needs Intervention, size=" + data.size + "MB, <br>" +
      data.count + " records found, " +
      data.error + ", contact: " + data.contact;
    $("ExportLocation").innerHTML = "";
    state = 0;
    Cookie.setData("state",state);
    }
  else if (data.status == 1 || data.status == 2 || data.status == 12)
    {
    ClearStatus();
    if (data.status == 1)
      $("StatusButtonMsg").innerHTML = "Export request is being processed";
    else  // status==2
      $("StatusButtonMsg").innerHTML = "Export request waiting for processing";

    $("ExportButton").style.backgroundColor = "#D8D8D8";
    //  XXXX FIX $("ExportStatus").innerHTML = "Processing, size=" + data.size + "MB, estimate " + data.wait + " seconds remaining";
    $("ExportStatus").innerHTML = "Processing, size estimate = " + data.size + " MB";
    RequestID = data.requestid;
    $("RequestIdPlace").innerHTML = data.requestid;
    $("RequestIDDesc").update(HTML_REQUESTID_DESC);
    $("StatusRequestID").value = data.requestid;

    // we now know that the JSOC has seen the export request; before jsoc_fetch returns, it inserts a row
    // into export_pending_reqs, which means the user has a pending request; jsoc_fetch sets status to 2
    // when starting a new request (not 1, which is what the status check will return)

    // it is safe to change state to cancel_enabled
    if ($("ExportButton").retrieve('state', EB_STATE_DISABLED) == EB_STATE_SUBMIT)
    {
        $("ExportButton").store('state', EB_STATE_CANCEL_ENABLED);
        update_export_buttons();

        interval_fn_timer = $("ExportButton").retrieve('interval', null);
        if (interval_fn_timer === null)
        {
            // start-up interval
            internal_fn = CHECK_FOR_PENDING_REQUEST(true);
            interval_fn_timer = setInterval(internal_fn, 1000);
            $("ExportButton").store('interval', interval_fn_timer);
        }

        // do not allow the pending-request check to last forever (EB is in EB_STATE_CANCEL_ENABLED); export processing could take a while
        // so set a 1 day timeout (86400000)
        interval_fn_timeout = $("ExportButton").retrieve('interval_timeout', null);
        if (interval_fn_timeout !== null)
        {
            clearTimeout(interval_fn_timeout);
        }

        if (interval_fn_timer !== null)
        {
            interval_fn_timeout = setTimeout(function () { $("ExportButton").store('state', EB_STATE_TIMEOUT); set_eb_state_disabled(false);}, 86400000);
            $("ExportButton").store('interval_timeout', interval_fn_timeout);
        }
    }
    else
    {
        // error
        alert('unexpected eb state');
    }

    Cookie.setData("requestid",data.requestid);
    $("ExportLocation").innerHTML = "";
    $("FileUploadInfo").innerHTML = "File upload done, " + data.rcount + " records requested.";
    if (ExportFromFileList == 1)
      {
      FinishFileUpload();
      $("FileUploadInfoRow").style.display="table-row";
      }
    }
  else // status == 0 implies url_quick format and all online as-is
    {
    var valuetable = "";
    state = 0;
    Cookie.setData("state",state);
    Cookie.setData("requestid","");
    var count = data.count;
    RequestID = data.requestid;

    // the user has clicked on the "get path" EB button; we need to changed back to disabled state
    if ($("ExportButton").retrieve('state', EB_STATE_DISABLED) == EB_STATE_PATH)
    {
        // before we change the state to disabled, we need to ensure that the interval function is no longer running
        // (due to a race condition, it may still be running (interval sets to EB_STATE_PATH, then this code here
        // runs, which changes state to EB_STATE_DISABLED before interval function has a chance to clear itself))
        set_eb_state_disabled(false);
    }
    else
    {
        // error
        alert('unexpected eb state');
    }

    //update_export_buttons();

    if (RequestID.length == 0) RequestID = "N.A.";
    $("RequestIdPlace").innerHTML = RequestID;
    $("RequestIDDesc").update(HTML_REQUESTID_DESC);
    $("ExportStatus").innerHTML = "Data Ready, size=" + data.size + "MB";
    valuetable = CreateDataTable(data, valuetable);
    $("ExportLocation").innerHTML =  valuetable + "<br>";
    $("FileUploadInfo").innerHTML = "File upload done, " + data.rcount + " records requested.";
    if (ExportMethodValue == "url_quick")
    {
        $("ExportLocation").innerHTML = valuetable + "<br>";
    }
    else
      $("ExportLocation").innerHTML =  valuetable + "<br>";
    if (ExportFromFileList == 1)
      {
      FinishFileUpload();
      $("FileUploadRow").style.display="none";
      $("FileUploadInfoRow").style.display="table-row";
      }
    }
  return(data.status);
  }

function ClearStatus()
  {
  $("StatusButton").style.backgroundColor = "#D8D8D8";
  $("StatusStatus").innerHTML = "";
  $("StatusValue").innerHTML = "";
  $("StatusOther").innerHTML = "";
  $("StatusButtonMsg").innerHTML = "Waiting new status request...";
  $("StatusButton").value = "Submit Status Request";
  $("StatusRequestID").value = "";
  $("StatusLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("TarFileLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("KeywordFileLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("StatusDataLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  }

function GetStatus()
  {
  if ($("StatusRequestID").value.length == 0)
    {
    alert("You must provide a RequestID");
    return;
    }

    // An external user can check status on certain internal requests. These requests originated from the external site,
    // but they were passed-through to the internal site because they involved at least one internal series that
    // was whitelisted for external access. The request IDs of those requests contains an 'X':
    //
    // JSOC_20161225_1254_X_IN
	var jsocfetchCGI = JSOC_FETCH;
	var is_IN = ($("StatusRequestID").value.search("_IN") > 0);
    var isExtOrigin = ($("StatusRequestID").value.search("_X_IN") > 0);

    // there are two boolean attributes describing the origin of an export request:
    // 1. the request was submitted from the external website (EXTERNAL_WEBSERVER) or the internal website (INTERNAL_WEBSERVER)
    // 2. the request was for the export of a db-external data series (the request ID ends in '_IN') or a db-internal data series (the request ID does not end in '_IN')
    //
    // the internal server can serve requests for db-internal series only; the external server can serve requests for either
    // db-external series (the request ID does not end in '_IN'), or db-internal series initiated from the external server
    // (the request ID ends in '_X_IN')

	if (is_IN && (Host.toLowerCase() == EXTERNAL_WEBSERVER || Host.toLowerCase() == EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN))
	{
		if (!isExtOrigin)
		{
			alert('The request ID ' +  $("StatusRequestID").value + ' is accessible from http://' + INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN +' only. Please use a request ID generated by a request made on the http://' + EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN +' webserver (which has a format of JSOC_YYYYMMDD_NNN or JSOC_YYYYMMDD_NNN_X_IN).');
			return;
		}

		jsocfetchCGI = JSOCEXTFETCH;
	}
	else if ((!is_IN || isExtOrigin) && (Host.toLowerCase() == INTERNAL_WEBSERVER || Host.toLowerCase() == INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN))
	{
		alert('The request ID ' +  $("StatusRequestID").value + ' is accessible from http://' + EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + ' only. Please use a request ID generated by a request made on the http://' + INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + ' webserver (which has a format of JSOC_YYYYMMDD_NNN_IN).');
		return;
	}

  var arguments = {"op" : "exp_status", "requestid" : $("StatusRequestID").value};

  $("StatusLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("TarFileLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("KeywordFileLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("StatusDataLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("StatusButton").style.backgroundColor = colorPink;
  $("StatusStatus").innerHTML = "";
  $("StatusValue").innerHTML = "";
  $("StatusOther").innerHTML = "";
  $("StatusButtonMsg").innerHTML = "Processing status request ...";
  $("StatusButton").value = "Processing ...";

  new Ajax.Request('http://' + Host + '/cgi-bin/ajax/' + jsocfetchCGI,
  {
    method: 'get',
    parameters: arguments,

    onSuccess: function(transport, json)
    {
      var response = transport.responseText || "no response text";
      var data = response.evalJSON();
      state = 2;
      Cookie.setData("state",state);
      if (data.status == 6)
        {
        $("StatusButtonMsg").innerHTML = "RequestID not found, status=6, error=" + data.error + "<br>Try again in a few seconds, may just be not ready to respond";
        StatusReadyOK = 0;
        $("StatusButton").value = "Bad RecordSet";
        $("StatusValue").innerHTML = "Requested RecordSet returned error status=6";
        $("StatusOther").innerHTML = $("StatusRequestID").value + " not found,  msg=" + data.error;
        $("ReExportDiv").style.display = "none";
        state = 1;
        Cookie.setData("state",state);
        }
      else if (data.status == 5)
        {
        $("StatusButtonMsg").innerHTML = "Requested RequestID is too old, data no longer online, error=" + data.error;
        $("ExportButton").value = "Export timeout";
        $("ExportButtonMsg").innerHTML = data.error;
        $("RequestIdPlace").innerHTML = "";
        $("ExportStatus").innerHTML = "Export timeout";
        $("ExportLocation").innerHTML = "";
        $("ReRequestID").value = data.requestid;
        $("ReExportDiv").style.display = "block";
        }
      else if (data.status == 4)
        {
        StatusReadyOK = 0;
        $("StatusButton").value = "Bad RecordSet";
        $("StatusButtonMsg").innerHTML = data.error;
        $("StatusValue").innerHTML = "Requested RecordSet returned error status=4";
        $("StatusOther").innerHTML = $("StatusRequestID").value + "msg=" + data.error;
        $("ReExportDiv").style.display = "none";
        }
      else if (data.status == 3)
        {
        $("StatusButtonMsg").innerHTML = "Requested export size is too large: " + data.error + " Please contact the JSOC for help.";
        $("StatusButton").value = "Export Too Large";
        $("StatusButton").style.backgroundColor = "#D8D8D8";
        $("StatusStatus").innerHTML = "Needs Intervention, size=" + data.size + "MB, contact: " + data.contact;
        $("RequestIdPlace").innerHTML = data.requestid;
        $("RequestIDDesc").update(HTML_REQUESTID_DESC);
        $("StatusValue").innerHTML = "Requested RecordSet returned error status=3";
        $("StatusOther").innerHTML = $("StatusRequestID").value +
           "<br>The requested RecordSet is too large for chosen export method." +
           "<br>" + data.count + " records found, " + data.error +
           "<br>Please contact the JSOC for help." ;
        $("ReExportDiv").style.display = "none";
        }
      else if (data.status == 1 || data.status == 2)
	{
        if (data.status == 1)
          $("StatusButtonMsg").innerHTML = "Export request is being processed";
        else  // status==2
          $("StatusButtonMsg").innerHTML = "Export request waiting for processing";
        $("StatusButton").value = "Submit Status Request";
        $("StatusButton").style.backgroundColor = "#D8D8D8";
        // XXXXX FIX $("StatusStatus").innerHTML = "Processing, size=" + data.size + "MB, estimate " + data.wait + " seconds remaining";
        var waiting = 10 - data.wait;
        $("StatusStatus").innerHTML = "Processing, size estimate = " + data.size + " MB, " + waiting + " seconds since request";
        $("RequestIdPlace").innerHTML = data.requestid;
        $("RequestIDDesc").update(HTML_REQUESTID_DESC);
        $("ReExportDiv").style.display = "none";
        state = 1;
        Cookie.setData("state",state);
        }
        else // status == 0
        {
            var valuetable = "";
            var StatusLoc;

            $("StatusButtonMsg").innerHTML = "Please only click once for status request.";
            $("StatusButton").value = "Submit Status Request";
            $("StatusButton").style.backgroundColor = "#D8D8D8";
            $("StatusStatus").innerHTML = "Data Ready, size=" + data.size + "MB";
            $("RequestIdPlace").innerHTML = data.requestid;
            $("RequestIDDesc").update(HTML_REQUESTID_DESC);

          	if (data.method.indexOf("ftp") >= 0)
            {
                StatusLoc = "ftp://pail.stanford.edu/export" + data.dir + "/";
            }
            else
            {
                StatusLoc = "http://jsoc1.stanford.edu" + data.dir + "/";
            }

            $("StatusLocation").innerHTML = "<a href='" + StatusLoc + "' target='_blank'>" + StatusLoc + "<\/a>";
            if (data.method.indexOf("-tar") > 0)
            {
                $("TarFileLocation").innerHTML = "<a href='" + data.tarfile + "'>" + data.tarfile + "<\/a>";
                $("TarFileLocationRow").style.display = "table-row";
        	  }
            else
            {
                $("TarFileLocationRow").style.display = "none";
            }

            if (data.protocol.indexOf("as-is") >= 0)
            {
                $("KeywordFileLocation").innerHTML = "<a href='" + data.keywords + "' target='_blank'>" + data.keywords + "<\/a>";
                $("KeywordFileLocationRow").style.display = "table-row";
            }
            else
            {
                $("KeywordFileLocationRow").style.display = "none";
            }

            $("ExportStatus").innerHTML = "Data Ready, size=" + data.size + "MB";
            valuetable = CreateDataTable(data, valuetable);
            $("StatusDataLocation").innerHTML = valuetable + "<br>";
            $("StatusValue").innerHTML = "Success";
            $("StatusOther").innerHTML = "List formats are index.html, index.json, and index.txt<br>" + "export script file is " + $("StatusRequestID").value +".drmsrun" ;

            if (ExportFromFileList  == 1)
            {
                FinishFileUpload();
            }

            $("ReExportDiv").style.display = "none";
            state = 1;
            Cookie.setData("state",state);
        }
      },
    onFailure: function()
      {
      $("StatusButtonMsg").innerHTML = "Export Failure, Problem at JSOC facility.";
      $("StatusButton").value = "FAILURE ...";
      $("StatusButton").style.backgroundColor = colorDarkPink;
      alert('[ GetStatus ] Something went wrong...');
      set_eb_state_disabled(true);
      },
    onComplete: function() { }
    });
  }

</script>

</head>
<body bgcolor="#E0F0FF" onload="OnLoadInit();" >
<div id="header">
  <a href ="http://jsoc.stanford.edu" id="header_logo"><img src="http://hmi.stanford.edu/images/web/JSOC_120.gif"
    style="vertical-align:middle;height:60px;border:0" alt="JSOC logo"></a>
&nbsp;&nbsp;&nbsp;
<b><big style="vertical-align:middle">&nbsp;&nbsp;JSOC Data Export</big></b>
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
<input id="ResetPageButton" type="button" value="reset page" onClick="ReInitPage();" disabled>
&nbsp;&nbsp;&nbsp;
<input id="TipsOnOffButton" type="button" value="Turn Help Off" onClick="ToggleHelp();" >
&nbsp;&nbsp;<span id="AjaxBusy">0</span> Active HTTP Requests
<!-- <br clear=all> -->
<hr>
</div> <!-- end div header -->
<div id="ExportRequestDiv">
<br><b>JSOC Data Export Request Generation</b>

<!-- Start Message of the Day -->
<div id="MOTD">
<!--#include virtual="JSOC_MOTD.html" -->
</div> <!-- end MOTD div -->
<!-- END MODT DIV -->

<span id="RecordSetExample">
&nbsp; &nbsp;
<a href="exportdata.d/ExportDataErrorHelp.html" target="JSOC_Help">Help with Error Messages</a>
&nbsp;
<a href="http://jsoc.stanford.edu/doc/exports/exportdata_lookdata_release_notes.txt" target="JSOC_Help">Release Notes</a>
</span>
<p>
If the Method is changed from "url_quick" or "url_direct" you will have additional options to specify.
"url-direct" is temporarily disabled.
<p>
After the request is submitted
for Methods of "url", "ftp", "url-tar" or "ftp-tar" you will recieve ON THIS PAGE a "Request_ID" that will be used
to access the data when it is ready.
<p>
If you enter an email address you will be notified when the data is ready.
If you do not provide an email address you must leave this page open or save the Request_ID in order to
access the data.
<p>

<!-- Load bulk of html code here -->
<span id="ExportRequestForm"></span>

<div id="iframeHideDiv" style="display:none;">
  <iframe id="FileUploadFrame" onload="uploadDone();" src="" style="height:0px;width:0px;border:0px solid #fff;"></iframe>
</div>

<div id="SubmitResponseDiv">
<table>
  <tr>
    <td>RequestID</td>
    <td colspan="2"><span id="RequestIdPlace" style="width:12em;background-color:#FFF8DC;">&nbsp;</span></td>
    <td id="RequestIDDesc"></td>
  </tr>

  <tr>
    <td>Status</td>
    <td colspan="3"> <span id="ExportStatus" style="background-color:#FFF8DC;"> </span ></td>
  </tr>

  <tr>
    <td id="DataLocation">Data Location</td>
    <td colspan="3"><span id="ExportLocation" style="background-color:#FFF8DC;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span ></td>
  </tr>

</table>
</div>
<hr>
<div id="ExportDataDiv"  style="background-color:#C0E0FF;">
<b>JSOC Data Export Status and Retrieval</b>
<p>
<table>
  <tr>
    <td style="width:10em" >RequestID</td>
    <td><input type="text" id="StatusRequestID" name="StatusRequestID" style="width:12em;background-color:#FFF8DC;" value="" onChange="GetStatus();"></td>
    <td>This is the ID tag for your export request.</td>
    <td><span id="StatusValue">&nbsp;</span></td>
  </tr>

  <tr>
    <td colspan="2" align="center" >
      <input id="StatusButton" type="button" value="Submit Status Request" style="background-color:#D8D8D8" onClick="GetStatus();" ></td>
    <td><span id="StatusButtonMsg">Please only click once for status request.</span ></td>
    <td rowspan="3"><span id="StatusOther">&nbsp;</span></td>
  </tr>

  <tr>
    <td colspan="2" align="center" >
      <input id="ClearButton" type="button" value="Clear Request" style="background-color:#D8D8D8" onClick="ClearStatus();" ></td>
    <td>Clear old status RequestID</td>
  </tr>

  <tr>
    <td>Status</td>
    <td colspan="2"> <span id="StatusStatus" style="background-color:#FFF8DC;"> </span ></td>
  </tr>

  <tr>
    <td>Data Location</td>
    <td colspan="3"><span id="StatusLocation" style="background-color:#FFF8DC;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span ></td>
  </tr>

  <tr id="TarFileLocationRow" style="display:none;">
    <td>Tar File Location</td>
    <td colspan="3"><span id="TarFileLocation"  style="background-color:#FFF8DC;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span ></td>
  </tr>

  <tr id="KeywordFileLocationRow" style="display:none;">
    <td>Keyword File Location</td>
    <td colspan="3"><span id="KeywordFileLocation"  style="background-color:#FFF8DC;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span ></td>
  </tr>

  <tr>
  <td colspan="4"><span id="StatusDataLocation" style="background-color:#FFF8DC;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span ></td>
  </tr>

</table>
</div> <!-- id="ExportRequestDiv" -->

<div id="ReExportDiv" style="display:none">
<HR>
Use this section to request a renewal/repeat of a prior export for which the data online-retention time has expired.
<table>

  <tr>
    <td style="width:10em" >RequestID</td>
    <td><input type="text" id="ReRequestID" name="ReRequestID" style="background-color:#FFF8DC;" value="" onChange="ExportNop();"></td>
    <td>Enter RequestID for repeat or prior export</td>
    <td><span id="ReStatusValue">&nbsp;</span></td>
  </tr>

  <tr id="ReNotifyRow">
    <td>Notify</td>
    <td><input id="ReExportNotify" type="text" name="Renotify" value="" onChange="ExportNop();" ></td>
    <td colspan="2">
      Provide your email address for notification.
    </td>
  </tr>

  <tr id="AjaxReExportRequestRow">
    <td colspan="4">
      re-<input id="ReExportButton" type="button" value="Submit Export Request" style="background-color:#D8D8D8" onClick="GetReExport();" >
    <span id="ReExportButtonMsg">Please only click once for re-export request.</span >
    </td>
  </tr>

</table>
</div> <!-- id="ReExportDiv" -->
</div>

<HR>
<P style="height:1px">
<div id="footer" style="vertical-align:bottom;text-align:center;">
<I>Home page for:</I>
<a href = "http://jsoc.stanford.edu/" id="footer_link"><b>SDO-JSOC</b></a>
</div>

<script type="text/javascript">
var unescaped_html = unescape(escaped_html);
$("ExportRequestForm").innerHTML = unescaped_html;
// The onload function is called after this. It calls ProcessingInit() and ProcessingEnabled(). Don't do that here as well.
</script>

</body>
</html>
