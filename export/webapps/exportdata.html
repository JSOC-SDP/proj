<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta HTTP-EQUIV="Content-Type" content="text/html; charset=iso-8859-1">
<title>JSOC Export Data</title>

<script type="text/javascript" src="js/prototype-1.6.0.3.js"></script>
<script type="text/javascript" src="js/cookies.js"></script>
<script type="text/javascript" src="js/prototip.js"></script>
<link rel="stylesheet" type="text/css" href="css/prototip.css" >

<script type="text/javascript">
// Global variables and initialize page locations
var exportdata = location.pathname.sub(".html",""); 
</script>
<script type="text/javascript">
document.write('<base id="basepath" href="'+exportdata+'/"><\/base>');
</script>

<script type="text/javascript">

// Set CGI-BIN and include targets

// Eventually this should be put into a common file loaded by all the html web pages. To do that
// we need to copy code from exportdata.html to here that sets the base directory that is used
// when loading files with the <script> tag. Then we need to put the common file in that
// base directory, and we need to read it here. But for now, just hard-code this needed map.
var serverMap = new Array();
serverMap["jsoc"] = "hmidb2";
serverMap["jsoc.stanford.edu"] = "hmidb2";
serverMap["jsoc2"] = "hmidb";
serverMap["jsoc2.stanford.edu"] = "hmidb";

// var JSOC_INFO = "jsoc_info_test";
// var JSOC_FETCH = "jsoc_fetch_test";
// var LOOKDATA = "lookdata2";

var JSOC_INFO = "jsoc_info";
var JSOC_INFO_X = "jsoc_info_x";
var JSOC_FETCH = "jsoc_fetch";
var JSOC_FETCH_X = "jsoc_fetch_x";
var LOOKDATA = "lookdata";
var PARSE_RECSET = 'drms_parserecset';
var SHOW_WLSERIES = 'show_wlseries';

</script>
<!-- Add html for processing and protocol options  -->
<!-- The sourced file contains: escaped_html='...'  -->
<script type="text/javascript" src="exportdata.d/export_request_form.htmlesc"></script>

<!-- Add functions for export processing and protocol options  -->
<script type="text/javascript" src="exportdata.d/processing.js"></script>
<script type="text/javascript" src="exportdata.d/protocols.js"></script>

<!-- Add list of seriesnames for which processing on export is not suportted -->
<script type="text/javascript" src="exportdata.d/no_processing.js"></script>

<style type="text/css">

#body { margin:0; padding:0; }
#header { position:relative; top:0; left:0; width:100%; background:#eee; }
#footer { position:fixed; bottom:0; left:0; width:100%; background:#eee; }
#ExportRecordSet { width:40em; font-size:100%; }
span.tip { background-color:blue;font-family:verdana;color:white;font-size:1em;font-weight:bold;}
.prototip { font:0.8em Arial, Helvetica, sans-serif; }
</style>

<script type="text/javascript">

// Protect page from accidental BACK button
window.onbeforeunload = function () 
  {
  return "Did you really mean to leave exportdata? Use CANCEL to stay here";
  }

function OnEnterKey(evt,action)
  {
  var keynum;
  var keychar;
  if(window.event) // IE
    keynum = evt.keyCode;
  else if(evt.which) // Netscape/Firefox/Opera
    keynum = evt.which;
  if(keynum == 13)
    action();
  keychar = String.fromCharCode(keynum);
  return keychar;
  }

var previousSeries = "";
function NotifyProcessingCode()
  {
  // called when RecordSet is changed.
  // Set flags to alert processing or method options here.
  // variables here will usually be defined in exportdata.d/processing.js
  // or exportdata.d/export_request_form.html
  if (SeriesName == previousSeries)
    SetProcessing(-1);
  else
    {
    SetProcessing(-2);
    ProtocolOptionsSet = 0;
    }
  previousSeries = SeriesName;
  }

// Global vars
var Host = location.host;
var Internal = 0;
var SeriesName;
var SeriesInfo;
var firstRealSegment;
var RequestID;
var RecordLimit;
var RecordCount = -1;
var RecordCountNeeded;
var ExportQueryOK;
var ExportRecordSetOK;
var ExportRedinessStatus;
var ExportFromFileList;
var ExportMethodOK;
var ExportMethodIsDirect;
var ExportFilenameFmtOK;
var ExportProcessingOK;
var ExportProcessingOptions;
var ExportUserOK;
var ExportNotifyOK;
var ExportReadyOK;
var TipsEnabled;
var TipsCreated = 0;
var args;
var state=0;
var uploadOndoneAction = 0;
var ExportProcessingArgs = "";
var ProcessingAllowed = 1;
var ExportMethodValue = "url_quick";
var exportparameters;

// Protocol global vars
var ExportCompressOK;
var ExportProtocolOK;
var ExportCompressValue = "";
var ExportProtocolValue = "FITS";
var ProtocolOptionsSet = 0;
var protocol_args
var ExportProtocolArgs = "";
var ExportProtocolArgsOK;
var protocolEnable;

// Misc vars
var firstTimePrime;
var expURL;
var exportdataLoaded = false;

// Colors
var colorNeutral = "#D4D0C8";
var colorPreset = "D8D8D8";
var colorOptionSet = "#FFCC66";
var colorPink = "#FFD8D8";
var colorDarkPink = "#FFB0B0";
var colorRed = "#D88080";
var colorDarkRed = "#FF8080";
var colorWhite = "#FFFFFF";
var colorGreen = "#80FF80";
var colorYellow = "#FFF8DC";


function initVars()
  {
  Host = location.host;
  if (Host == "jsoc2.stanford.edu")
    Internal = 1;
  else
    Internal = 0;
  SeriesName = "";
  RequestID = "";
  RecordCount = 0;
  RecordCountNeeded = 1;
  RecordLimit = 0;
  ExportRecordSetOK = 0;
  ExportQueryOK = 0;
  ExportRedinessStatus = 0;
  ExportFromFileList = 0;
  ExportMethodOK = 1;
  ExportMethodIsDirect = 0;
  ExportFilenameFmtOK = 1;
  ExportUserOK = 0;
  ExportNotifyOK = 0;
  ExportReadyOK = 2;
  TipsEnabled = 1;
  uploadOndoneAction = 0;
  firstTimePrime = "";
  ProcessingAllowed = 1;

  // Init processing
  ExportProcessingOK = 1;
  ExportProcessingArgs = "";

  // Init protocols
  ExportProtocolOK = 1;
  ExportCompressOK = 1;
  ExportProtocolArgs = "";
  protocolEnable = 0;
  ProtocolOptionsSet = 0;

  if (exportdataLoaded)
    {
    ProcessingInit();
    ProtocolOptionsInit();
    }

  // if (state < 2)
  // Form init
    {
    $("ExportRequestor").value = "";
    // always ask email, default solarmail
    // if (Internal)
      $("ExportNotify").value = "solarmail";
    // else
      // $("ExportNotify").value = "";
    $("RequestIdPlace").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("StatusLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("TarFileLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("ExportStatus").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("StatusDataLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("ExportRecordSet").value = "";
    // Processing
    $("ProcessRow").style.display="none";
    $("ExportProcessingHidden").value = "no_op";
    $("ProcessingCheckbox").checked = 0;
    // Protocols
    $("ProtocolRow").style.display="none";
    $("ExportProtocol").selectedIndex = 1;
    $("ExportProtocolHidden").value = "FITS";
    $("ExportCompress").selectedIndex = 0;
    $("CompressRow").style.display="none";
    $("ProtocolImageOptions").style.display="none";

    $("ExportMethod").selectedIndex = 2;
    $("ExportFilenameFmt").value = "{seriesname}.{recnum:%lld}.{segment}";
    $("ExportButton").value = "Submit Export Request";
    $("ExportButtonMsg").innerHTML = "Please only click once for export request.";
    $("ExportButton").style.backgroundColor = colorRed;
    $("RecordSetRow").style.display="table-row";
    $("RecordCountRow").style.display="table-row";
    $("FilenameFmtRow").style.display="none";
    $("RequestorRow").style.display="none";
    $("NotifyRow").style.display="none";
    $("FileUploadCheckbox").checked = 0;
    $("ExportOpID").value = "exp_request";
    $("ReRequestID").value = "";
    $("ReExportDiv").style.display = "none";
    $("TarFileLocationRow").style.display = "none";
    $("KeywordFileLocationRow").style.display = "none";
    $("ShowQueryCheckbox").checked = 0;
    SetExportMethod(1);
    }
  FileUploadCleanup();
  }

function getargs()
  {
  state = Cookie.getData("state");
  $("ExportRequestor").value = Cookie.getData("user");
  if ($("ExportRequestor").value == "undefined")
    $("ExportRequestor").value = "";
  if (state == 1)
    {
    var exportargs = Cookie.data["search"];
    if (exportargs != undefined)
      {
      exportargs = decodeURIComponent(exportargs);
      exportargs = exportargs.substr(1);
      exportargs = exportargs.replace(/\?/g,"QUESTIONMARK");
      args = exportargs.toQueryParams();
      if (args.ds == undefined)
        args.ds = "";
      args.ds = args.ds.replace(/QUESTIONMARK/g, "?");
      }
    else
      {
      args = new Object;
      args.ds = "";
      }
    }
  else if (state > 1)
    {
    args = new Object;
    args.ds = "";
    args.requestid = "";
    args.limit= "none";
    }
  else
    {
    var exportargs = location.search;
    exportargs = decodeURIComponent(exportargs);
    exportargs = exportargs.substr(1);
    exportargs = exportargs.replace(/\?/g,"QUESTIONMARK");
    args = exportargs.toQueryParams();
    if (args.ds == undefined)
      args.ds = "";
    args.ds = args.ds.replace(/QUESTIONMARK/g, "?");
    state=1;
    Cookie.setData("state",state);
    Cookie.setData("search",location.search);
    Cookie.setData("user", $("ExportRequestor").value);
    }
  return args;
  }

function OnLoadInit()
  {
  var needcount = 0;
  Cookie.init({name:exportdata, expires:5});
  initVars();
  if (Internal)
    {
    $("header_logo").href="http://jsoc2.stanford.edu";
    $("footer_link").href="http://jsoc2.stanford.edu";
    }
  state = 0;
  Cookie.setData("state",state);
  args = getargs();
  if (args.ds)
    {
    $("ExportRecordSet").value = args.ds;
    needcount = 1;
    }
  if (args.id)
    {
    RequestID = args.id;
    }
  if (args.limit) 
    {
    $("ExportRecordLimit").value = args.limit;
    if (args.limit == "none") RecordLimit = 0;
    else RecordLimit = args.limit;
    }
  if (needcount && $("ExportRecordSet").value != "")
    {
    GetRSCount();
    GetDefaultFormat();
    }
  // if (Internal)
   //  $("RequestorMessage").innerHTML = "Provide an identifier for you, e.g. your SolarMail name. Required for jsoc2";
    $("RequestorMessage").innerHTML = "If Notify is 'solarmail' provide your SolarMail name else your name or leave blank.";
  // HELP tips enable
  if (exportdataLoaded)
    ProcessingEnabled();
  CreateTips();
  $("TipsOnOffButton").value = "Turn Help Off";
  window.focus();
  }

function ReInitPage()
  {
  Cookie.setData("state",0);
  OnLoadInit();
  }

function MainTips(tipstyle)
  {
  if (TipsCreated == 0)
    {
    new Tip('RecordFromFileHelp','Allows user to provide a RecordSet list in a file.  ' +
        'The file should contain recordSet specifiers in the format allowed by drms_open_records include files.  ' +
        'See http://jsoc.stanford.edu/jsocwiki/AllAboutJsocNames.',tipstyle);
    new Tip('RecordSetHelp','RecordSet to be exported. May be imported on call and/or may be entered directly here. ' +
        'May be filled in by series select in Im_patch processing option.',tipstyle);
    new Tip('CallLookdataHelp','Start lookdata.html in a different tab/window with RecordSet given.  ' +
        'If a JSOC Lookdata window already exists, the first one will be replaced by this call.',tipstyle);
    new Tip('RecordLimitHelp','RecordSet record limit. Max number of records to export.  Modifies RecordSet. ' +
        'Value should be "none" or a number. Number > 0 counts from start of RecordSet.  Negative number counts ' +
        'from high end of RecordSet.  0 means no limit',tipstyle);
    new Tip('RecordCountHelp','RecordSet record count.  Update this to repeat export with new method, email, etc.  ' +
        'There is presently a limit to the memory space allocated for record queries which restricts AIA lev1 ' +
        'requests to about 15,000 records and HMI X_45s or X_720s data to about 32,000 records.  ' +
        'The limit depends on number of keywords in each record.  This limit will be eased in the future.',tipstyle);
    new Tip('MethodHelp','Handshake method to be used in the process of doing the export and to fetch the data files. ' +
        '"url-quick" is the fastest but can only be used if the data is online and will be exported "as-is". ' +
        '"url-direct" is has the constraints of url_quick with the limit of one file per request but it will ' +
        'automatically do the postprocessing specified in the "protocol" instruction. For "url_direct" the file ' +
        'is returned directly to your browser rather than returning to the export page.  If you have the ' +
        'set to load some fits reader program when the mime-ype "fits" is encountered you will see the image promptly. ' +
        '"url" will result in a temporary directory being created and the URL to that directory be returned to you after ' +
        'a handshake process using the RequestID provided. ' +
        '"ftp" is like "url" but the returned links will be to an ftp directory. ' +
        ' A "-tar" suffix will cause a tar of all files in the request to be included with the separate files. ' +
        'NOTE: do not use "-tar" unless you really need it since that will generate an extra copy of the data.',tipstyle);
    new Tip('FilenameFmtHelp','Filename format to be used in the process of doing the export.  ' +
        'The filename format is a template used to construct a filename for each segment of each record requested.  ' +
        'The template consists of literal characters and substitution tokens enclosed in "{}".  ' +
        'The special words: seriesname, recnum, and segment are replaced with the series_name, the record number, ' +
        'or the segment name.  The element {#} will generate an increasing number, ' +
        'with optional layout e.g. default is {#:%05d}. ' +
        'Any keyword in the record may also be used.  Optional layout may be provided after a ":".' +
        'Special format options are available for type TIME keywords: A leading "A" will strip "." and ":" from the time and ' +
        'a "D" will strip the "." and ":" but will insert "@" around the date components to allow easy scripts ' +
        'to move the exported files into date structured directory trees. ' +
        'It is wise to include enough of the "prime-keys" to make a unique filename.  ' +
        'The default format template is made from series structure.',tipstyle);
    new Tip('ProcessingHelp','Processing to be done to the data prior to export. ' +
        ' Select from drop-down list for details.',tipstyle);
    new Tip('ProtocolHelp','Data storage protocol for data files to be fetched.  ' +
        '<br>"Fits" causes the data to be converted to full fits files with header information filled from the DRMS records.  ' +
        '<br>"As-is" leaves the data as it is used inside the JSOC DRMS system, ' +
        'with the header metadata stored in the database rather than with the data file.  ' +
        '"As-is" is faster since the data does not need to be rewritten.  In as-is mode the header data is ' +
        'provided in a tab-delimited file named {RequestID}.keywords.txt. <br> The "jpeg" option will ' +
        ' yield  jpeg images of the data and the <br>"mpg" or "mp4" options will ' +
        ' yield a movie along with the jpeg images that make up the frames in the movie.<br> ' +
        'Default colortables and scaling for protocols making images are provided but may be altered.',tipstyle);
    new Tip('CompressHelp','Compression parameters to be used by the cfitsio library.  ' +
        'One comma separated string for each segment name in your export will be generated. ' +
        'Use "**NONE**" to indicate uncompressed FITS files desired. ' +
        'Note that e.g. AIA data can be more than 5 times larger if not compressed.  Do not request uncompressed ' +
        'exports for more than a few files.',tipstyle);
    new Tip('RequestorHelp','Optional place for your name, this will be used later when we have a way of saving your ' +
        'preferred export options.  This value will be saved in a Cookie if allowed.',tipstyle);
    new Tip('NotifyHelp','Email address to be used to notify you when the export is complete and ready to be ' +
        'fetched using the RequestID. NOTE - an email address is required for exports from jsoc2.',tipstyle);
    new Tip('SendFileHelp','This action will submit the export request with the RecordSet specified in the upload file.',tipstyle);
    new Tip('CheckParamHelp','This button is required to verify all fields used to specify the export request ' +
        'have been filled in in a consistent way.  If all is OK, the Submit button will be enabled.  A new Check ' +
        'button press is required before each export request.',tipstyle);
    new Tip('SubmitHelp','This button does the actual export request submission.  After a submit request the button ' +
        'action is changed to a Status Request which can be used to get the response from JSOC.  For all but url-direct and ' +
        'url-quick methods a RequestID tag will be returned a few seconds after a submit request.  ' +
        'This tag will be used to identify ' +
        'your export request inside JSOC and may be used at a later time to request the processing status and to ' +
        'obtain a link to your data.',tipstyle);
    new Tip('FetchCheckboxHelp','When this box is checked, the URL string that will be sent to the JSOC jsoc_fetch ' +
        'command will be shown when the "Check Params for Export" button is pressed.  This string can be used to ' +
        'help you develop script driven exports and to see how exportdata functions.',tipstyle);
    }
  };

</script>
<script type="text/javascript" src="exportdata.d/addOnTips.js"></script>
<script type="text/javascript">

function CreateTips()
  {
  var tipstyle =
    {
    style:'protoblue',
    hook:{target:'topRight',tip:'bottomLeft'},
    stem:'bottomLeft',
    closeButton:false,
    hideAfter:5,
    hideOn:'click',
    showOn:'click',
    border:3,
    radius:3,
    width:300,
    };

  MainTips(tipstyle);
  AddOnTips(tipstyle, Tip);
  TipsCreated = 1;
  $$("span.tip").each(function(showspan){showspan.show();}); 
  }

function HideTips()
  {
  $$("span.tip").each(function(hidespan){hidespan.hide();}); 
  Tips.hideAll();
  }

function ToggleHelp()
  {
  if (TipsEnabled)
    {
    HideTips();
    $("TipsOnOffButton").value = "Turn Help On";
    TipsEnabled = 0;
    }
  else
    {
    CreateTips();
    $("TipsOnOffButton").value = "Turn Help Off";
    TipsEnabled = 1;
    }
  }

// Check list of seriesnames for which processing options are not available for SeriesName spec given
function CheckNoProcessingList()
  {
  var n = NoProcessingList.length;
// alert("NoProcessingList length = "+n+" SeriesName="+SeriesName);
  var i;
  var result = 1;
  var prior = ProcessingAllowed;
  for (i=0; i<n; i++)
    if (SeriesName == NoProcessingList[i])
      result = 0;
  ProcessingAllowed = result;
  if (ProcessingAllowed != prior)
    ProcessingEnabled();
  }

function FileUploadCleanup()
  {
  ExportQueryOK = 0;
  $("ExportRecordSet").value = "";
  ExportRecordSetOK = 0;
  ExportFromFileList = 0;
  $("FileUploadCheckbox").checked = 0;
  $("RSCountPlace").innerHTML = "";
  $("ExportButton").value = "Submit Export Request";
  $("AjaxExportRequestRow").style.display="table-row";
  $("FileUploadInfoRow").style.display="none";
  $("RecordSetRow").style.display="table-row";
  $("RecordCountRow").style.display="table-row";
  $("ExportOpID").value = "exp_request";
  }
  
function FileUploadWanted()
  {
  ExportQueryOK = 0;
  if (ExportFromFileList == 0)
    {
    $("ExportRecordSet").value = "*file*";
    ExportRecordSetOK = 1;
    ExportFromFileList = 1;
    $("FileUploadCheckbox").checked = 1;
    $("RecordSetRow").style.display="none";
    $("RecordCountRow").style.display="none";
    $("ExportOpID").value = "exp_request";
    $("FileUploadRow").style.display="table-row";
    $("FileUploadInfoRow").style.display="none";
    $("AjaxExportRequestRow").style.display="none";
    }
  else
    {
    $("FileUploadInfoRow").style.display="none";
    FileUploadCleanup();
    FinishFileUpload();
    }
  }

function insertOption(list,text,note)
  {
  var y=document.createElement('option');
  y.value=text;
  if (note.length)
    y.text = text + "  --- " + note;
  else
    y.text = text;
  var x = $(list);
  try
    {
    x.add(y,null); // standards compliant
    }
  catch(ex)
    {
    x.add(y); // IE only
    }
  }

function MakeFileUploadRequest()
  {
  if (CheckExportParams(1) == 0)
    return;
  uploadOndoneAction = 1;
// XXXX fix compression here
  $("FileUploadFormID").action = 'http://' + Host + '/cgi-bin/ajax/' + JSOC_FETCH;
  $("FileUploadFormID").submit();
  }

function uploadDone()
  { //Function will be called when iframe is loaded
  if (uploadOndoneAction == 1)
    {
    var response = window.frames[0].document.getElementsByTagName("body")[0].innerHTML;
    var status = ProcessExportResponse(response);
    var op = "exp_upload";
    uploadOndoneAction = 0;
    }
  }

function FinishFileUpload()
  {
  window.frames[0].document.getElementsByTagName("body")[0].innerHTML = "";
  $("FileUploadRow").style.display="none";
  uploadOndoneAction = 0;
  }

function CallLookdata()
  { 
  var recset = $("ExportRecordSet").value;
  var posbracket = recset.indexOf("[");
  var posRbracket = recset.lastIndexOf("]");
  var posCurlbracket = recset.indexOf("{");
  var firstbracket = posbracket>=0 ? posbracket : posCurlbracket;
  var seriesname = (firstbracket == -1 ? recset : recset.substring(0,firstbracket));
  var recfilt = (posbracket >=0 ? recset.substring(posbracket,posRbracket+1) : "");
  var recordcount = RecordCount + "";
  var lookdataargs="ds="+seriesname;
  if (recfilt.length > 0 || RecordCount > 0)
    lookdataargs += "&rs=" + recfilt + "&n=" + recordcount;
  LookdataWindow=window.open("http://" + Host + "/ajax/" + LOOKDATA + ".html?" + encodeURIComponent(lookdataargs), "JSOC Lookdata");
  LookdataWindow.window.focus();
  }

var RSCountActiveMSg = "Getting count - wait...";

// Class
function WlSeriesInfo()
{
}

WlSeriesInfo.info = {};
WlSeriesInfo.intSeries = {}; // hash of record-set specifications to internal series

// filter is an array of regexps, where each regexp identifies a set of series.
// If you want to find all series that contain the string 'su_arta' or 'su_jim',
// then pass in a filter of ['su_arta', 'su_jim']. This function will convert
// this to 'su_arta|su_jim' then use that when querying the database.
WlSeriesInfo.prototype.getInfo = function(args)
{
    var filter = args.args[0];
    var callback = args.cbfn; // updateServersFn
    var callbackArgs = args.cbargs;
    
    var filterStr = filter.join('|');
    var url = 'http://' + Host + '/cgi-bin/ajax/' + SHOW_WLSERIES;
    
    // Map the host name (e.g., "jsoc2.stanford.edu") to the seriesname server (e.g., "hmidb").
    var seriesnameServer = serverMap[Host.toLowerCase()];
    
    $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
    
    new Ajax.Request(url,
    {
         method: 'get',
         parameters: { "server" : seriesnameServer, "filter" : filterStr },
         onSuccess: function(transport, json)
         {
             $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
                     
             var response = transport.responseText || null;
             var seriesInfo = response.evalJSON();
             var seriesArr = seriesInfo.seriesList
             
             if (seriesArr.length == 0)
             {
                 alert("There are no series that match '" + filterStr + "' accessible from " + Host + '.');
             }
             else
             {
                 for (var iarr = 0; iarr < seriesArr.length; iarr++)
                 {
                     var snameMixed = Object.keys(seriesArr[iarr])[0];
                     var sname = snameMixed.toLowerCase();
                     
                     if (WlSeriesInfo.info[sname] == undefined)
                     {
                         WlSeriesInfo.info[sname] = {};
                     }
                     
                     WlSeriesInfo.info[sname].server = seriesArr[iarr][snameMixed].infoDB;
                 }

                 callback(callbackArgs);
             }
         },
         onFailure: function() { alert('Unable to get information for series regexp ' + "'" + filterStr + "'."); },
         onComplete: function() { $("AjaxBusy").innerHTML = Ajax.activeRequestCount; }
    });
    
    $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
};

WlSeriesInfo.prototype.getServer = function(args)
{
    var spec = args.args[0]; // a string
    var snames = args.args[1]; // a list
    var callback = args.cbfn; // jsoc_fetch
    var callbackArgs = args.cbargs;
    var filter = [];
    var intSeries = []; // A list of internal series.
    
    WlSeriesInfo.intSeries[spec] = [];
    
    for (var iseries = 0; iseries < snames.length; iseries++)
    {
        var sname = snames[iseries].toLowerCase();

        if (WlSeriesInfo.info[sname] == undefined)
        {
            filter[filter.length] = sname;
        }
        else if (WlSeriesInfo.info[sname].server == 'hmidb')
        {
            intSeries[intSeries.length] = sname;
            // Add cached internal series to list of internal series for this spec.
            WlSeriesInfo.intSeries[spec][WlSeriesInfo.intSeries[spec].length] = sname;
        }
    }
    
    if (filter.length > 0)
    {
        var updateServersFn = function(args)
        {
            var spec = args[0];
            var snames = args[1];

            for (var iseries = 0; iseries < snames.length; iseries++)
            {
                var sname = snames[iseries].toLowerCase();
                
                if (WlSeriesInfo.info[sname].server == 'hmidb')
                {
                    // Newly discovered internal series.
                    // If at least one of the series needs series info from the internal database, then we need
                    // to use jsoc2 for the following jsoc_fetch request.
                    intSeries[intSeries.length] = sname;
                    WlSeriesInfo.intSeries[spec][WlSeriesInfo.intSeries[spec].length] = sname;
                }
            }
            
            // Also must call the callback passed to the getServer() function. Hopefully JS realizes these are defined outside
            // this function.
            callbackArgs.args[callbackArgs.args.length] = intSeries; // Append host; the jsoc_fetch arguments are the 0th argument already.
            callback(callbackArgs);
        };

        getInfoFnArgs = {};
        getInfoFnArgs.cbfn = updateServersFn;
        getInfoFnArgs.cbargs = [spec, filter];
        getInfoFnArgs.args = [filter];

        this.getInfo(getInfoFnArgs);
    }
    else
    {
        // Do not need to call show_wlseries. We just need to pass the list of internal series to jsoc_fetch.
        callbackArgs.args[callbackArgs.args.length] = intSeries; // Append host; the jsoc_fetch arguments are the 0th argument already.
        callback(callbackArgs);
    }
};

// Parse record-set specification (spec) to get a list of all series names in the spec. This function sends that list to the WlSeriesInfo.getServer() method.
// THAT method finds out which database server contains the DRMS series information.
WlSeriesInfo.prototype.extractSnames = function(args)
{
    var spec = args.args[0];
    var callbackObj = args.cbfnobj;
    var callbackObjMeth = args.cbfnobjmeth; // getServer
    var callbackArgs = args.cbargs;
    var snames = [];
    
    $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
    
    new Ajax.Request('http://' + Host + '/cgi-bin/' + PARSE_RECSET,
    {
        method: 'get',
        parameters: { "spec" : spec },
        onSuccess: function(transport, json)
        {
            $("AjaxBusy").innerHTML = Ajax.activeRequestCount;

            var response = transport.responseText || null;
            var parseInfo = response.evalJSON();

            if (parseInfo.subsets.length > 0)
            {
                for (var iset = 0; iset < parseInfo.subsets.length; iset++)
                {
                    snames[snames.length] = parseInfo.subsets[iset].seriesname;
                }
            }
            else
            {
                alert("Invalid record-set specification: '" + spec + "'.")
            }

            callbackArgs.args = [spec, snames];
            callbackObj[callbackObjMeth](callbackArgs);
        },
        onFailure: function() { alert('Unable to parse record-set specficiation ' + "'" + spec + "'."); },
        onComplete: function() { $("AjaxBusy").innerHTML = Ajax.activeRequestCount; }
     });
     
     $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
};

// Get the db host that we should use for this spec. If this page is on the external site, but we are accessing a sanctioned internal
// series, then we need to use the internal db server (hmidb). spec could (eventually) have more than one series in it. If that is
// the case, then if at least one series requires the internal db server, use that one. All external series are available from the
// internal db server at this point.
WlSeriesInfo.prototype.determineHost = function(args)
{
    var spec = args.args[0];
    var callerid = args.args[1];
    var callback = args.cbfn; // jsoc_fetch
    var callbackArgs = args.cbargs;
    
    // Gotta figure out which host to use.
    if (Host.match(/^\s*jsoc2/))
    {
        // This is the internal page. Just use [] for the list of intSeries (not used when the user is on the internal web site).
        callbackArgs.args[callbackArgs.args.length] = [];
        callback(callbackArgs);
    }
    else
    {
        if (WlSeriesInfo.intSeries[spec])
        {
            // We know the internal series for this specification.
            intSeries = WlSeriesInfo.intSeries[spec];
            callbackArgs.args[callbackArgs.args.length] = intSeries;
            callback(callbackArgs);
        }
        else
        {
            // jsoc.stanford.edu is the external website. We need to figure out
            // if the user is accessing internal series that are sanctioned for use externally.
            var getServerFnArgs = {};
            getServerFnArgs.cbfn = args.cbfn;
            getServerFnArgs.cbargs = args.cbargs;
            
            var extractSnamesFnArgs = {};
            extractSnamesFnArgs.cbfnobj = this;
            extractSnamesFnArgs.cbfnobjmeth = 'getServer';
            extractSnamesFnArgs.cbargs = getServerFnArgs;
            extractSnamesFnArgs.args = [spec];
            
            this.extractSnames(extractSnamesFnArgs);
        }
    }
};

// Internal-DB pass-through.
// If the user is accessing the external website, the database source of the series information could be the internal database.
// External users have access to a sanctioned list of internal data series. So, we do not necessarily want to use the 'Host'
// variable to identify the jsoc_info CGI. If the user is accessing a sanctioned internal series, then we need to use the jsoc_info
// CGI hosted on jsoc2.stanford.edu, not the one on 'Host' (which is jsoc.stanford.edu).
function GetRSCount()
  {
  ExportQueryOK = 0;
  var recset = $("ExportRecordSet").value;


  var recfilt, segfilt;
  var posbracket = recset.indexOf("[");
  var posRbracket = recset.lastIndexOf("]");
  var posCurlbracket = recset.indexOf("{");
  var posCurlRbracket = recset.lastIndexOf("}");
  if ((posbracket>=0 && posRbracket < posbracket) || 
      (posRbracket>=0 && posbracket < 0) ||
      (posCurlbracket>=0 && (posCurlRbracket < posCurlbracket || posCurlbracket < posbracket || posCurlbracket < posRbracket)) ||
      (posCurlRbracket>=0 && posCurlbracket < 0))
       {
       $("RSCountPlace").innerHTML = "ERROR - missing or wrong bracket or seglist precedes record filter";
       return(1);
       }
  var firstbracket = posbracket>=0 ? posbracket : posCurlbracket;
  SeriesName = (firstbracket == -1 ? recset : recset.substring(0,firstbracket));
  if (SeriesName.length < 3)
    {
    $("RSCountPlace").innerHTML = "ERROR - missing SeriesName";
    return(1);
    }
  recfilt = (posbracket >=0 ? recset.substring(posbracket,posRbracket+1) : (RecordLimit == 0 ? "[$]" : ""));
  segfilt = (posCurlbracket >=0 ? recset.substring(posCurlbracket,posCurlRbracket+1) : "");
  $("ExportRecordSet").value = SeriesName + recfilt + segfilt;
  
  $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
  $("RSCountPlace").innerHTML = RSCountActiveMSg;
  RecordCount = -1;
  var RecordSet = $("ExportRecordSet").value;
  
    // Internal-db pass-through. We need to determine which host has the series information needed.
    var doInfoReqFn = function(args)
    {
        var intSeries = args.args[0]; // A list
        var script = null;
        var arguments = { "ds" : RecordSet, "op" : "rs_summary", "n" : RecordLimit };
        
        if (intSeries.length > 0)
        {
            arguments.series = intSeries.join();
            script = JSOC_INFO_X; // Uses internal db.
        }
        else
        {
            script = JSOC_INFO;
        }
  
        $("AjaxBusy").innerHTML = Ajax.activeRequestCount;

        new Ajax.Request('http://' + Host + '/cgi-bin/ajax/' + script,
        {
            method: 'get',
            parameters: arguments,
            onSuccess: function(transport, json)
            {
                var response = transport.responseText || "no response text";
                var data = response.evalJSON();
                
                if (data.status != 0)
                {
                    RecordCount = 0;
                    $("RSCountPlace").innerHTML = "No RecordSet Count Found";
                    ExportRecordSetOK = 0;
                }
                else
                {
                    RecordCount = data.count;
                    $("RSCountPlace").innerHTML = data.count;
                    ExportRecordSetOK = 1;
                }
                         
                $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
                //if ($("ProcessingCheckbox").checked == false)
                //{
                //$("ProcessingWaitMessage").style.display = "none"; 
                //}
                CheckRediness();
            },
            onFailure: function() { alert('Something went wrong...'); },
            onComplete: function() { $("AjaxBusy").innerHTML = Ajax.activeRequestCount; }
        });
        
        $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
    }

    var wlInfo = new WlSeriesInfo();
    
    var doInfoReqFnArgs = {};
    doInfoReqFnArgs.args = [];
    doInfoReqFnArgs.cbfn = null;
    doInfoReqFnArgs.cbargs = null;
    
    var determineHostFnArgs = {};
    // exportparameters contains the record-set specification in the 'ds' key (The Hash() class is implemented by
    // prototype). We need the seriesname(s) from this argument. There is supposed to be an 'item' method for Hash(),
    // but it doesn't seem to work. Use 'toObject' instead ('arguments' contains the results of this call).
    determineHostFnArgs.args = [RecordSet, 'GetRSCount'];
    determineHostFnArgs.cbfn = doInfoReqFn;
    determineHostFnArgs.cbargs = doInfoReqFnArgs;
    
    wlInfo.determineHost(determineHostFnArgs);
    
  return(0);
  }

function GetDefaultFormat()
  {
  $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
  $("RSCountPlace").innerHTML = "Getting count - wait...";
  RecordCount = -1;
  var RecordSet = $("ExportRecordSet").value;
  
  var doInfoReqFn = function(args)
  {
    var intSeries = args.args[0]; // A list
    
    // CANNOT open a page or run a CGI on jsoc2 if the user is accessing jsoc. Access-Control-Allow-Origin prevents this.
    // Instead ALWAYS use Host for the domain, but if the host the web resource is being served by is the external host,
    // but we need to access the internal host, then use a special cgi program that uses the internal db. This cgi
    // will do a check to make sure that an external user isn't attempting to use the internal db for series that are not
    // whitelisted.
    var script = null;
    var arguments = {"ds" : RecordSet, "op" : "series_struct", "l" : 1 };
    
    if (intSeries.length > 0)
    {
        arguments.series = intSeries.join();
        script = JSOC_INFO_X; // Uses internal db.
    }
    else
    {
        script = JSOC_INFO;
    }
    
    new Ajax.Request('http://' + Host + '/cgi-bin/ajax/' + script,
    {
        method: 'get',
        parameters: arguments,
                       
        onSuccess: function(transport, json)
        {
            var response = transport.responseText || "no response text";
            SeriesInfo = response.evalJSON();
            if (SeriesInfo.status == 0)
            {
                var nprimes = SeriesInfo.primekeysinfo.length;
                var nkeys = SeriesInfo.keywords.length;
                if (nprimes == 0)
                {
                    $("ExportFilenameFmt").value = SeriesName + ".{recnum:%lld}.{segment}";
                }
                else
                {
                    var newfmt = SeriesName + ".";
                    var i;
                    for (i=0; i<nprimes; i++)
                    {
                        var thisprime = SeriesInfo.primekeys[i];
                        var j;
                        for  (j=0; j<nkeys; j++)
                        {
                            var thiskey = SeriesInfo.keywords[j].name;
                            if (thiskey === thisprime)
                            {
                                if (SeriesInfo.keywords[j].type === "time")
                                {
                                    newfmt = newfmt + "{" + thisprime + ":A}.";
                                    if (firstTimePrime ==="") firstTimePrime = thisprime;
                                }
                                else
                                newfmt = newfmt + "{" + thisprime + "}.";
                                break;
                            }
                        }
                    }
                    newfmt = newfmt + "{segment}";
                    $("ExportFilenameFmt").value = newfmt;
                }
                firstRealSegment = "";
                var nsegs = SeriesInfo.segments.length;
                for (var iseg=0; iseg<nsegs; iseg++)
                {
                    var thisProtocol = SeriesInfo.segments[iseg].protocol;
                    if (thisProtocol === "fits")
                    {
                        firstRealSegment = SeriesInfo.segments[iseg].name;
                        break;
                    }
                }
            }
            else
                alert("failed to get series info for " + RecordSet + "\nEnter correct RecordSet or proceed to processing options");
            $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
        },
        onFailure: function() { alert('Something went wrong...'); },
        onComplete: function() { $("AjaxBusy").innerHTML = Ajax.activeRequestCount; }
    });
  };

    var wlInfo = new WlSeriesInfo();
    
    var doInfoReqFnArgs = {};
    doInfoReqFnArgs.args = [];
    doInfoReqFnArgs.cbfn = null;
    doInfoReqFnArgs.cbargs = null;
    
    var determineHostFnArgs = {};
    determineHostFnArgs.args = [RecordSet, 'GetDefaultFormat'];
    determineHostFnArgs.cbfn = doInfoReqFn;
    determineHostFnArgs.cbargs = doInfoReqFnArgs;
    
    wlInfo.determineHost(determineHostFnArgs);
  }

function CreateDataTable(data, valuetable)
  {
  $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
  // valuetable = "";
  // var count = data.count;
  var count = data.data.length;
  valuetable = "<table border='1'>";
  valuetable = valuetable + "<tr><td>File<\/td><td>Record<\/td><td>Filename<\/td><\/tr>";
  for (ifile=0; ifile < count; ifile++)
    {
    valuetable = valuetable + "<tr>";
    valuetable = valuetable +  "<td>" + (ifile + 1) + "<\/td>";
    valuetable = valuetable +  "<td>" + data.data[ifile].record + "<\/td>";
    thisfile = data.data[ifile].filename;
    if (data.method.indexOf("tar") > 0)
      valuetable = valuetable +  "<td>" + thisfile + "<\/td><\/tr>";
    else
      {
      if (data.method.indexOf("ftp") >= 0)
        expURL = "ftp://pail.stanford.edu/export" + data.dir + "/" + thisfile;
      else
        expURL = "http://jsoc.stanford.edu" + data.dir + "/" + thisfile;
      tmp = "<a href='" + expURL + "' target='_blank'>" + thisfile + "<\/a>";
      valuetable = valuetable +  "<td>" + tmp + "<\/td><\/tr>";
      }
    }
  valuetable = valuetable + "<\/table>";
  return valuetable;
  }

function ExportNop()
  {
  }

function ExportRSChanged()
  {
  ExportQueryOK = 0;
  RecordCountNeeded = 1;
  $("CountButton").style.backgroundColor = colorYellow;
  // CheckRediness();
  ExportNewRS(); // to fix opeator not pressing enter or count.
  }

function ExportNewRS()
  {
  ExportQueryOK = 0;
  $("CountButton").style.backgroundColor = colorNeutral;
  RecordCountNeeded = 0;
  if (SetRecordLimit())
    return; // SetRecordLimit calls GetRSCount(), non-zero on RS syntax error
  firstTimePrime = "";
  GetDefaultFormat();
  CheckNoProcessingList();
  NotifyProcessingCode();
  CheckRediness();
  }

function SetRecordLimit()
  {
  var newLimit;
  newLimit = 1 * $("ExportRecordLimit").value;
  if (isNaN(newLimit))
    {  // newlimit is a non-numeric string
    newLimit = $("ExportRecordLimit").value;
    if (newLimit == "none")
      RecordLimit = 0;
    else
      {
      $("ExportRecordLimit").style.backgroundColor = colorRed;
      alert("RecordLimit must be a number or 'none'");
      RecordLimit = 0;
      }
    }
  else
    {
    if (newLimit == 0)
      $("ExportRecordLimit").value = "none";
    RecordLimit = newLimit;
    }
  $("ExportRecordLimit").style.backgroundColor = colorWhite;
  return(GetRSCount());
  }

function SetExportMethod(byWhom)
  {
  // byWhom = 0 for user click, else 1
  if (byWhom == 0)
    ExportQueryOK = 0;
  var ExportMethodIndex = $("ExportMethod").selectedIndex;
  ExportMethodValue = $("ExportMethod").options[ExportMethodIndex].value;
  if (ExportMethodValue == "url_direct" || ExportMethodValue == "url_quick")
    {
    ExportMethodOK = 1;
    $("ProcessRow").style.display="none";
    var nProcs = ExportProcessingOptions.length;
    $(ExportProcessingOptions[0].id).checked = true;
    for (var iProc=1; iProc < nProcs; iProc++)
      { 
      var ExpOpt = ExportProcessingOptions[iProc];
      $(ExpOpt.id).checked = false;
      $(ExpOpt.rowid).style.display = "none";
      }
    if (ExportMethodValue == "url_direct")
      {
      $("ProtocolRow").style.display="table-row";
      ExportMethodIsDirect = 1;
      }
    else
      {
      $("ProtocolRow").style.display="none";
      ExportMethodIsDirect = 0;
      }
    $("FilenameFmtRow").style.display="none";
    ExportProtocolValue = "as-is";
    $("ExportProtocol").selectedIndex = 0;
    ExportCompressValue = "";
    // $("ExportCompress").selectedIndex = 1;
    $("CompressRow").style.display="none";
    $("RequestorRow").style.display="none";
    $("NotifyRow").style.display="none";
    }
  else if (ExportMethodValue == "url" ||
           ExportMethodValue == 'ftp' ||
           ExportMethodValue == "url-tar" ||
           ExportMethodValue == 'ftp-tar')
    {
    ExportMethodOK = 1;
    $("ProcessRow").style.display="table-row";
    $("ProtocolRow").style.display="table-row";
    $("FilenameFmtRow").style.display="table-row";
    $("RequestorRow").style.display="table-row";
    $("NotifyRow").style.display="table-row";
    // PHS turn off compression option
    // if(ExportProtocolValue == "FITS")
       // $("CompressRow").style.display="table-row";
    if (byWhom == 0)
      $("ExportCompress").selectedIndex = 0;
    }
  else
    {
    alert("Please set Method to url_quick, url_direct,  url, or ftp");
    ExportMethodOK = 0;
    }
  CheckRediness();
  }

function SetExportFilenameFmt()
  {
  ExportQueryOK = 0;
  if ($("ExportFilenameFmt").value.length != 0)
    ExportFilenameFmtOK = 1;
  else
    {
    alert("Please set non-empty name for FilenameFmt");
    ExportFilenameFmtOK = 0;
    }
  CheckRediness();
  }

function ProcessingEnabled()
  {
  ExportQueryOK = 0;
  if ($("ProcessingCheckboxHide").checked)
    $("ProcessingCheckbox").checked = false;
  if ($("ProcessingCheckbox").checked)
    {
    if ($("ExportRecordSet").value == "" || $("ExportRecordSet").value == "[$]")
      {
      $("ProcessingWaitMessage").style.display = "table-row";
      $("ProcessingCheckbox").checked = false;
      return;
      }
    $("ProcessingWaitMessage").style.display = "none";
    $("ProcessingCheckbox").checked = true;
    $("ProcessingCheckboxHide").checked = false;
    $("ProcessingShowCheckbox").style.display = "none";
    $("ExportProcessing").style.display = "table-row";
    }
  else
    {
    $("ProcessingCheckbox").checked = false;
    $(ExportProcessingOptions[0].id).checked = true;
    $("ExportProcessing").style.display = "none";
    if (ProcessingAllowed == 0)
      {
      $("ProcessingWaitMessage").style.display = "table-row";
      $("ProcessingWaitMessage").innerHTML = "Processing not available for series " + SeriesName;
      $("ProcessingCheckboxHide").checked = true;
      $("ProcessingShowCheckbox").style.display = "none";
      }
    else
      {
      $("ProcessingWaitMessage").style.display = "none";
      $("ProcessingCheckboxHide").checked = false;
      $("ProcessingShowCheckbox").style.display = "table-row";
      }
    SetProcessing(0);
    }
  }

var SizeRatio;

function SetProcessing(ichecked)
  { // 0 if no procesing enabled,  -1 if same seriesname, -2 if changed
  ExportQueryOK = 0;
  if (ProcessingAllowed == 0)
    {
    $(ExportProcessingOptions[0].id).checked = true;
    }
  if (ichecked > 0) $(ExportProcessingOptions[0].id).checked = false;
  ExportProcessingOK = 0;
  // Add recordLimit FIRST always.
  ExportProcessingArgs = "n=" + RecordLimit;
  var isok = 1;
  var nchecked = 0;
  var iProc = 0;
  var nProcs = ExportProcessingOptions.length;
  SizeRatio = 1.0;
  if ($(ExportProcessingOptions[0].id).checked) // no_op case must be first
    {
    nchecked++;
    for (iProc=1; iProc<nProcs; iProc++)
      {
      var ExpOpt = ExportProcessingOptions[iProc];
      $(ExpOpt.id).checked = false;
      $(ExpOpt.rowid).style.display = "none";
      }
    ExportProcessingArgs += "|no_op";
    }
  else
    {
    for (iProc=1; iProc<nProcs; iProc++)
      {
      var ExpOpt = ExportProcessingOptions[iProc];
      if ($(ExpOpt.id).checked)
        {
        nchecked++;
        $(ExportProcessingOptions[0].id).checked = false;
        if (ichecked == -2)
          {
          ExpOpt.Init(0);
          $(ExpOpt.rowid).style.display="table-row";
          isok = 0;
          }
        else
          {
          ExpOpt.Init(1);
          $(ExpOpt.rowid).style.display="table-row";
          var args = ExpOpt.Check();
          if (args.length > 0)
            {
            ExportProcessingArgs += "|"+args;
            SizeRatio *= ExpOpt.Size;
            }
          // else
            // {
            // ExportProcessingArgs += "|--ERROR>>"+args+"<<";
            // isok = 0;
            // }
          }
        }
      else
        {
        $(ExpOpt.rowid).style.display="none";
        ExpOpt.Init(0);
        }
      }
    }
  if (nchecked == 0)
    {
    $(ExportProcessingOptions[0].id).checked = true;
    SetProcessing(0);
    }
  $("ExportSizeRatio").value = SizeRatio;
        
  $("ExportProcessingHidden").value = ExportProcessingArgs;
  if (isok)
    ExportProcessingOK = 1;
  else
    ExportProcessingOK = 0;
  CheckRediness();
  }

function SetExportProtocol(byWhom)
  { 
  // byWhom = 0 for user click, else 1
  if (byWhom == 0)
    ExportQueryOK = 0;
  var ExportProtocolIndex = $("ExportProtocol").selectedIndex;
  ExportProtocolValue = $("ExportProtocol").options[ExportProtocolIndex].value;

  if (ExportProtocolValue == "as-is" || ExportProtocolValue == "FITS")
    { // Handle file protocols
    if (ExportProtocolValue == "as-is")
      {
      ExportProtocolOK = 1;
      $("CompressRow").style.display="none";
      $("ExportProtocolHidden").value = "as-is";
      ExportCompressValue = "";
      }

    else if (ExportProtocolValue == "FITS")
      {
      ExportProtocolOK = 2;
      // PHS hide compression option row
      // $("CompressRow").style.display="table-row";
      $("ExportProtocolHidden").value = "FITS";
      if (byWhom == 0)
        $("ExportCompress").selectedIndex = 0;
      var ExportCompressIndex = $("ExportCompress").selectedIndex;
      ExportCompressValue = $("ExportCompress").options[ExportCompressIndex].value;
      }
    $("ProtocolImageOptions").style.display="none";
    }
  else
    { // Handle image protocols
    if (ExportProtocolValue == "MPEG")
      {
      ExportProtocolOK = 4;
      $("ProtocolImageOptions").style.display="table-row";
      $("CompressRow").style.display="none";
      $("ExportProtocolHidden").value = "mpg";
      }
    else if (ExportProtocolValue == "MP4")
      {
      ExportProtocolOK = 4;
      $("ProtocolImageOptions").style.display="table-row";
      $("CompressRow").style.display="none";
      $("ExportProtocolHidden").value = "mp4";
      }
    else if (ExportProtocolValue == "JPEG")
      {
      ExportProtocolOK = 3;
      $("ProtocolImageOptions").style.display="table-row";
      $("CompressRow").style.display="none";
      $("ExportProtocolHidden").value = "jpg";
      }
    // ProtocolOptionsSet: 0 if need to set defaults, 1 if defaults, 2 if user changed
    if (ProtocolOptionsSet == 0)
      ProtocolImageInit();
    if (ProtocolOptionsSet > 0)
      ProtocolImageCheck();
    }
  CheckRediness();
  }

function SetExportCompress()
  {
  ExportQueryOK = 0;
  var protocolparam = ExportProtocolValue;
  if (protocolparam == "FITS" || protocolparam == "as-is")
    {
    if (ExportRecordSetOK)
      {
      var ExportCompressIndex = $("ExportCompress").selectedIndex;
      ExportCompressValue = $("ExportCompress").options[ExportCompressIndex].value;
      for (var i=0; i < SeriesInfo.segments.length; i++)
        {
        var segtype = SeriesInfo.segments[i].type;
        if (ExportCompressValue == "compress Rice" &&  protocolparam == "FITS" && (segtype == "float" || segtype == "double"))
          protocolparam = protocolparam  + ",**NONE**";
        else if (protocolparam == "FITS")
          // PHS do not allow uncompressed.  13 Nov 2014
          // protocolparam = protocolparam  + "," + ExportCompressValue;
          protocolparam = protocolparam  + "," + "compress Rice";
        }
      $("ExportProtocolHidden").value = protocolparam;
      ExportCompressOK = 1;
      }
    else
      {
      ExportCompressOK = 0;
      }
    }
  CheckRediness();
  }

function SetExportUser()
  {  
  ExportQueryOK = 0;
  var tmp1 = $("ExportRequestor").value.toUpperCase();
  if (tmp1.length != 0 && tmp1 !== "NONE")
    {
    Cookie.setData("user", $("ExportRequestor").value);
    ExportUserOK = 1;
    }
  else
    {
    $("ExportRequestor").value = "none";
    ExportUserOK = 0;
    }
  SetExportNotify();
  }

function SetExportNotify()
  {   
  // ExportNotifyOK values:
  //  0 - not OK to proceed
  //  1 - OK to proceed for internal or external real email
  //  2 - OK, email is SolarMail and Requestor not empty.
  //  3 - OK, quick or external with no email to be sent
  ExportQueryOK = 0;
  var tmp1 = $("ExportNotify").value.toUpperCase();
  if (ExportMethodValue == "url_direct" || ExportMethodValue == "url_quick")
    {
    ExportNotifyOK = 3;
    $("ExportNotify").value = "none";
    }
  else if (tmp1.length == 0)
    {
    // as of 14 Nov 2014 ask for passwords for all exports
    // if (Internal)
    // {
      ExportNotifyOK = 0;
      $("ExportNotify").value = "solarmail";
    // }
    // else
      // {
      // ExportNotifyOK = 3;
      // $("ExportNotify").value = "none";
      // }
    }
  else if ( tmp1 ===  "SOLARMAIL" )
    {
    if (ExportUserOK)
      ExportNotifyOK = 2;
    else
      ExportNotifyOK = 0;
    }
  else if (tmp1 == "NONE" || tmp1 == "NO")
    {
    // if (Internal)
      ExportNotifyOK = 0;
    // else
      // ExportNotifyOK = 3;
    }
  else if ($("ExportNotify").value.indexOf("@") < 0)
    ExportNotifyOK = 0;
  else
    ExportNotifyOK = 1;
  CheckRediness();
  }

function ExportShowQuery()
  {
  if ($("ShowQueryCheckbox").checked)
    {
    var paramString = decodeURIComponent(Object.toQueryString(exportparameters));
    $("ExportParameters").innerHTML = paramString.replace(/&/g,"&amp;");
     }
  else
    $("ExportParameters").innerHTML = "";
  }

function CheckRediness()
  {
  var status = ExportQueryOK * ExportRecordSetOK * ExportMethodOK * ExportFilenameFmtOK * ExportProcessingOK * ExportProtocolOK * ExportNotifyOK;
  if (status)
    {
    $("ExportButtonMsg").innerHTML = "Please only click once for export request.";
    $("ExportButton").value = "Submit Export Request";
    $("ExportButton").style.backgroundColor = colorGreen;
    $("ExportCheckMsg").innerHTML = "";
    $("ExportCheckButton").style.backgroundColor = colorGreen;
    }
  else
    {
    $("ExportCheckButton").style.backgroundColor = colorYellow;
    $("ExportButton").value = "Not Ready To Submit";
    $("ExportButton").style.backgroundColor = colorRed;
    }
  ExportRedinessStatus = status;
  return(status);
  }

function CheckExportParams()
  {
  if ($("RSCountPlace").innerHTML == RSCountActiveMSg)
    {
    $("ExportCheckButton").style.backgroundColor = colorYellow;
    $("ExportCheckMsg").innerHTML = "Still counting records, wait a second then retry";
    return(0);
    }
  while (1) // use with break instead of goto done.
    {
//XXXXX
    if (ExportRecordSetOK == 0)
      {
      GetRSCount();
      $("ExportCheckMsg").innerHTML = "RecordSet not verified, enter RecordSet then retry export request.";
      break;
      }
    SetExportMethod(1);
    if (ExportMethodOK == 0)
      {
      $("ExportCheckMsg").innerHTML = "Method not given, Enter export method then retry export request.";
      break;
      }
    SetExportFilenameFmt();
    if (ExportFilenameFmtOK == 0)
      {
      $("ExportCheckMsg").innerHTML = "FilenameFmt not given, Enter FilenameFmt then retry export request.";
      break;
      }
    SetProcessing(-1);
    if (ExportProcessingOK == 0)
      {
      $("ExportCheckMsg").innerHTML = "Processing details not correct, fix and retry export request.";
      break;
      }
    SetExportProtocol(1);
    if (ExportProtocolOK == 0)
      {
      $("ExportCheckMsg").innerHTML = "Protocol not given, Enter export protocol then retry export request.";
      break;
      }
    if ((ExportProtocolValue == "FITS" || ExportProtocolValue == "as-is") && ExportMethodValue != "url_quick")
      {
      SetExportCompress();
      }
    else if (protocolEnable)
      {
      ProtocolImageCheck();
      }
    SetExportUser();  // SetExportUser calls SetExportNotify
    if (ExportNotifyOK == 0)
      {
      if (ExportUserOK == 0)
        $("ExportCheckMsg").innerHTML = "Requestor not given, Enter name you will use in Requestor field then retry export request.  This field in required if Notify is 'solarmail'";
      // as of 14 Nov email requested for all exports
      // else if (Internal)
      else
          // $("ExportCheckMsg").innerHTML = "Notify email required for jsoc2, enter 'solarmail' or email address then retry export request.";
        $("ExportCheckMsg").innerHTML = "Notify email address required, enter 'solarmail' or email address then retry export request.";
      // else
          // $("ExportCheckMsg").innerHTML = "Notify email not given.  Enter 'none' or 'solarmail' or email address then retry export request.";
      break;
      }
    break;
    }

  var isOK = ExportRecordSetOK * ExportMethodOK * ExportFilenameFmtOK * ExportProcessingOK * ExportProtocolOK * ExportNotifyOK;
  if (isOK)
    {
    var protocolparam = $("ExportProtocolHidden").value;
    var RecordSet = $("ExportRecordSet").value;
    
    exportparameters = new Hash( {"op" : $("ExportOpID").value,
                 		      "ds" : RecordSet, 
                                      "sizeratio" : $("ExportSizeRatio").value,
                 		      "process" :  ExportProcessingArgs,
                 		      "requestor" : $("ExportRequestor").value,
                 		      "notify" : $("ExportNotify").value,
                                      "method" : ExportMethodValue,
                                      "filenamefmt" : $("ExportFilenameFmt").value,
			 	      "format" : "json",
                 		      "protocol" : protocolparam });

    ExportShowQuery();
    ExportQueryOK = 1;
    }
  else
    {
    exportparameters = null;
    $("ExportParameters").innerHTML = "";
    ExportQueryOK = 0;
    }
  var isOK = CheckRediness();
  return isOK;
  }


function GetExport() // This is the code executed when the user clicks on the "Submit Export Request" button.
  {
  // ExportReadyOK values
  // use this for state inside GetExport only, use ExportRedinessStatus to determine OK to proceed
  //  0 ready to begin export process
  //  1 ready for status request
  //  2 export complete, OK or failure.
  //  3 Process started, waiting response

  $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
  if (ExportReadyOK == 3)
    {
    alert("Processing request, please wait...");
    return;
    }
    
  if (ExportRedinessStatus) 
    {
    ExportRedinessStatus = 0;
    ExportReadyOK = 3;
    state = 2;
    Cookie.setData("state",state);
    $("ExportStatus").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("ExportLocation").innerHTML = "";
    $("ExportButtonMsg").innerHTML = "Export request submitted, please wait...";
    $("ExportButton").value = "Processing ...";
    $("ExportButton").style.backgroundColor = colorDarkRed;
    $("ExportCheckButton").style.backgroundColor = colorYellow;
    // var protocolparam = $("ExportProtocolHidden").value;
    // var RecordSet = $("ExportRecordSet").value;
    // exportparameters = new Hash( {"op" : $("ExportOpID").value,
                 		      // "ds" : RecordSet, 
                 		      // "process" :  ExportProcessingArgs,
                 		      // "requestor" : $("ExportRequestor").value,
                 		      // "notify" : $("ExportNotify").value,
                                      // "method" : ExportMethodValue,
                                      // "filenamefmt" : $("ExportFilenameFmt").value,
			 	      // "format" : "json",
                 		      // "protocol" : protocolparam });
    // // if (nsegsselected) exportparameters = exportparameters.merge({"seg": SegList});
    // $("ExportParameters").innerHTML = decodeURIComponent(Object.toQueryString(exportparameters));
    }
  else if (ExportReadyOK == 1)
    {
    var requestidtmp = $("RequestIdPlace").innerHTML;
    exportparameters = new Hash( {"op" : "exp_status","requestid":requestidtmp});
    }
  else // ExportReadyOK == 2
    {
    // $("ExportRecordSet").value = "";
    ExportRedinessStatus = 0;
    $("ExportCheckMsg").innerHTML = "Export Request Complete, Please check updated export params before making another export request";
    return;
    }

    var arguments = exportparameters.toObject();

    var doFetchReqFn = function(args)
    {
        var arguments = args.args[0];
        var intSeries = args.args[1];
        var script = null;
        
        if (intSeries.length > 0)
        {
            // The user is on the external website, but they are about to initiate a new export request on the internal system.
            // JSOC_FETCH_X will ensure that the internal series the user wants to access (in the series argument) are whitelisted.
            // Also, by setting the p flag to 1, this will tell jsoc_fetch (the binary) to create a _X_IN request ID.
            arguments.series = intSeries.join();
            arguments.p = 1;
            script = JSOC_FETCH_X; // Uses internal db.
        }
        else
        {
            script = JSOC_FETCH;
        }
        
        $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
        
        // Add a new argument that will direct jsoc_fetch to insert an 'X' into the request ID. The 'X' denotes a export
        // made from the external site, but which is performed as an internal-site insert because the request contains
        // references to one or more internals series.
        
        new Ajax.Request('http://' + Host + '/cgi-bin/ajax/' + script,
        {
            method: 'post',
            parameters: arguments,

            onSuccess: function(transport, json)
            {
                $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
                var response = transport.responseText || "no response text";
                var status = ProcessExportResponse(response);
                var op = $("ExportOpID").value;
            },
            onFailure: function()
            {
                $("ExportButtonMsg").innerHTML = "Export Failure, Problem at JSOC facility.";
                $("ExportButton").value = "FAILURE ...";
                $("ExportButton").style.backgroundColor = colorDarkPink;
                ExportReadyOK = 2;
                alert('Something went wrong...');
            },
            onComplete: function() { $("AjaxBusy").innerHTML = Ajax.activeRequestCount; }
        });
        
        $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
    };
    
    var wlInfo = new WlSeriesInfo();
    
    var doFetchReqFnArgs = {};
    doFetchReqFnArgs.args = [arguments];
    doFetchReqFnArgs.cbfn = null;
    doFetchReqFnArgs.cbargs = null;
    
    var determineHostFnArgs = {};
    // exportparameters contains the record-set specification in the 'ds' key (The Hash() class is implemented by
    // prototype). We need the seriesname(s) from this argument. There is supposed to be an 'item' method for Hash(),
    // but it doesn't seem to work. Use 'toObject' instead ('arguments' contains the results of this call).
    determineHostFnArgs.args = [arguments.ds, 'GetExport'];
    determineHostFnArgs.cbfn = doFetchReqFn;
    determineHostFnArgs.cbargs = doFetchReqFnArgs;
    
    wlInfo.determineHost(determineHostFnArgs);
  }

function GetReExport()
  {
  $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
  ExportReadyOK = 3;
  state = 2;
  Cookie.setData("state",state);
  $("ExportStatus").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("ExportLocation").innerHTML = "";
  $("ReExportButtonMsg").innerHTML = "Export request submitted, please wait...";
  $("ReExportButton").value = "Processing ...";
  $("ReExportButton").style.backgroundColor = colorPink;
  
  var paramObj = {"op" : "exp_repeat",
                  "requestid" : $("ReRequestID").value,
                  "format" : "json",
                  "notify" : $("ReExportNotify").value};
  
  exportparameters = new Hash(paramObj);
  
  // Use JSOC_FETCH_X, which accesses the internal db, if needed. And this is needed if the request ID string ends in
  // 'X_IN'.
  var script = JSOC_FETCH;
  var is_IN = ($("ReRequestID").value.search("_IN") > 0);
  
  if (is_IN && Host == "jsoc.stanford.edu")
  {
      var isExtOrigin = ($("ReRequestID").value.search("_X_IN") > 0);
      
      if (!isExtOrigin)
      {
          alert("RequestID ending with '_IN' belongs to jsoc2.stanford.edu, use proper RequestID or swtich to jsoc2.stanford.edu.");
          return;
      }
      
      script = JSOC_FETCH_X
  }
  else if (!is_IN && Host == "jsoc2.stanford.edu")
  {
      alert("RequestID without '_IN' belongs to jsoc.stanford.edu, use proper RequestID or switch to jsoc.stanford.edu.");
      return;
  }

    new Ajax.Request('http://' + Host + '/cgi-bin/ajax/' + script,
    {
        method: 'post',
        parameters: exportparameters.toObject(),

        onSuccess: function(transport, json)
        {
            $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
            var response = transport.responseText || "no response text";
            var status = ProcessExportResponse(response);
        },
        onFailure: function()
        {
            $("ReExportButtonMsg").innerHTML = "Export Failure, Problem at JSOC facility.";
            ExportReadyOK = 2;
            $("ReExportButton").value = "FAILURE ...";
            $("ReExportButton").style.backgroundColor = colorDarkPink;
            alert('Something went wrong...');
        },
        onComplete: function() { $("AjaxBusy").innerHTML = Ajax.activeRequestCount; }
    });
    $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
  }


function ProcessExportResponse(response)
  {
  var data = response.evalJSON();
  state = 3;
  Cookie.setData("state",state);
  if (data.status == 6)
    {
    $("ExportCheckMsg").innerHTML = "RequestID not found, status=6, error=" + data.error + "<br>Try again in a few seconds, may just be not ready to respond";
    ExportReadyOK = 3; // keep waiting
    $("ExportButton").value = "Retry";
    $("ExportButtonMsg").innerHTML = data.error;
    $("RequestIdPlace").innerHTML = "";
    $("ExportStatus").innerHTML = "RecordSet not found";
    $("ExportLocation").innerHTML = "";
    }
  else if (data.status == 5)
    {
    $("ExportCheckMsg").innerHTML = "Requested RequestID is too old, data no longer online, error=" + data.error;
    ExportReadyOK = 2;
    $("ExportButton").value = "Export timeout";
    $("ExportButtonMsg").innerHTML = data.error;
    $("RequestIdPlace").innerHTML = "";
    $("ExportStatus").innerHTML = "Export timeout";
    $("ExportLocation").innerHTML = "";
    state = 0;
    Cookie.setData("state",state);
    }
  else if (data.status == 4)
    {
    $("ExportCheckMsg").innerHTML = "Requested RecordSet not found or specification error, status=4, error=" + data.error +
      "<br>The export program failed.<br>" + "JSOC support see: jsoc/exports/tmp/" + data.requestid + ".runlog";
    ExportReadyOK = 2;
    $("ExportButton").value = "Bad RecordSet";
    $("ExportButtonMsg").innerHTML = data.error;
    $("RequestIdPlace").innerHTML = "";
    $("ExportStatus").innerHTML = "RecordSet not found";
    $("ExportLocation").innerHTML = "";
    state = 0;
    Cookie.setData("state",state);
    }
  else if (data.status == 3)
    {
    $("ExportCheckMsg").innerHTML = "Requested RecordSet is too large for chosen export method.  Please contact the JSOC for help.";
    $("ExportButtonMsg").innerHTML = "Export Too Large";
    ExportReadyOK = 2;
    $("ExportButton").value = "FAILURE ...";
    $("ExportButton").style.backgroundColor = "#D8D8D8";
    RequestID = data.requestid;
    $("RequestIdPlace").innerHTML = data.requestid;
    $("ExportStatus").innerHTML = "Needs Intervention, size=" + data.size + "MB, <br>" +
      data.count + " records found, " +
      data.error + ", contact: " + data.contact;
    $("ExportLocation").innerHTML = "";
    state = 0;
    Cookie.setData("state",state);
    }
  else if (data.status == 1 || data.status == 2 || data.status == 12)
    {
    ClearStatus();
    if (data.status == 1)
      $("StatusButtonMsg").innerHTML = "Export request is being processed";
    else  // status==2
      $("StatusButtonMsg").innerHTML = "Export request waiting for processing";
    ExportReadyOK = 1; // now allow check for status
    $("ExportButton").value = "Request Export Status";
    $("ExportButton").style.backgroundColor = "#D8D8D8";
    //  XXXX FIX $("ExportStatus").innerHTML = "Processing, size=" + data.size + "MB, estimate " + data.wait + " seconds remaining";
    $("ExportStatus").innerHTML = "Processing, size estimate = " + data.size + " MB";
    RequestID = data.requestid;
    $("RequestIdPlace").innerHTML = data.requestid;
    $("StatusRequestID").value = data.requestid;
    Cookie.setData("requestid",data.requestid);
    $("ExportLocation").innerHTML = "";
    $("FileUploadInfo").innerHTML = "File upload done, " + data.rcount + " records requested.";
    if (ExportFromFileList == 1)
      {
      FinishFileUpload();
      $("FileUploadInfoRow").style.display="table-row";
      }
    }
  else // status == 0 implies url_quick format and all online as-is
    {
    var valuetable = "";
    state = 0;
    Cookie.setData("state",state);
    Cookie.setData("requestid","");
    var count = data.count;
    $("ExportButtonMsg").innerHTML = "Fetch your data at URLs below before starting next request";
    ExportReadyOK = 2;
    $("ExportButton").value = "Submit Export Request";
    $("ExportButton").style.backgroundColor = "#D8D8D8";
    RequestID = data.requestid;
    alert('req id is ' + RequestID);
    if (RequestID.length == 0) RequestID = "N.A.";
    $("RequestIdPlace").innerHTML = RequestID;
    $("ExportStatus").innerHTML = "Data Ready, size=" + data.size + "MB";
    valuetable = CreateDataTable(data, valuetable);
    $("ExportLocation").innerHTML =  valuetable + "<br>";
    $("FileUploadInfo").innerHTML = "File upload done, " + data.rcount + " records requested.";
    if (ExportMethodValue == "url_quick")
      {
      if (ExportMethodIsDirect) // was url_direct on call
        {
        if (count > 1)
            $("ExportLocation").innerHTML =  "<b>Multiple files returned, direct fetch not possible. <\/b><p>" +
              valuetable + "<br>";
        else
            {
            var path = encodeURI("http://jsoc.stanford.edu" + data.dir + "/" + data.data[0].filename);
    //      doucment.write("<link type=\"application/fits\" href="+path+" />");
    //      fetch image
            }
        }
      else // url_quick on call
        $("ExportLocation").innerHTML = valuetable + "<br>";
      }
    else
      $("ExportLocation").innerHTML =  valuetable + "<br>";
    if (ExportFromFileList == 1)
      {
      FinishFileUpload();
      $("FileUploadRow").style.display="none";
      $("FileUploadInfoRow").style.display="table-row";
      }
    }
  return(data.status);
  }

function ClearStatus()
  {
  $("StatusButton").style.backgroundColor = "#D8D8D8";
  $("StatusStatus").innerHTML = "";
  $("StatusValue").innerHTML = "";
  $("StatusOther").innerHTML = "";
  $("StatusButtonMsg").innerHTML = "Waiting new status request...";
  $("StatusButton").value = "Submit Status Request";
  $("StatusRequestID").value = "";
  $("StatusLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("TarFileLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("KeywordFileLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("StatusDataLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  }

function GetStatus()
  {
  $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
  if ($("StatusRequestID").value.length == 0)
    {
    alert("You must provide a RequestID");
    return;
    }
    
    // An external user can check status on certain internal requests. These requests originated from the external site,
    // but they were passed-through to the internal site because they involved at least one internal series that
    // was whitelisted for external access. The request IDs of those requests contains an 'X':
    //
    // JSOC_2016122566_1254_X_IN
    
    // Use JSOC_FETCH_X, which accesses the internal db, if needed. And this is needed if the request ID string ends in
    // 'X_IN'.
  var script = JSOC_FETCH;
  var is_IN = ($("StatusRequestID").value.search("_IN") > 0);
  
  if (is_IN && Host == "jsoc.stanford.edu")
  {
      var isExtOrigin = ($("StatusRequestID").value.search("_X_IN") > 0);
      
      if (!isExtOrigin)
      {
          alert("RequestID ending with '_IN' belongs to jsoc2.stanford.edu, use proper RequestID or swtich to jsoc2.stanford.edu.");
          return;
      }
      
      script = JSOC_FETCH_X
  }
  else if (!is_IN && Host == "jsoc2.stanford.edu")
  {
      alert("RequestID without '_IN' belongs to jsoc.stanford.edu, use proper RequestID or switch to jsoc.stanford.edu.");
      return;
  }
  
  var arguments = {"op" : "exp_status", "requestid" : $("StatusRequestID").value};

  $("StatusLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("TarFileLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("KeywordFileLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("StatusDataLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("StatusButton").style.backgroundColor = colorPink;
  $("StatusStatus").innerHTML = "";
  $("StatusValue").innerHTML = "";
  $("StatusOther").innerHTML = "";
  $("StatusButtonMsg").innerHTML = "Processing status request ...";
  $("StatusButton").value = "Processing ...";
  
  new Ajax.Request('http://' + Host + '/cgi-bin/ajax/' + script,
    {
    method: 'get',
    parameters: arguments,

    onSuccess: function(transport, json)
      {
      var response = transport.responseText || "no response text";
      var data = response.evalJSON();
      state = 2;
      Cookie.setData("state",state);
      if (data.status == 6)
        {
        $("StatusButtonMsg").innerHTML = "RequestID not found, status=6, error=" + data.error + "<br>Try again in a few seconds, may just be not ready to respond";
        StatusReadyOK = 0;
        $("StatusButton").value = "Bad RecordSet";
        $("StatusButtonMsg").innerHTML = data.error + ", processing perhaps not started yet or bad RequestID";
        $("StatusValue").innerHTML = "Requested RecordSet returned error status=6";
        $("StatusOther").innerHTML = $("StatusRequestID").value + " not found,  msg=" + data.error;
        $("ReExportDiv").style.display = "none";
        state = 1;
        Cookie.setData("state",state);
        }
      else if (data.status == 5)
        {
        $("StatusButtonMsg").innerHTML = "Requested RequestID is too old, data no longer online, error=" + data.error;
        ExportReadyOK = 2;
        $("ExportButton").value = "Export timeout";
        $("ExportButtonMsg").innerHTML = data.error;
        $("RequestIdPlace").innerHTML = "";
        $("ExportStatus").innerHTML = "Export timeout";
        $("ExportLocation").innerHTML = "";
        $("ReRequestID").value = data.requestid;
        $("ReExportDiv").style.display = "block";
        }
      else if (data.status == 4)
        {
        $("StatusButtonMsg").innerHTML = "Requested RecordSet not found or specification error, status=4, error=" + data.error + "<br>The export program failed.<br>" +
		"JSOC support see: jsoc/exports/tmp/" + data.requestid + ".runlog";
        StatusReadyOK = 0;
        ExportReadyOK = 2;
        $("StatusButton").value = "Bad RecordSet";
        $("StatusButtonMsg").innerHTML = data.error;
        $("StatusValue").innerHTML = "Requested RecordSet returned error status=4";
        $("StatusOther").innerHTML = $("StatusRequestID").value + "msg=" + data.error;
        $("ReExportDiv").style.display = "none";
        }
      else if (data.status == 3)
        {
        $("StatusButtonMsg").innerHTML = "Requested RecordSet is too large for chosen export method.  Please contact the JSOC for help.";
        $("StatusButtonMsg").innerHTML = "Export Too Large";
        $("StatusButton").value = "FAILURE ...";
        $("StatusButton").style.backgroundColor = "#D8D8D8";
        ExportReadyOK = 2;
        $("StatusStatus").innerHTML = "Needs Intervention, size=" + data.size + "MB, contact: " + data.contact;
        $("RequestIdPlace").innerHTML = data.requestid;
        $("StatusValue").innerHTML = "Requested RecordSet returned error status=3";
        $("StatusOther").innerHTML = $("StatusRequestID").value +
           "<br>The requested RecordSet is too large for chosen export method." +
           "<br>" + data.count + " records found, " + data.error +
           "<br>Please contact the JSOC for help." ;
        $("ReExportDiv").style.display = "none";
        }
      else if (data.status == 1 || data.status == 2)
	{
        if (data.status == 1)
          $("StatusButtonMsg").innerHTML = "Export request is being processed";
        else  // status==2
          $("StatusButtonMsg").innerHTML = "Export request waiting for processing";
        ExportReadyOK = 2;
        $("StatusButton").value = "Submit Status Request";
        $("StatusButton").style.backgroundColor = "#D8D8D8";
        // XXXXX FIX $("StatusStatus").innerHTML = "Processing, size=" + data.size + "MB, estimate " + data.wait + " seconds remaining";
        var waiting = 10 - data.wait;
        $("StatusStatus").innerHTML = "Processing, size estimate = " + data.size + " MB, " + waiting + " seconds since request";
        $("RequestIdPlace").innerHTML = data.requestid;
        $("ReExportDiv").style.display = "none";
        state = 1;
        Cookie.setData("state",state);
        }
      else // status == 0
        {
        ExportReadyOK = 2;
        var valuetable = "";
        $("StatusButtonMsg").innerHTML = "Please only click once for status request.";
        $("StatusButton").value = "Submit Status Request";
        $("StatusButton").style.backgroundColor = "#D8D8D8";
        $("StatusStatus").innerHTML = "Data Ready, size=" + data.size + "MB";
        $("RequestIdPlace").innerHTML = data.requestid;
        var StatusLoc;
	if (data.method.indexOf("ftp") >= 0)
          StatusLoc = "ftp://pail.stanford.edu/export" + data.dir + "/";
        else
          StatusLoc = "http://jsoc.stanford.edu" + data.dir + "/";
        $("StatusLocation").innerHTML = "<a href='" + StatusLoc + "' target='_blank'>" + StatusLoc + "<\/a>";
        if (data.method.indexOf("-tar") > 0)
          {
          $("TarFileLocation").innerHTML = "<a href='" + data.tarfile + "'>" + data.tarfile + "<\/a>";
          $("TarFileLocationRow").style.display = "table-row";
	  }
        else
          $("TarFileLocationRow").style.display = "none";
        if (data.protocol.indexOf("as-is") >= 0)
          {
          $("KeywordFileLocation").innerHTML = "<a href='" + data.keywords + "' target='_blank'>" + data.keywords + "<\/a>";
          $("KeywordFileLocationRow").style.display = "table-row";
          }
        else
          $("KeywordFileLocationRow").style.display = "none";

        $("ExportStatus").innerHTML = "Data Ready, size=" + data.size + "MB";
        valuetable = CreateDataTable(data, valuetable);
        $("StatusDataLocation").innerHTML =  valuetable + "<br>";
        $("StatusValue").innerHTML = "Success";
        $("StatusOther").innerHTML = "List formats are index.html, index.json, and index.txt<br>" +
             "export script file is " + $("StatusRequestID").value +".drmsrun" ;
        if (ExportFromFileList  == 1)
          FinishFileUpload();
        $("ReExportDiv").style.display = "none";
        state = 1;
        Cookie.setData("state",state);
        }
      },
    onFailure: function()
      {
      $("StatusButtonMsg").innerHTML = "Export Failure, Problem at JSOC facility.";
      $("StatusButton").value = "FAILURE ...";
      $("StatusButton").style.backgroundColor = colorDarkPink;
      alert('Something went wrong...');
      ExportReadyOK = 2;
      },
    onComplete: function() { $("AjaxBusy").innerHTML = Ajax.activeRequestCount; }
    });
  $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
  }

</script>

</head>
<body bgcolor="#E0F0FF" onload="OnLoadInit();" >
<div id="header">
  <a href ="http://jsoc.stanford.edu" id="header_logo"><img src="http://hmi.stanford.edu/images/web/JSOC_120.gif"
    style="vertical-align:middle;height:60px;border:0" alt="JSOC logo"></a>
&nbsp;&nbsp;&nbsp;
<b><big style="vertical-align:middle">&nbsp;&nbsp;JSOC Data Export</big></b>
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
<input type="button" value="reset page" onClick="ReInitPage();" >
&nbsp;&nbsp;&nbsp;
<input id="TipsOnOffButton" type="button" value="Turn Help Off" onClick="ToggleHelp();" >
&nbsp;&nbsp;<span id="AjaxBusy">0</span> Requests Pending
<span id='systemWorking'>, Loading...</span>
<!-- <br clear=all> -->
<hr>
</div> <!-- end div header -->
<div id="ExportRequestDiv">
<br><b>JSOC Data Export Request Generation</b>

<!-- Start Message of the Day -->
<div id="MOTD">
<!--#include virtual="JSOC_MOTD.html" -->
</div> <!-- end MOTD div -->
<!-- END MODT DIV -->

<span id="RecordSetExample">
&nbsp; &nbsp;
<a href="exportdata.d/ExportDataErrorHelp.html" target="JSOC_Help">Help with Error Messages</a>
&nbsp;
<a href="http://jsoc.stanford.edu/doc/exports/exportdata_lookdata_release_notes.txt" target="JSOC_Help">Release Notes</a>
</span>
<p>
If the Method is changed from "url_quick" or "url_direct" you will have additional options to specify.
"url-direct" is temporarily disabled.
<p>
After the request is submitted
for Methods of "url", "ftp", "url-tar" or "ftp-tar" you will recieve ON THIS PAGE a "Request_ID" that will be used
to access the data when it is ready.
<p>
If you enter an email address you will be notified when the data is ready.
If you do not provide an email address you must leave this page open or save the Request_ID in order to
access the data.
<p>

<!-- Load bulk of html code here -->
<span id="ExportRequestForm"></span>

<div id="iframeHideDiv" style="display:none;">
  <iframe id="FileUploadFrame" onload="uploadDone();" src="" style="height:0px;width:0px;border:0px solid #fff;"></iframe>
</div>

<div id="SubmitResponseDiv">
<table>
  <tr>
    <td>RequestID</td>
    <td colspan="2"><span id="RequestIdPlace" style="width:12em;background-color:#FFF8DC;">&nbsp;</span></td>
    <td>This is the ID tag for your export request.  Use the Status Request button below to retrieve the links to the data.</td>
  </tr>

  <tr>
    <td>Status</td>
    <td colspan="3"> <span id="ExportStatus" style="background-color:#FFF8DC;"> </span ></td>
  </tr>

  <tr>
    <td>Data Location</td>
    <td colspan="3"><span id="ExportLocation" style="background-color:#FFF8DC;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span ></td>
  </tr>

</table>
</div>
<hr>
<div id="ExportDataDiv"  style="background-color:#C0E0FF;">
<b>JSOC Data Export Status and Retrieval</b>
<p>
<table>
  <tr>
    <td style="width:10em" >RequestID</td>
    <td><input type="text" id="StatusRequestID" name="StatusRequestID" style="width:12em;background-color:#FFF8DC;" value="" onChange="GetStatus();"></td>
    <td>This is the ID tag for your export request.</td>
    <td><span id="StatusValue">&nbsp;</span></td>
  </tr>

  <tr>
    <td colspan="2" align="center" >
      <input id="StatusButton" type="button" value="Submit Status Request" style="background-color:#D8D8D8" onClick="GetStatus();" ></td>
    <td><span id="StatusButtonMsg">Please only click once for status request.</span ></td>
    <td rowspan="3"><span id="StatusOther">&nbsp;</span></td>
  </tr>

  <tr>
    <td colspan="2" align="center" >
      <input id="ClearButton" type="button" value="Clear Request" style="background-color:#D8D8D8" onClick="ClearStatus();" ></td>
    <td>Clear old status RequestID</td>
  </tr>

  <tr>
    <td>Status</td>
    <td colspan="2"> <span id="StatusStatus" style="background-color:#FFF8DC;"> </span ></td>
  </tr>

  <tr>
    <td>Data Location</td>
    <td colspan="3"><span id="StatusLocation" style="background-color:#FFF8DC;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span ></td>
  </tr>

  <tr id="TarFileLocationRow" style="display:none;">
    <td>Tar File Location</td>
    <td colspan="3"><span id="TarFileLocation"  style="background-color:#FFF8DC;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span ></td>
  </tr>

  <tr id="KeywordFileLocationRow" style="display:none;">
    <td>Keyword File Location</td>
    <td colspan="3"><span id="KeywordFileLocation"  style="background-color:#FFF8DC;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span ></td>
  </tr>

  <tr>
  <td colspan="4"><span id="StatusDataLocation" style="background-color:#FFF8DC;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span ></td>
  </tr>

</table>
</div> <!-- id="ExportRequestDiv" -->

<div id="ReExportDiv" style="display:none">
<HR>
Use this section to request a renewal/repeat of a prior export for which the data online-retention time has expired.
<table>

  <tr>
    <td style="width:10em" >RequestID</td>
    <td><input type="text" id="ReRequestID" name="ReRequestID" style="background-color:#FFF8DC;" value="" onChange="ExportNop();"></td>
    <td>Enter RequestID for repeat or prior export</td>
    <td><span id="ReStatusValue">&nbsp;</span></td>
  </tr>

  <tr id="ReNotifyRow">
    <td>Notify</td>
    <td><input id="ReExportNotify" type="text" name="Renotify" value="" onChange="ExportNop();" ></td>
    <td colspan="2">
      Provide your email address for notification.
      If Requestor is your SolarMail name you may use "solarmail" here.
    </td>
  </tr>
  
  <tr id="AjaxReExportRequestRow">
    <td colspan="4">
      re-<input id="ReExportButton" type="button" value="Submit Export Request" style="background-color:#D8D8D8" onClick="GetReExport();" >
    <span id="ReExportButtonMsg">Please only click once for re-export request.</span >
    </td>
  </tr>
  
</table>
</div> <!-- id="ReExportDiv" -->
</div>

<HR>
<P style="height:1px">
<div id="footer" style="vertical-align:bottom;text-align:center;">
<I>Home page for:</I>
<a href = "http://jsoc.stanford.edu/" id="footer_link"><b>SDO-JSOC</b></a>
</div>

<script type="text/javascript">
var unescaped_html = unescape(escaped_html);
$("ExportRequestForm").innerHTML = unescaped_html;
ProcessingInit();
ProcessingEnabled();
exportdataLoaded=true;
</script>

</body>
</html>
