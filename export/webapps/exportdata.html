<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta HTTP-EQUIV="Content-Type" content="text/html; charset=iso-8859-1">
<title>JSOC Export Data</title>

<!--
<script type="text/javascript" src="js/prototype-1.6.0.3.js"></script>
-->
<script type="text/javascript" src="js/prototype-1.6.1.js"></script>
<script type="text/javascript" src="js/cookies.js"></script>
<script type="text/javascript" src="js/prototip.js"></script>
<link rel="stylesheet" type="text/css" href="css/prototip.css" >

<script type="text/javascript">
// Global variables and initialize page locations
var exportdata = location.pathname.sub(".html",""); 
</script>
<script type="text/javascript">
document.write('<base id="basepath" href="'+exportdata+'/"><\/base>');
</script>

<script type="text/javascript">

// Set CGI-BIN and include targets

// Eventually this should be put into a common file loaded by all the html web pages. To do that
// we need to copy code from exportdata.html to here that sets the base directory that is used
// when loading files with the <script> tag. Then we need to put the common file in that
// base directory, and we need to read it here. But for now, just hard-code this needed map.
var INTERNAL_SERVER = 'hmidb'
var EXTERNAL_SERVER = 'hmidb2'
var INTERNAL_WEBSERVER = 'jsoc2'
var EXTERNAL_WEBSERVER = 'jsoc'
var STANFORD_DOMAIN = 'stanford.edu'

var KEYWORD_CTYPE1 = 'CTYPE1';
var KEYWORD_CTYPE2 = 'CTYPE2';
var AIA_SCALE_CTYPE1 = 'HPLN-TAN';
var AIA_SCALE_CTYPE2 = 'HPLT-TAN';
var KEYWORD_SPEC = '*spec*';
var AIA_NAMESPACE = 'aia';
var NA = 'na';
var AIA_SCALE_NAXES = 2;

var serverMap = new Array();
serverMap[EXTERNAL_WEBSERVER] = EXTERNAL_SERVER;
serverMap[EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN] = EXTERNAL_SERVER;
serverMap[INTERNAL_WEBSERVER] = INTERNAL_SERVER;
serverMap[INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN] = INTERNAL_SERVER;

var JSOCEXTINFO = 'jsocextinfo';
var JSOC_INFO = 'jsoc_info';
var JSOCEXTFETCH = 'jsocextfetch';
var JSOC_FETCH = 'jsoc_fetch';
var SERIES_INFO = 'series_info';
var PARSE_RECSET = 'drms_parserecset';
var LOOKDATA = "lookdata";

</script>
<!-- Add html for processing and protocol options  -->
<!-- The sourced file contains: escaped_html='...'  -->
<script type="text/javascript" src="exportdata.d/export_request_form.htmlesc"></script>

<!-- Add functions for export processing and protocol options  -->
<script type="text/javascript" src="exportdata.d/processing.js"></script>
<script type="text/javascript" src="exportdata.d/protocols.js"></script>

<!-- Add list of seriesnames for which processing on export is not suportted -->
<script type="text/javascript" src="exportdata.d/no_processing.js"></script>

<!-- Add export email checking code. -->
<script type="text/javascript" src="exportdata.d/export_email_verify.js"></script>

<style type="text/css">

#body { margin:0; padding:0; }
#header { position:relative; top:0; left:0; width:100%; background:#eee; }
#footer { position:fixed; bottom:0; left:0; width:100%; background:#eee; }
#ExportRecordSet { width:40em; font-size:100%; }
span.tip { background-color:blue;font-family:verdana;color:white;font-size:1em;font-weight:bold;}
.prototip { font:0.8em Arial, Helvetica, sans-serif; }
</style>

<script type="text/javascript">

// Protect page from accidental BACK button
window.onbeforeunload = function () 
  {
  return "Did you really mean to leave exportdata? Use CANCEL to stay here";
  }

function OnEnterKey(evt,action)
  {
  var keynum;
  var keychar;
  if(window.event) // IE
    keynum = evt.keyCode;
  else if(evt.which) // Netscape/Firefox/Opera
    keynum = evt.which;
  if(keynum == 13)
    action();
  keychar = String.fromCharCode(keynum);
  return keychar;
  }

var previousSeries = "";
function NotifyProcessingCode()
  {
  // called when RecordSet is changed.
  // Set flags to alert processing or method options here.
  // variables here will usually be defined in exportdata.d/processing.js
  // or exportdata.d/export_request_form.html
  
  // SeriesName is determined asynchronously.
  if (SeriesName == previousSeries)
    SetProcessing(-1, null); // Do not initialize all processing options to their defaults.
  else
    {
    SetProcessing(-2, null); // Init all processing options to their defaults.
    ProtocolOptionsSet = 0;
    }
  previousSeries = SeriesName;
  }

// Global vars
var Host = location.host;
var Internal = 0;
var SeriesName;
var SeriesInfo;
var firstRealSegment;
var RequestID;
var RecordLimit;
var RecordCount = null; // Initialized in initVars(), Modified in GetRSCount()
var ExportQueryOK;
var ExportRecordSetOK;
var ExportRedinessStatus;
var ExportFromFileList;
var ExportMethodOK;
var ExportMethodIsDirect;
var ExportFilenameFmtOK;
var ExportProcessingOptions;
var ExportUserOK;
var ExportNotifyOK;
var ExportReadyOK;
var TipsEnabled;
var TipsCreated = 0;
var args;
var state=0;
var uploadOndoneAction = 0;
var ExportProcessingArgs = "";
var ProcessingAllowed = 1;
var ExportMethodValue = "url_quick";
var exportparameters;

// Export processing globals.
var ExportProcessingArgsPoll = null;
var ExportProcessingOK = null;

// Protocol global vars
var ExportCompressOK;
var ExportProtocolOK;
var ExportCompressValue = "";
var ExportProtocolValue = "FITS";
var ProtocolOptionsSet = 0;
var protocol_args
var ExportProtocolArgs = "";
var ExportProtocolArgsOK;
var protocolEnable;

// Misc vars
var firstTimePrime;
var expURL;

// Colors
var colorNeutral = "#D4D0C8";
var colorPreset = "D8D8D8";
var colorOptionSet = "#FFCC66";
var colorPink = "#FFD8D8";
var colorDarkPink = "#FFB0B0";
var colorRed = "#D88080";
var colorDarkRed = "#FF8080";
var colorRealRed = "#FF0000";
var colorWhite = "#FFFFFF";
var colorBlack = "#000000";
var colorGreen = "#80FF80";
var colorYellow = "#FFF8DC";


function initVars()
  {
  Host = location.host;
  if (Host == "jsoc2.stanford.edu")
    Internal = 1;
  else
    Internal = 0;
  SeriesName = "";
  RequestID = "";
  RecordCount = null;
  RecordLimit = 0;
  ExportRecordSetOK = 0;
  ExportQueryOK = 0;
  ExportRedinessStatus = 0;
  ExportFromFileList = 0;
  ExportMethodOK = 1;
  ExportMethodIsDirect = 0;
  ExportFilenameFmtOK = 1;
  ExportUserOK = 0;
  ExportNotifyOK = 0;
  ExportReadyOK = 2;
  TipsEnabled = 1;
  uploadOndoneAction = 0;
  firstTimePrime = "";
  ProcessingAllowed = 1;

  // Init processing
  ExportProcessingArgs = "";
  ExportProcessingOK = null;
  ExportProcessingArgsPoll = null;

  // Init protocols
  ExportProtocolOK = 1;
  ExportCompressOK = 1;
  ExportProtocolArgs = "";
  protocolEnable = 0;
  ProtocolOptionsSet = 0;

    // If the page is being loaded, then exportdataLoaded is true. If the reset page button was clicked, then 
    // exportdataLoaded is true as well. So, there is no need to check for a true value for exportdataLoaded.
    ProcessingInit();
    ProcessingEnabled()
    ProtocolOptionsInit();

    // Enable the reset button, now that the page has completed loaded.
    $("ResetPageButton").disabled = false;

  // if (state < 2)
  // Form init
    {
    $("ExportRequestor").value = "";
    $("ExportNotify").value = "solarmail";
    $("RequestIdPlace").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("StatusLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("TarFileLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("ExportStatus").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("StatusDataLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("ExportRecordSet").value = "";
    $("ExportCheckMsg").innerHTML = "";
    $("ExportCheckMsg").style.color = colorRealRed;
    // Processing
    $("ProcessRow").style.display="none";
    $("ExportProcessingHidden").value = "no_op";
    $("ProcessingCheckbox").checked = 0;
    // Protocols
    $("ProtocolRow").style.display="none";
    $("ExportProtocol").selectedIndex = 1;
    $("ExportProtocolHidden").value = "FITS";
    $("ExportCompress").selectedIndex = 0;
    $("CompressRow").style.display="none";
    $("ProtocolImageOptions").style.display="none";

    $("ExportMethod").selectedIndex = 2;
    $("ExportFilenameFmt").value = "{seriesname}.{recnum:%lld}.{segment}";
    $("ExportButton").value = "Submit Export Request";
    $("ExportButtonMsg").innerHTML = "Please only click once for export request.";
    $("ExportButton").style.backgroundColor = colorRed;
    $("RecordSetRow").style.display="table-row";
    $("RecordCountRow").style.display="table-row";
    $("FilenameFmtRow").style.display="none";
    $("RequestorRow").style.display="none";
    $("NotifyRow").style.display="none";
    $("FileUploadCheckbox").checked = 0;
    $("ExportOpID").value = "exp_request";
    $("ReRequestID").value = "";
    $("ReExportDiv").style.display = "none";
    $("TarFileLocationRow").style.display = "none";
    $("KeywordFileLocationRow").style.display = "none";
    $("ShowQueryCheckbox").checked = 0;
    SetExportMethod(1);
    }
  email_initVars();
  FileUploadCleanup();
  }

function getargs()
  {
  state = Cookie.getData("state");
  if (state == 1)
    {
    var exportargs = Cookie.data["search"];
    if (exportargs != undefined)
      {
      exportargs = decodeURIComponent(exportargs);
      exportargs = exportargs.substr(1);
      exportargs = exportargs.replace(/\?/g,"QUESTIONMARK");
      args = exportargs.toQueryParams();
      if (args.ds == undefined)
        args.ds = "";
      args.ds = args.ds.replace(/QUESTIONMARK/g, "?");
      }
    else
      {
      args = new Object;
      args.ds = "";
      }
    }
  else if (state > 1)
    {
    args = new Object;
    args.ds = "";
    args.requestid = "";
    args.limit= "none";
    }
  else
    {
    var exportargs = location.search;

    exportargs = decodeURIComponent(exportargs);
    exportargs = exportargs.substr(1);
    exportargs = exportargs.replace(/\?/g,"QUESTIONMARK");
    args = exportargs.toQueryParams();
    if (args.ds == undefined)
      args.ds = "";
    args.ds = args.ds.replace(/QUESTIONMARK/g, "?");
    state=1;
    Cookie.setData("state",state);
    Cookie.setData("search",location.search);
    }
  email_getargs();
  return args;
  }

function OnLoadInit()
  {
  var needcount = 0;
  Cookie.init({name:exportdata, expires:14});
  initVars(); // This call runs code that requires RecordSet to be set. However, that is not true  
              // before it is set below [ $("ExportRecordSet").value = args.ds ]
  if (Internal)
    {
    $("header_logo").href="http://jsoc2.stanford.edu";
    $("footer_link").href="http://jsoc2.stanford.edu";
    }
  state = 0;
  Cookie.setData("state",state);
  args = getargs();

  if (args.ds)
    {
    $("ExportRecordSet").value = args.ds;
    needcount = 1;
    }
  if (args.id)
    {
    RequestID = args.id;
    }
  if (args.limit) 
    {
    $("ExportRecordLimit").value = args.limit;
    if (args.limit == "none") RecordLimit = 0;
    else RecordLimit = args.limit;
    }
  if (needcount && $("ExportRecordSet").value != "")
    {
    if (GetRSCount(null))
    {
        $("ExportCheckMsg").innerHTML = "Invalid record-set specification";
    }
    GetDefaultFormat();
    }

  CreateTips();
  $("TipsOnOffButton").value = "Turn Help Off";
  
  $('RSCountPlace').up().setStyle({ 'max-width': '22em', 'overflow-wrap': 'break-word', 'word-wrap': 'break-word', 'word-break': 'break-all' });
  
  window.focus();
  }

function ReInitPage()
  {
  Cookie.setData("state",0);
  OnLoadInit();
  }

function MainTips(tipstyle)
  {
  if (TipsCreated == 0)
    {
    new Tip('RecordFromFileHelp','Allows user to provide a RecordSet list in a file.  ' +
        'The file should contain recordSet specifiers in the format allowed by drms_open_records include files.  ' +
        'See http://jsoc.stanford.edu/jsocwiki/AllAboutJsocNames.',tipstyle);
    new Tip('RecordSetHelp','RecordSet to be exported. May be imported on call and/or may be entered directly here. ' +
        'May be filled in by series select in Im_patch processing option.',tipstyle);
    new Tip('CallLookdataHelp','Start lookdata.html in a different tab/window with RecordSet given.  ' +
        'If a JSOC Lookdata window already exists, the first one will be replaced by this call.',tipstyle);
    new Tip('RecordLimitHelp','RecordSet record limit. Max number of records to export.  Modifies RecordSet. ' +
        'Value should be "none" or a number. Number > 0 counts from start of RecordSet.  Negative number counts ' +
        'from high end of RecordSet.  0 means no limit',tipstyle);
    new Tip('RecordCountHelp','RecordSet record count.  Update this to repeat export with new method, email, etc.  ' +
        'There is presently a limit to the memory space allocated for record queries which restricts AIA lev1 ' +
        'requests to about 15,000 records and HMI X_45s or X_720s data to about 32,000 records.  ' +
        'The limit depends on number of keywords in each record.  This limit will be eased in the future.',tipstyle);
    new Tip('MethodHelp','Handshake method to be used in the process of doing the export and to fetch the data files. ' +
        '"url-quick" is the fastest but can only be used if the data is online and will be exported "as-is". ' +
        '"url-direct" is has the constraints of url_quick with the limit of one file per request but it will ' +
        'automatically do the postprocessing specified in the "protocol" instruction. For "url_direct" the file ' +
        'is returned directly to your browser rather than returning to the export page.  If you have the ' +
        'set to load some fits reader program when the mime-ype "fits" is encountered you will see the image promptly. ' +
        '"url" will result in a temporary directory being created and the URL to that directory be returned to you after ' +
        'a handshake process using the RequestID provided. ' +
        '"ftp" is like "url" but the returned links will be to an ftp directory. ' +
        ' A "-tar" suffix will cause a tar of all files in the request to be included with the separate files. ' +
        'NOTE: do not use "-tar" unless you really need it since that will generate an extra copy of the data.',tipstyle);
    new Tip('FilenameFmtHelp','Filename format to be used in the process of doing the export.  ' +
        'The filename format is a template used to construct a filename for each segment of each record requested.  ' +
        'The template consists of literal characters and substitution tokens enclosed in "{}".  ' +
        'The special words: seriesname, recnum, and segment are replaced with the series_name, the record number, ' +
        'or the segment name.  The element {#} will generate an increasing number, ' +
        'with optional layout e.g. default is {#:%05d}. ' +
        'Any keyword in the record may also be used.  Optional layout may be provided after a ":".' +
        'Special format options are available for type TIME keywords: A leading "A" will strip "." and ":" from the time and ' +
        'a "D" will strip the "." and ":" but will insert "@" around the date components to allow easy scripts ' +
        'to move the exported files into date structured directory trees. ' +
        'It is wise to include enough of the "prime-keys" to make a unique filename.  ' +
        'The default format template is made from series structure.',tipstyle);
    new Tip('ProcessingHelp','Processing to be done to the data prior to export. ' +
        ' Select from drop-down list for details.',tipstyle);
    new Tip('ProtocolHelp','Data storage protocol for data files to be fetched.  ' +
        '<br>"Fits" causes the data to be converted to full fits files with header information filled from the DRMS records.  ' +
        '<br>"As-is" leaves the data as it is used inside the JSOC DRMS system, ' +
        'with the header metadata stored in the database rather than with the data file.  ' +
        '"As-is" is faster since the data does not need to be rewritten.  In as-is mode the header data is ' +
        'provided in a tab-delimited file named {RequestID}.keywords.txt. <br> The "jpeg" option will ' +
        ' yield  jpeg images of the data and the <br>"mpg" or "mp4" options will ' +
        ' yield a movie along with the jpeg images that make up the frames in the movie.<br> ' +
        'Default colortables and scaling for protocols making images are provided but may be altered.',tipstyle);
    new Tip('CompressHelp','Compression parameters to be used by the cfitsio library.  ' +
        'One comma separated string for each segment name in your export will be generated. ' +
        'Use "**NONE**" to indicate uncompressed FITS files desired. ' +
        'Note that e.g. AIA data can be more than 5 times larger if not compressed.  Do not request uncompressed ' +
        'exports for more than a few files.',tipstyle);
    new Tip('RequestorHelp','Optional place for your name, this will be used later when we have a way of saving your ' +
        'preferred export options.  This value will be saved in a Cookie if allowed.',tipstyle);
    new Tip('NotifyHelp','Email address to be used to notify you when the export is complete and ready to be ' +
        'fetched using the RequestID. NOTE - an email address is required for exports from jsoc2.',tipstyle);
    new Tip('SendFileHelp','This action will submit the export request with the RecordSet specified in the upload file.',tipstyle);
    new Tip('CheckParamHelp','This button is required to verify all fields used to specify the export request ' +
        'have been filled in in a consistent way.  If all is OK, the Submit button will be enabled.  A new Check ' +
        'button press is required before each export request.',tipstyle);
    new Tip('SubmitHelp','This button does the actual export request submission.  After a submit request the button ' +
        'action is changed to a Status Request which can be used to get the response from JSOC.  For all but url-direct and ' +
        'url-quick methods a RequestID tag will be returned a few seconds after a submit request.  ' +
        'This tag will be used to identify ' +
        'your export request inside JSOC and may be used at a later time to request the processing status and to ' +
        'obtain a link to your data.',tipstyle);
    new Tip('FetchCheckboxHelp','When this box is checked, the URL string that will be sent to the JSOC jsoc_fetch ' +
        'command will be shown when the "Check Params for Export" button is pressed.  This string can be used to ' +
        'help you develop script driven exports and to see how exportdata functions.',tipstyle);
    }
  };

</script>
<script type="text/javascript" src="exportdata.d/addOnTips.js"></script>
<script type="text/javascript">

function CreateTips()
  {
  var tipstyle =
    {
    style:'protoblue',
    hook:{target:'topRight',tip:'bottomLeft'},
    stem:'bottomLeft',
    closeButton:false,
    hideAfter:5,
    hideOn:'click',
    showOn:'click',
    border:3,
    radius:3,
    width:300,
    };

  MainTips(tipstyle);
  AddOnTips(tipstyle, Tip);
  TipsCreated = 1;
  $$("span.tip").each(function(showspan){showspan.show();}); 
  }

function HideTips()
  {
  $$("span.tip").each(function(hidespan){hidespan.hide();}); 
  Tips.hideAll();
  }

function ToggleHelp()
  {
  if (TipsEnabled)
    {
    HideTips();
    $("TipsOnOffButton").value = "Turn Help On";
    TipsEnabled = 0;
    }
  else
    {
    CreateTips();
    $("TipsOnOffButton").value = "Turn Help Off";
    TipsEnabled = 1;
    }
  }

// Check list of seriesnames for which processing options are not available for SeriesName spec given
function CheckNoProcessingList()
  {
  var n = NoProcessingList.length;
  var i;
  var result = 1;
  var prior = ProcessingAllowed;
  for (i=0; i<n; i++)
    {
        if (SeriesName == NoProcessingList[i])
        {
            result = 0;
            break;
        }
    }
  ProcessingAllowed = result;
  if (ProcessingAllowed != prior)
    ProcessingEnabled();
  }

function FileUploadCleanup()
  {
  ExportQueryOK = 0;
  $("ExportRecordSet").value = "";
  ExportRecordSetOK = 0;
  ExportFromFileList = 0;
  $("FileUploadCheckbox").checked = 0;
  $("RSCountPlace").innerHTML = "";
  $("ExportButton").value = "Submit Export Request";
  $("AjaxExportRequestRow").style.display="table-row";
  $("FileUploadInfoRow").style.display="none";
  $("RecordSetRow").style.display="table-row";
  $("RecordCountRow").style.display="table-row";
  $("ExportOpID").value = "exp_request";
  }
  
function FileUploadWanted()
  {
  ExportQueryOK = 0;
  if (ExportFromFileList == 0)
    {
    $("ExportRecordSet").value = "*file*";
    ExportRecordSetOK = 1;
    ExportFromFileList = 1;
    $("FileUploadCheckbox").checked = 1;
    $("RecordSetRow").style.display="none";
    $("RecordCountRow").style.display="none";
    $("ExportOpID").value = "exp_request";
    $("FileUploadRow").style.display="table-row";
    $("FileUploadInfoRow").style.display="none";
    $("AjaxExportRequestRow").style.display="none";
    }
  else
    {
    $("FileUploadInfoRow").style.display="none";
    FileUploadCleanup();
    FinishFileUpload();
    }
  }

function insertOption(list,text,note)
  {
  var y=document.createElement('option');
  y.value=text;
  if (note.length)
    y.text = text + "  --- " + note;
  else
    y.text = text;
  var x = $(list);
  try
    {
    x.add(y,null); // standards compliant
    }
  catch(ex)
    {
    x.add(y); // IE only
    }
  }

function MakeFileUploadRequest()
  {
  if (CheckExportParams() == 0)
    return;
  uploadOndoneAction = 1;
// XXXX fix compression here
  $("FileUploadFormID").action = 'http://' + Host + '/cgi-bin/ajax/' + JSOC_FETCH;
  $("FileUploadFormID").submit();
  }

function uploadDone()
  { //Function will be called when iframe is loaded
  if (uploadOndoneAction == 1)
    {
    var response = window.frames[0].document.getElementsByTagName("body")[0].innerHTML;
    var status = ProcessExportResponse(response);
    var op = "exp_upload";
    uploadOndoneAction = 0;
    }
  }

function FinishFileUpload()
  {
  window.frames[0].document.getElementsByTagName("body")[0].innerHTML = "";
  $("FileUploadRow").style.display="none";
  uploadOndoneAction = 0;
  }

function CallLookdata()
  { 
  var recset = $("ExportRecordSet").value;
  var posbracket = recset.indexOf("[");
  var posRbracket = recset.lastIndexOf("]");
  var posCurlbracket = recset.indexOf("{");
  var firstbracket = posbracket>=0 ? posbracket : posCurlbracket;
  var seriesname = (firstbracket == -1 ? recset : recset.substring(0,firstbracket));
  var recfilt = (posbracket >=0 ? recset.substring(posbracket,posRbracket+1) : "");
  var lookdataargs="ds="+seriesname;

  if (recfilt.length > 0)
    {
        // This is the filter used to select a series in lookdata.html, step 1.
        lookdataargs += "&rs=" + recfilt
    }
    
    // I guess the RecordCount can never be negative.
    if (RecordCount !== null && RecordCount > 0)
    {
        lookdataargs += "&n=" + RecordCount.toString();
    }
    
  LookdataWindow=window.open("http://" + Host + "/ajax/" + LOOKDATA + ".html?" + encodeURIComponent(lookdataargs), "JSOC Lookdata");
  LookdataWindow.window.focus();
  }

var RSCountActiveMSg = "Getting count - wait...";

// Class
function WlSeriesInfo()
{
}

// Parse record-set specification (spec) to get a list of all series names in the spec. This function sends that list to the WlSeriesInfo.getServer() method.
// THAT method finds out which database server contains the DRMS series information.
// To use extract names, do this. 
// This callback assumes that you want to call the getServer method in the 'this' object (an instance of the WlSeriesInfo class).
// So if you want to call extractSnames from outside of the 'this' object, you have to create a wrapper in WlSeriesInfo, then
// instantiate it (outside of 'this') with var wlInfo = new WlSeriesInfo(), then call the wrapper wlInfo.wrapper(args).
// So put the following into WlSeriesInfo.prototype.wrapper:
// var getServerFnArgs = {};
// getServerFnArgs.cbfn = callback;
// getServerFnArgs.cbargs = callbackArgs;
// var extractSnamesFnArgs = {};
// extractSnamesFnArgs.cbfnobj = this;
// extractSnamesFnArgs.cbfnobjmeth = 'getServer';
// extractSnamesFnArgs.cbargs = getServerFnArgs;
// extractSnamesFnArgs.args = [spec];
// this.extractSnames(extractSnamesFnArgs);
WlSeriesInfo.prototype.extractSnames = function(args)
{
    var spec = args.args[0];
    var callbackObj = args.cbfnobj;
    var callbackObjMeth = args.cbfnobjmeth; // getServer
    var callbackArgs = args.cbargs;
    var snames = [];
    
    $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
    
    new Ajax.Request('http://' + Host + '/cgi-bin/' + PARSE_RECSET,
    {
        method: 'get',
        parameters: { "spec" : spec },
        onSuccess: function(transport, json)
        {
            $("AjaxBusy").innerHTML = Ajax.activeRequestCount;

            var response = transport.responseText || null;
            var parseInfo = response.evalJSON();

            if (parseInfo.subsets.length > 0)
            {
                for (var iset = 0; iset < parseInfo.subsets.length; iset++)
                {
                    snames[snames.length] = parseInfo.subsets[iset].seriesname;
                }
            }
            else
            {
                alert("Invalid record-set specification: '" + spec + "'.")
            }

            callbackArgs.args = [spec, snames];
            callbackObj[callbackObjMeth](callbackArgs);
        },
        onFailure: function() { alert('Unable to parse record-set specficiation ' + "'" + spec + "'."); },
        onComplete: function() { $("AjaxBusy").innerHTML = Ajax.activeRequestCount; }
     });
     
     $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
};

function CreateParseSpecResponse(processSpec)
{
    var parseSpecResponseCallback = processSpec;
    
    var ParseSpecResponse = 
        function(transport)
        {
            var response = transport.responseText;
            var data = null;
            var errMsg = null;

            if (response && response.length)
            {   
                data = response.evalJSON();
            }
            else
            {
                data = { 'status' : 1, 'errMsg' : 'invalid parserecset response' };
                errMsg = 'invalid parserecset response';
            }

            // data contains parsed spec data; use it
            // callback closure
            if (parseSpecResponseCallback !== null)
            {
                parseSpecResponseCallback(errMsg, data);
            }
        };
                            
    return ParseSpecResponse;
}

function ParseSpec(spec, processSpec)
{    
    var onSuccess = CreateParseSpecResponse(processSpec);

    new Ajax.Request('http://' + EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + '/cgi-bin/' + PARSE_RECSET, 
    {
        'method' : 'get',
        'parameters' : { 'spec' : spec },
        'onSuccess' : onSuccess,
        'onFailure' : function() { $("RSCountPlace").innerHTML = 'ERROR - unable to parse record-set specification ' + spec; $('ExportRecordSet').disabled = false; },
        'onComplete' : function() { $("AjaxBusy").innerHTML = Ajax.activeRequestCount; }
    });
}

function CreateRequestRSInfoCallback(callback, lastRecord)
{    
    var processRSInfo = 
        function(transport)
        {
            var response = transport.responseText;

            if (response && response.length)
            {
                var data = response.evalJSON();

                if (!data || !data.hasOwnProperty('status') || data.status != 0)
                {
                    errMsg = 'failure running jsoc_info';
                    if (data.hasOwnProperty('error'))
                    {
                        errMsg = data.error;
                    }
                    RecordCount = null; // global
                    $("RSCountPlace").innerHTML = errMsg;
                    ExportRecordSetOK = 0; // global
                    SeriesName = ''; // global
                    
                    if (callback !== null)
                    {
                        callback(errMsg);
                    }
                }
                else
                {
                    RecordCount = data.count; // global
                    $("RSCountPlace").innerHTML = data.count;
                    ExportRecordSetOK = 1; // global
                    
                    // check for compatibility with aia_scale processing
                    if ($('OptionAiaScale').retrieve('disabledState', null) === null)
                    {
                        // aia_scale compatibility has not yet been determined; check now
                        // loop through all records, checking the keyword criteria; jsoc_info
                        // does not provide hash-accessibility to keyword info, so must
                        // loop through all keywords
                        var compatible = null;
                        
                        if (data.hasOwnProperty('keywords'))
                        {
                            compatible = true;
                            for (var index = 0; index < data.keywords.length; index++)
                            {
                                // we are assured that the CTYPE keywords will be in the jsoc_info results, 
                                // even if the series does not have those keywords; if a keyword
                                // does not exist in the series, jsoc_info prints 'Invalid Keylink'
                                // for the keyword value
                                if (data.keywords[index].name.strip().toLowerCase() == KEYWORD_CTYPE1.toLowerCase())
                                {
                                    for (var valIndex = 0; valIndex < data.keywords[index].values.length; valIndex++)
                                    {
                                        // loop over records
                                        if (data.keywords[index].values[valIndex] != AIA_SCALE_CTYPE1)
                                        {
                                            compatible = false;
                                            break;
                                        }
                                    }
                                }
                        
                                if (!compatible)
                                {
                                    break;
                                }
                            
                                if (data.keywords[index].name.strip().toLowerCase() == KEYWORD_CTYPE2.toLowerCase())
                                {
                                    for (var valIndex = 0; valIndex < data.keywords[index].values.length; valIndex++)
                                    {
                                        // loop over records
                                        if (data.keywords[index].values[valIndex] != AIA_SCALE_CTYPE2)
                                        {
                                            compatible = false;
                                            break;
                                        }
                                    }
                                }
                            
                                if (!compatible)
                                {
                                    break;
                                }
                            }
                        }
                        else
                        {
                            // no keyword information was returned by jsoc_info, so we cannot tell if this series;
                            // this happens if no rows were returned
                            compatible = false;
                        }
                        
                        // we definitively know whether or not aia_scale processing should be disabled
                        if (compatible)
                        {
                            $('OptionAiaScale').store({ 'disabledState' : false });
                        }
                        else
                        {
                            $('OptionAiaScale').store({ 'disabledState' : true });
                        }
                    }
                    else
                    {
                        // processSeriesSelection determined that the series is not aia_scale compatible
                    }
                    
                    if (!$('OptionAiaScale').retrieve('disabledState', false))
                    {
                        // this series' first segment has a 2D-image with a CTYPE1 value of 'HPLN-TAN' and a CTYPE2 value of 'HPLT-TAN' so
                        // it is compatible with aia_scale processing; the code to determine this is split between processSeriesSelection and 
                        // processRSInfo                    

                        // this should remain disabled until all asynchronous processing completes
                        $('OptionAiaScaleLabel').innerHTML = 'aia_scale - Scale image to 0.6 arcsec/pixel';
                        $('OptionAiaScaleLabel').setStyle({ color: 'black' });
                    }
                    else
                    {
                        // not compatible with aia_scale processing

                        // this should remain disabled until all asynchronous processing completes
                        $('OptionAiaScaleLabel').innerHTML = 'aia_scale - Scale image to 0.6 arcsec/pixel (compatible with 2D dataseries with CTYPE1 == HPLN-TAN and CTYPE2 == HPLT-TAN only)'
                        $('OptionAiaScaleLabel').setStyle({ color: 'grey' });
                        
                        // uncheck the aia_scale checkbox if it is currently checked
                        if ($('OptionAiaScale').checked)
                        {
                            $('OptionAiaScale').checked = false;
                        }
                    }
                    
                    // if the user has specified the current record with [$], then replace [$] with the record-specification
                    if (lastRecord && data.hasOwnProperty('keywords'))
                    {
                        for (var index = 0; index < data.keywords.length; index++)
                        {
                            if (data.keywords[index].name.strip().toLowerCase() == '*spec*' && data.keywords[index].values.length == 1)
                            {
                                $("ExportRecordSet").value = data.keywords[index].values[0];
                                break;
                            }
                        }
                    }
                }

                CheckRediness();
            }
            else
            {
                errMsg = 'invalid jsoc_info response';
                RecordCount = null;
                $("RSCountPlace").innerHTML = errMsg;
                ExportRecordSetOK = 0; // global  
                SeriesName = ''; // global

                if (callback !== null)
                {
                    callback(errMsg);
                }
            }

            if (callback !== null)
            {
                var errMsg = null;

                if (!ExportRecordSetOK)
                {
                    errMsg = $("RSCountPlace").innerHTML;
                }

                callback(errMsg);
            }
        };
        
    return processRSInfo;
}

// if errMsg, then do not call jsoc_info, but we still have to call the callback
function RequestRSInfo(errMsg, spec, lastRecord, callback)
{
    var arguments = null;
    var jsocinfoCGI = null;
    var host = null;

    if (errMsg && errMsg.length != 0)
    {
        if (callback !== null)
        {
            callback(errMsg);
        }
    }
    else
    {
        // if this is the external host, then use jsocinfointext; this CGI will choose the correct db server to handle the series;
        // if this is the internal host, then use jsoc_info, which will use the internal db server; Host, RecordLimit and EXTERNAL_SERVER 
        // are globals
        host = Host.toLowerCase();
        if (serverMap[host] == INTERNAL_SERVER)
        {
            jsocinfoCGI = JSOC_INFO;
            arguments = { 'ds' : spec, 'n' : RecordLimit, 'op' : 'rs_list', 'key' : KEYWORD_CTYPE1 + ',' + KEYWORD_CTYPE2 + ',' + KEYWORD_SPEC };
        }
        else
        {
            jsocinfoCGI = JSOCEXTINFO;
            arguments = { 'dbhost' : EXTERNAL_SERVER, 'ds' : spec, 'n' : RecordLimit, 'op' : 'rs_list', 'key' : KEYWORD_CTYPE1 + ',' + KEYWORD_CTYPE2 + ',' + KEYWORD_SPEC };
        }

        var onSuccess = CreateRequestRSInfoCallback(callback, lastRecord);
        
        new Ajax.Request('http://' + host + '/cgi-bin/ajax/' + jsocinfoCGI,
        {        
            'method': 'get',
            'parameters': arguments,
            'onSuccess': onSuccess, 
            'onFailure': function() { RecordCount = null; $("RSCountPlace").innerHTML = 'ERROR - failure calling jsoc_info'; ExportRecordSetOK = 0; SeriesName = ''; $('ExportRecordSet').disabled = false; },
            'onComplete': function() { $("AjaxBusy").innerHTML = Ajax.activeRequestCount; }
        });
    }
}

function CreateProcessSeriesSelection(spec, series, seriesNs, callback)
{
    var processSeriesSelection = 
        function(transport)
        {
            var response = transport.responseText;

            if (response && response.length)
            {
                var data = response.evalJSON();
                var errMsg = null;
         
                // check for suitability for aia_scale processing
                if (!data || !data.hasOwnProperty('errMsg'))
                {
                    // unexpected response from seriesinfo.py
                    errMsg = 'unexpected response to series-info request';
                }
                else if (data.errMsg !== null)
                {
                    errMsg = data.errMsg;
                }

                if (errMsg)
                {
                    RecordCount = null; // global
                    $("RSCountPlace").innerHTML = errMsg;
                    ExportRecordSetOK = 0; // global
                    SeriesName = ''; // global
                    
                    // need to call GetRSCount callback by calling the series-selection callback (with an error message)
                    if (callback !== null)
                    {
                        callback(errMsg);
                    }
                }
                else
                {
                    // successfully obtained series info
                    var compatible = null;
                    for (var segment in data[series.toLowerCase()].segments)
                    {
                        if (data[series.toLowerCase()].segments.hasOwnProperty(segment))
                        {
                            if ((parseInt(data[series.toLowerCase()].segments[segment]['segment-number']) == 0) &&
                                 (parseInt(data[series.toLowerCase()].segments[segment]['number-axes']) != 2))
                            {
                                // we know that aia_scale should definitely be disabled; store that information now so we can skip
                                // the secondary check in processRSInfo
                                $('OptionAiaScale').store({ 'disabledState' : true });
                                compatible = false;
                                break;
                            }
                        }
                    }
                    
                    if (compatible === null)
                    {
                        // compatibility not yet determined
                        if ((data[series.toLowerCase()].keywords[KEYWORD_CTYPE1.toLowerCase()]['constant-value'] != AIA_SCALE_CTYPE1 && 
                             data[series.toLowerCase()].keywords[KEYWORD_CTYPE1.toLowerCase()]['constant-value'] != NA) ||
                            (data[series.toLowerCase()].keywords[KEYWORD_CTYPE2.toLowerCase()]['constant-value'] != AIA_SCALE_CTYPE2 && 
                             data[series.toLowerCase()].keywords[KEYWORD_CTYPE2.toLowerCase()]['constant-value'] != NA))
                        {
                            // we know that aia_scale should definitely be disabled; store that information now so we can skip
                            // the secondary check in 
                            $('OptionAiaScale').store({ 'disabledState' : true });
                            compatible = false;
                        }   
                    }
                    
                    // we can also determine compatibility with the MPT-selection check box
                    if (seriesNs.toLowerCase() == AIA_NAMESPACE)
                    {
                        $('AiaScaleUseMptCheckbox').disabled = false;
                        $('AiaScaleUseMptCheckboxLabel').innerHTML = 'Use a master pointing table to scale images (instead of keyword values)&nbsp';
                        $('AiaScaleUseMptCheckboxLabel').setStyle({ color: 'black' });
                    }
                    else
                    {
                        $('AiaScaleUseMptCheckbox').disabled = true;
                        $('AiaScaleUseMptCheckboxLabel').innerHTML = 'Use a master pointing table to scale images (instead of keyword values - compatible with AIA series only)&nbsp';
                        $('AiaScaleUseMptCheckboxLabel').setStyle({ color: 'grey' });
                    }
                    
                    if (callback !== null)
                    {
                        callback(null);
                    }
                }
            }
            else
            {
                errMsg = 'unable to obtain series information';
                RecordCount = null; // global
                $("RSCountPlace").innerHTML = errMsg;
                ExportRecordSetOK = 0; // global
                SeriesName = ''; // global
                
                // need to call GetRSCount callback by calling the series-selection callback (with an error message)
                if (callback !== null)
                {
                    callback(errMsg);
                }
            }
        };
        
    return processSeriesSelection;
}

function RequestSeriesInfo(series, callback)
{
    var onSuccess = callback;

    new Ajax.Request('http://' + EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + '/cgi-bin/' + SERIES_INFO,
    {
        'method': 'get',
        'parameters': { 'series' : series, 'atts' : 1, 'keys' : KEYWORD_CTYPE1 + ',' + KEYWORD_CTYPE2, 'segs' : '*' },
        'onSuccess': onSuccess, 
        'onFailure': function() { RecordCount = null; SeriesName = ''; ExportRecordSetOK = 0; $("RSCountPlace").innerHTML = 'ERROR - failure calling series-info'; $('ExportRecordSet').disabled = false; },
        'onComplete': function() { $("AjaxBusy").innerHTML = Ajax.activeRequestCount; }
    });
}

// callback - called after record-set specification has been successfully parsed (this does not mean that the 
// series is valid - it just means the specification has valid syntax)
function CreateProcessSpec(spec, processRecordCount)
{    
    var processSpec = 
        function(errMsg, data)
        {
            var errMsgActual = null;
            prefix = 'ERROR - unable to parse record-set specification';

            if (data && data.hasOwnProperty('errMsg') && data.errMsg && data.errMsg.length != 0)
            {
                errMsgActual = prefix + ': ' + data.errMsg;
            }
            else if (errMsg && errMsg.length != 0)
            {
                errMsgActual = prefix + ': ' + errMsg;
            }
            
            if (errMsgActual)
            {
                RecordCount = null;
                ExportRecordSetOK = 0;
                $('RSCountPlace').innerHTML = errMsgActual;
                
                // if an error occurred, we still need to call the processRecordCount callback
                processRecordCount(errMsgActual);
            }
            else
            {
                // set SeriesName
                var series = data.subsets[0].seriesname;
                var seriesNs = data.subsets[0].seriesns;
                var validSpec = data.subsets[0].spec;
                var lastRecord = false;

                SeriesName = series; // global
                if (!data.hasfilts && RecordLimit == 0)
                {
                    validSpec = series + '[$]' + (data.subsets[0].segments === null ? '' : data.subsets[0].segments);
                    lastRecord = true;
                }
                else if (data.hasfilts)
                {
                    if (data.subsets[0].filter == '[$]')
                    {
                        lastRecord = true;
                    }
                }
                
                $("ExportRecordSet").value = validSpec;

                // use the parsed series name to call the jsocInfoCGI to get the series information;
                // disable the aia_scale processing option if the series selected is not suitable for that
                // processing option; NOTE: the series info might not be sufficient to make this determination;
                // if this is the case, then we need to consult the actual record metadata to do so; check
                // series info first since this is a simpler, quicker test; 
                //
                // series suitable for the aia_scale processing option have these properties:
                //   1. They are 2-D time series
                //   2. CTYPE1 == 'HPLN-TAN'
                //   3. CTYPE2 == 'HPLT-TAN'
                //
                // the RequestSeriesInfo callback needs to call RequestRSInfo with processRecordCount as the callback
                var requestRSInfo = function(errMsg) { RequestRSInfo(errMsg, validSpec, lastRecord, processRecordCount); };
                var processSeriesSelection = CreateProcessSeriesSelection(validSpec, series, seriesNs, requestRSInfo);
                RequestSeriesInfo(series, processSeriesSelection);
            }
        };
        
    return processSpec;
}

// Internal-DB pass-through.
// If the user is accessing the external website, the database source of the series information could be the internal database.
// External users have access to a sanctioned list of internal data series. So, we do not necessarily want to use the 'Host'
// variable to identify the jsoc_info CGI. If the user is accessing a sanctioned internal series, then we need to use the jsoc_info
// CGI hosted on jsoc2.stanford.edu, not the one on 'Host' (which is jsoc.stanford.edu).
// The callback is optional. Many functions require jsoc_info to have returned before they can continue.
//
// IF THE CALLBACK IS NOT null THEN IT MUST BE CALLED, EVEN ON ERROR; OTHERWISE, CERTAIN GLOBAL VARIABLES
// WILL NOT BE SET APPROPRIATELY
function GetRSCount(countCallback)
{
    ExportQueryOK = 0;
    ExportRecordSetOK = 0;
    SeriesName = "";
    $('OptionAiaScale').store({ 'disabledState' : null }) // means aia_scale compatibility not determined yet

    var recset = $("ExportRecordSet").value;

    if (recset.length == 0)
    {
        $("RSCountPlace").innerHTML = "ERROR - missing record-set specification.";
        return(1);
    }

    $("RSCountPlace").innerHTML = RSCountActiveMSg;
    // we need not only the series name, but we need the CTYPE1 and CTYPE2 keyword values so that
    // we can determine if the series is suitable for aia_scale processing; from recset, we can
    // extract the seriesname
    var cb = CreateProcessSpec(recset, countCallback);
    ParseSpec(recset, cb);

    RecordCount = null; // To indicate that the RecordCount has not been set yet.  
    $("AjaxBusy").innerHTML = Ajax.activeRequestCount;

    return(0);
}

function GetDefaultFormat()
{
	$("AjaxBusy").innerHTML = Ajax.activeRequestCount;
	// $("RSCountPlace").innerHTML = RSCountActiveMSg; why?
	// RecordCount = null; why?
	var RecordSet = $("ExportRecordSet").value;
  
	var doInfoReqFn = function()
	{
		var arguments = null;
		var jsocinfoCGI = null;

		// If this is the external host, then use jsocinfointext. This CGI will choose the correct db server to handle the series.
		// If this is the internal host, then use jsoc_info, which will use the internal db server.
		if (serverMap[Host.toLowerCase()] == INTERNAL_SERVER)
		{
			jsocinfoCGI = JSOC_INFO;
			arguments = {"ds" : RecordSet, "op" : "series_struct", "l" : 1 };
		}
		else
		{
			jsocinfoCGI = JSOCEXTINFO;
			arguments = {"dbhost" : EXTERNAL_SERVER, "ds" : RecordSet, "op" : "series_struct", "l" : 1 };
		}

		new Ajax.Request('http://' + Host + '/cgi-bin/ajax/' + jsocinfoCGI,
		{
			method: 'get',
			parameters: arguments,
			   
			onSuccess: function(transport, json)
			{
				var response = transport.responseText || "no response text";
				SeriesInfo = response.evalJSON();
				if (SeriesInfo.status == 0)
				{
					var nprimes = SeriesInfo.primekeysinfo.length;
					var nkeys = SeriesInfo.keywords.length;
					if (nprimes == 0)
					{
						$("ExportFilenameFmt").value = SeriesName + ".{recnum:%lld}.{segment}";
					}
					else
					{
						var newfmt = SeriesName + ".";
						var i;
						for (i=0; i<nprimes; i++)
						{
							var thisprime = SeriesInfo.primekeys[i];
							var j;
							for  (j=0; j<nkeys; j++)
							{
								var thiskey = SeriesInfo.keywords[j].name;
								if (thiskey === thisprime)
								{
									if (SeriesInfo.keywords[j].type === "time")
									{
										newfmt = newfmt + "{" + thisprime + ":A}.";
										if (firstTimePrime ==="") firstTimePrime = thisprime;
									}
									else
									newfmt = newfmt + "{" + thisprime + "}.";
									break;
								}
							}
						}
						newfmt = newfmt + "{segment}";
						$("ExportFilenameFmt").value = newfmt;
					}
					firstRealSegment = "";
					var nsegs = SeriesInfo.segments.length;
					var recset = $("ExportRecordSet").value;
					var posCurlbracket = recset.indexOf("{");
					var posCurlRbracket = recset.lastIndexOf("}");
					var seglist = ((posCurlbracket >=0 && posCurlRbracket > 0) ? recset.substring(posCurlbracket+1,posCurlRbracket) : "");
                                        var seglistLength = seglist.length;
					var WantedSegments = [];
					if (seglistLength > 0)
					    WantedSegments = seglist.split(",");
					for (var iseg=0; iseg<nsegs; ++iseg)
					    {
                                            if (seglistLength > 0)
                                                {
                                                var thisname = SeriesInfo.segments[iseg].name;
                                                var thisnamearray = [thisname];
                                                var jointnames = WantedSegments.intersect(thisnamearray)
                                                if (jointnames.length == 0)
                                                    continue;
                                                }
					    var thisProtocol = SeriesInfo.segments[iseg].protocol;
						if (thisProtocol === "fits")
						    {
						    firstRealSegment = SeriesInfo.segments[iseg].name;
						    break;
						    }
					    }
				}
				else
				{
					alert('Unable to retrieve series information for record-set ' + RecordSet + '. ' + SeriesInfo.error)
				}
				$("AjaxBusy").innerHTML = Ajax.activeRequestCount;
			},
			onFailure: function() { alert('Something went wrong...'); },
			onComplete: function() { $("AjaxBusy").innerHTML = Ajax.activeRequestCount; }
		});
	};
	
	// Just call the function. It will determine if it should use the internal or external version of the CGI.
	doInfoReqFn();
}

function CreateDataTable(data, valuetable)
  {
  $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
  // valuetable = "";
  // var count = data.count;
  var count = data.data.length;
  valuetable = "<table border='1'>";
  valuetable = valuetable + "<tr><td>File<\/td><td>Record<\/td><td>Filename<\/td><\/tr>";
  for (ifile=0; ifile < count; ifile++)
    {
    valuetable = valuetable + "<tr>";
    valuetable = valuetable +  "<td>" + (ifile + 1) + "<\/td>";
    valuetable = valuetable +  "<td>" + data.data[ifile].record + "<\/td>";
    thisfile = data.data[ifile].filename;
    if (data.method.indexOf("tar") > 0)
      valuetable = valuetable +  "<td>" + thisfile + "<\/td><\/tr>";
    else
      {
      if (data.method.indexOf("ftp") >= 0)
        expURL = "ftp://pail.stanford.edu/export" + data.dir + "/" + thisfile;
      else
        expURL = "http://jsoc.stanford.edu" + data.dir + "/" + thisfile;
      tmp = "<a href='" + expURL + "' target='_blank'>" + thisfile + "<\/a>";
      valuetable = valuetable +  "<td>" + tmp + "<\/td><\/tr>";
      }
    }
  valuetable = valuetable + "<\/table>";
  return valuetable;
  }

function ExportNop()
  {
  }

function ExportRSChanged()
  {
  ExportQueryOK = 0;
  RecordCount = null; // This will cause the record-count global to be updated later.
  $("CountButton").style.backgroundColor = colorYellow;
  ExportNewRS(); // to fix opeator not pressing enter or count.
  }
  
function ProcessRSChange(error)
{
    // GetDefaultFormat() starts another jsoc_info asnchronously. It sets firstTimePrime. firstTimePrime is used in processing.js.
    // GetDefaultFormat() requires SeriesName, which is set in the first jsoc_info.
    // ProcessRSChange() is now not called until the first jsoc_info has completed.
    if (!error)
    {
        firstTimePrime = ""; // Used in GetDefaultFormat()
        GetDefaultFormat();

        CheckNoProcessingList();
        // NotifyProcessingCode requires the first jsoc_info to have completed (the one started by SetRecordLimit()).
        // It also requires that SetProcessing() has completed its asynchronous running.
        NotifyProcessingCode();
        CheckRediness();
    
        // re-enable the processing step checkboxes
        for (iProc = 0; iProc < ExportProcessingOptions.length; iProc++)
        {
            var ExpOpt = ExportProcessingOptions[iProc];

            // if disabledState metadata do not exist, then set disabled to false (the second arg to retrieve() is the default
            $(ExpOpt.id).disabled = $(ExpOpt.id).retrieve('disabledState', false);
        }
    }
    else
    {
        // something went wrong; uncheck any processing check boxes that are checked and hide the processing UI
        for (iProc = 0; iProc < ExportProcessingOptions.length; iProc++)
        {
            var ExpOpt = ExportProcessingOptions[iProc];

            $(ExpOpt.id).checked = false;
            if (ExpOpt.id != 'OptionNone' && ExpOpt.hasOwnProperty('rowid'))
            {
                // the 'none' processing step has no processing UI html element
                $(ExpOpt.rowid).style.display = "none";
            }
        }
        
        CheckRediness();
    }
    
    // Re-enable the RecordSet text box.
    $('ExportRecordSet').disabled = false;
    
    // must set to false every time the user enters a specification, even on error, otherwise the user will never
    // be able to enter a new specification
    newRSRunning = false;
}

// Called when record-set changes, when user clicks on Recount, when user clicks on enter key in RecordSet field.
var newRSRunning = false;
function ExportNewRS()
  {
    // This took forever to figure out. JS event handlers CAN interrupt each other at alert()s. 
    // ExportRecordSet has both an onchange and an onclick handler that fire when you click on the Recount
    // button after you enter a record-set specification. As a result, ExportNewRS() is called twice.
    // IFF you have an alert anywhere between the checking for newRSRunning and the setting of 
    // newRSRunning in ExportNewRS(), then the onchange handler
    // will be interrupted at the alert() statement, and the onclick handler will run. 
    if (newRSRunning)
    {
        return;
    }
    // NO alert()!
    newRSRunning = true;

    // disable processing step checkboxes for now, since we are about to change the record-set, and some processing steps
    // need the record-set to be present
    for (iProc = 0; iProc < ExportProcessingOptions.length; iProc++)
    {
        var ExpOpt = ExportProcessingOptions[iProc];
        $(ExpOpt.id).disabled = true;
    }
  
    $("ExportCheckMsg").innerHTML = "";
    SeriesName = "";
    ExportQueryOK = 0;
    $("CountButton").style.backgroundColor = colorNeutral;
      
    // Disable RecordSet text edit while the asynchronous stuff runs for the newly set record-set.
    $('ExportRecordSet').disabled = true;

    // SetRecordLimit() starts jsoc_info asynchronously (via GetRSCount()).        
    if (SetRecordLimit(ProcessRSChange))
    {
        return; // SetRecordLimit calls GetRSCount(), non-zero on RS syntax error
    }    
  }

function SetRecordLimit(callbackAfterJsocinfo)
  {
  var newLimit;
  newLimit = 1 * $("ExportRecordLimit").value;
  if (isNaN(newLimit))
    {  // newlimit is a non-numeric string
    newLimit = $("ExportRecordLimit").value;
    if (newLimit == "none")
      RecordLimit = 0;
    else
      {
      $("ExportRecordLimit").style.backgroundColor = colorRed;
      alert("RecordLimit must be a number or 'none'");
      RecordLimit = 0;
      }
    }
  else
    {
    if (newLimit == 0)
      $("ExportRecordLimit").value = "none";
    RecordLimit = newLimit;
    }
  $("ExportRecordLimit").style.backgroundColor = colorWhite;
  return(GetRSCount(callbackAfterJsocinfo));
  }

function SetExportMethod(byWhom)
  {
  // byWhom = 0 for user click, else 1
  if (byWhom == 0)
    ExportQueryOK = 0;
  var ExportMethodIndex = $("ExportMethod").selectedIndex;
  ExportMethodValue = $("ExportMethod").options[ExportMethodIndex].value;
  if (ExportMethodValue == "url_direct" || ExportMethodValue == "url_quick")
    {
    ExportMethodOK = 1;
    $("ProcessRow").style.display="none";
    var nProcs = ExportProcessingOptions.length;
    $(ExportProcessingOptions[0].id).checked = true;
    for (var iProc=1; iProc < nProcs; iProc++)
      { 
      var ExpOpt = ExportProcessingOptions[iProc];
      $(ExpOpt.id).checked = false;
      $(ExpOpt.rowid).style.display = "none";
      }
    if (ExportMethodValue == "url_direct")
      {
      $("ProtocolRow").style.display="table-row";
      ExportMethodIsDirect = 1;
      }
    else
      {
      $("ProtocolRow").style.display="none";
      ExportMethodIsDirect = 0;
      }
    $("FilenameFmtRow").style.display="none";
    ExportProtocolValue = "as-is";
    $("ExportProtocol").selectedIndex = 0;
    ExportCompressValue = "";
    // $("ExportCompress").selectedIndex = 1;
    $("CompressRow").style.display="none";
    $("RequestorRow").style.display="none";
    $("NotifyRow").style.display="none";
    }
  else if (ExportMethodValue == "url" ||
           ExportMethodValue == 'ftp' ||
           ExportMethodValue == "url-tar" ||
           ExportMethodValue == 'ftp-tar')
    {
    ExportMethodOK = 1;
    $("ProcessRow").style.display="table-row";
    $("ProtocolRow").style.display="table-row";
    $("FilenameFmtRow").style.display="table-row";
    $("RequestorRow").style.display="table-row";
    $("NotifyRow").style.display="table-row";
    // PHS turn off compression option
    // if(ExportProtocolValue == "FITS")
       // $("CompressRow").style.display="table-row";
    if (byWhom == 0)
      $("ExportCompress").selectedIndex = 0;
    }
  else
    {
    alert("Please set Method to url_quick, url_direct,  url, or ftp");
    ExportMethodOK = 0;
    }
  CheckRediness();
  }

function SetExportFilenameFmt()
  {
  ExportQueryOK = 0;
  if ($("ExportFilenameFmt").value.length != 0)
    ExportFilenameFmtOK = 1;
  else
    {
    alert("Please set non-empty name for FilenameFmt");
    ExportFilenameFmtOK = 0;
    }
  CheckRediness();
  }

// Called after user clicks on 'Enable Processing' checkbox.
function ProcessingEnabled()
  {
  ExportQueryOK = 0;
  if ($("ProcessingCheckboxHide").checked)
    $("ProcessingCheckbox").checked = false;
  if ($("ProcessingCheckbox").checked)
    {
        // The user enabled processing
    if ($("ExportRecordSet").value == "" || $("ExportRecordSet").value == "[$]")
      {
      $("ProcessingWaitMessage").style.display = "table-row";
      $("ProcessingCheckbox").checked = false;
      return;
      }
    $("ProcessingWaitMessage").style.display = "none";
    $("ProcessingCheckboxHide").checked = false;
    $("ProcessingShowCheckbox").style.display = "none";
    $("ExportProcessing").style.display = "table-row";
    }
  else
    {
        // The user disabled processing.
    $(ExportProcessingOptions[0].id).checked = true; // Enable the none processing option.
    $("ExportProcessing").style.display = "none";
    if (ProcessingAllowed == 0)
      {
      $("ProcessingWaitMessage").style.display = "table-row";
      $("ProcessingWaitMessage").innerHTML = "Processing not available for series " + SeriesName;
      $("ProcessingCheckboxHide").checked = true;
      $("ProcessingShowCheckbox").style.display = "none";
      }
    else
      {
      $("ProcessingWaitMessage").style.display = "none";
      $("ProcessingCheckboxHide").checked = false;
      $("ProcessingShowCheckbox").style.display = "table-row";
      }
    SetProcessing(0, null); // Pretend the user clicked on the none processing option.
    }
  }

var SizeRatio;

// Called when a processing-option checkbox has changed, or the record-set query has changed.
// Make the ExportProcessingArgs string (a |-separated list of processing steps).

var setProcessingRunning = false;
var setProcessingQueue = [];

function runSetProcessing(intervalFn, spCallback)
{ // 0 if no procesing enabled (Enable Processing is not checked),  -1 if same seriesname, -2 if series has changed between export processing requests.
    // ichecked > 0 if the user clicks on/off a processing-step checkbox.    
    if (setProcessingRunning)
    {
        // do not clear interval, this will continue to run until it is safe to run the code in the rest of the function
		return;
	}

    // No alerts in here.
	setProcessingRunning = true;
	
    ichecked = setProcessingQueue.shift()

	if (typeof ichecked == 'undefined')
	{
		// nothing to do; should not get here because each function instance handles one SetProcessing() call
		alert('bad')
		clearInterval(intervalFn);
		setProcessingRunning = false;
		return;
	}
    
    ExportQueryOK = 0;

    if (ProcessingAllowed == 0)
    {
        $(ExportProcessingOptions[0].id).checked = true;
    }
    if (ichecked > 0)
    {
        $(ExportProcessingOptions[0].id).checked = false; // Disable the 'none' processing step.
    }
    
    ExportProcessingOK = null;

  // Add recordLimit FIRST always. Could change when user changes RecordSet specification.
  ExportProcessingArgs = "n=" + RecordLimit;
  var isok = 1;
  var nchecked = 0;
  var iProc = 0;
  var nProcs = ExportProcessingOptions.length;
  SizeRatio = 1.0;
  if ($(ExportProcessingOptions[0].id).checked) // no_op case must be first
    {
        // The none processing case.
    nchecked++;
    for (iProc=1; iProc<nProcs; iProc++)
      {
      var ExpOpt = ExportProcessingOptions[iProc];
      $(ExpOpt.id).checked = false;
      $(ExpOpt.rowid).style.display = "none";
      
        if (ExpOpt.id != "OptionImPatch")
        {
            ExpOpt.Init(1);
        }
      }
    ExportProcessingArgs += "|no_op";
    }
  else
    {
    for (iProc=1; iProc<nProcs; iProc++)
      {
      // ExportProcessingOptions is a list of all processing options. The command to perform
      // any given option is sent to jsoc_fetch only if ExportProcessingOptions[iProc].id.checked is true.
      // So, the order of the processing steps is the order they appear in ExportProcessingOptions, 
      // which is determined in ProcessingInit() in processing.js.
      var ExpOpt = ExportProcessingOptions[iProc];
      if ($(ExpOpt.id).checked)
        {
        nchecked++;
        $(ExportProcessingOptions[0].id).checked = false; // Do not send the 'none' processing option to jsoc_fetch.
        if (ichecked == -2)
          {
            // This is the on-load case, where we want to initialize all processing parameters to their defaults.
          ExpOpt.Init(1);
          $(ExpOpt.rowid).style.display="table-row";
          isok = 0;
          
            // We need to run the check function for each checked option since we changed the record-set.
            // The Check() functions always run synchronously.
            if (ExpOpt.hasOwnProperty('Check') && ExpOpt.Check && typeof ExpOpt.Check === 'function')
            {
                ExpOpt.paramsValid = null; // blow-away the cache so Check() can actually do the check and generate the command-line arguments.
                args = ExpOpt.Check(true);

                if (args == 'error')
                {
                    // Error that requires the checkbox to be unchecked.
                    $(ExpOpt.id).checked = false;
                    $(ExpOpt.rowid).style.display = 'none';
                    nchecked--;
                }
            }
          }
        else
          {
            $(ExpOpt.rowid).style.display="table-row";
            // This is the case where we do not want to reset the processing parameters to the default.
            ExpOpt.Init(0); // 0 initializes globals needed by Check() functions; initialization is asynchronous, so 
                            // we run a setInterval function below, waiting for completion; the Check() functions can modify the UI
        }
      }
        else
        {
            $(ExpOpt.rowid).style.display="none";
            // keep existing argument values for ImPatch only (the other processing options have no way
            // of resetting them to default values, so we have to do that here if the user has unchecked
            // the option's checkbox
            if (ExpOpt.id != "OptionImPatch")
            {
                ExpOpt.Init(1);
            }
        }
      }
      
      if (nchecked > 0)
      {
        // The Set() functions can run asynchronously. We have at least one Set() function that succeeded (which means 
        // there could be AJAX running).
        ExportProcessingArgsPoll = setInterval(function(){ GetExportProcessingArguments(spCallback); }, 50);
        
        // Disable all processing-step checkboxes, until GetExportProcessingArguments() resolves.
        for (iProc = 0; iProc < nProcs; iProc++)
        {
            var ExpOpt = ExportProcessingOptions[iProc];
            $(ExpOpt.id).store({ 'disabledState' : $(ExpOpt.id).disabled})
            $(ExpOpt.id).disabled = true;
        }
      }
    }
  if (nchecked == 0)
    {
    $(ExportProcessingOptions[0].id).checked = true; // Set no-op processing step.
    
    // Hide the non-no-op steps.
    for (iProc=1; iProc<nProcs; iProc++)
    {
        var ExpOpt = ExportProcessingOptions[iProc];
        $(ExpOpt.rowid).style.display = "none";
    }
    
    ExportProcessingArgs += "|no_op";
    }
  $("ExportSizeRatio").value = SizeRatio;
        
  $("ExportProcessingHidden").value = ExportProcessingArgs;
  
    clearInterval(intervalFn);
  
    if (ExportProcessingArgsPoll)
    {
        // We don't know if export processing is OK yet.
        ExportProcessingOK = false;
        // do not clear the setProcessingRunning flag
    }
    else
    {
        if (isok)
        {
            ExportProcessingOK = true;
        }
        else
        {
            ExportProcessingOK = false;
        }
        
        setProcessingRunning = false;
        
        if (spCallback)
        {
            spCallback();
        }
    }
    
    CheckRediness();
}

function SetProcessing(ichecked, spCallback)
{
	var intervalFn;

	setProcessingQueue.push(ichecked)
	intervalFn = setInterval(function(){ runSetProcessing(intervalFn, spCallback); }, 100);
}
 
// Cannot determine the arguments at the time that SetProcessing() is called because there might be
// asynchronous processes running (AJAX calls) that need to complete before the arguments can be 
// finalized.

// Polling function
function GetExportProcessingArguments(spCallback)
{
    var ExpOpt = null;
    var args = null;
    var iProc = 0;
    var SizeRatio = 1.0;
    var oneChecked = false;
    
    if (!ExportProcessingArgsReady())
    {
        // Wait till all the Set() procs for each processing step have completed their asynchronous processing.
        return;
    }

    for (iProc = 1; iProc < ExportProcessingOptions.length; iProc++)
    {
        ExpOpt = ExportProcessingOptions[iProc];
        
        if ($(ExpOpt.id).checked)
        {
            args = ExportProcessingOptions[iProc].Check(true);
            
            if (args === null)
            {
                // a Set() function is pending; wait until it has completed
                return;
            }
            
            if (args == 'error')
            {
                // Error that requires the checkbox to be unchecked.
                $(ExpOpt.id).checked = false;
                $(ExpOpt.rowid).style.display = 'none';
                continue;
            }
            
            oneChecked = true;
        
            // At this point, we know for sure if there is an error with the export options chosen. If so, 
            // ignore that processing step, and uncheck its checkbox.
            if (args.length > 0)
            {
                // args contains all the processing args. ExportProcessingArgs will have n=X already.
                ExportProcessingArgs += "|" + args;
                SizeRatio *= ExpOpt.Size;
            }
        }
    }
    
    if (!oneChecked)
    {
        $(ExportProcessingOptions[0].id).checked = true; // Set no-op processing step.
    
        // Hide the non-no-op steps.
        for (iProc = 1; iProc < ExportProcessingOptions.length; iProc++)
        {
            var ExpOpt = ExportProcessingOptions[iProc];
            $(ExpOpt.rowid).style.display = "none";
        }
    
        ExportProcessingArgs += "|no_op";
    }
    
    // Re-enable all processing-step checkboxes, until GetExportProcessingArguments() resolves.
    for (iProc = 0; iProc < ExportProcessingOptions.length; iProc++)
    {
        var ExpOpt = ExportProcessingOptions[iProc];
        // ART $(ExpOpt.id).disabled = false;
        $(ExpOpt.id).disabled = $(ExpOpt.id).retrieve('disabledState', false);
    }
    
    $("ExportSizeRatio").value = SizeRatio;
    $("ExportProcessingHidden").value = ExportProcessingArgs; // Not used.
    CheckRediness();
    
    clearInterval(ExportProcessingArgsPoll);
    ExportProcessingArgsPoll = null;
    ExportProcessingOK = true; // This means that everything that is going to modify the export arguments has completed
                               // modifying said parameters. It does NOT mean that the parameter values are acceptable.

    setProcessingRunning = false;
    
    if (spCallback)
    {
        spCallback();
    }
}

function SetExportProtocol(byWhom)
  { 
  // byWhom = 0 for user click, else 1
  if (byWhom == 0)
    ExportQueryOK = 0;
  var ExportProtocolIndex = $("ExportProtocol").selectedIndex;
  ExportProtocolValue = $("ExportProtocol").options[ExportProtocolIndex].value;

  if (ExportProtocolValue == "as-is" || ExportProtocolValue == "FITS")
    { // Handle file protocols
    if (ExportProtocolValue == "as-is")
      {
      ExportProtocolOK = 1;
      $("CompressRow").style.display="none";
      $("ExportProtocolHidden").value = "as-is";
      ExportCompressValue = "";
      }

    else if (ExportProtocolValue == "FITS")
      {
      ExportProtocolOK = 2;
      // PHS hide compression option row
      // $("CompressRow").style.display="table-row";
      $("ExportProtocolHidden").value = "FITS";
      if (byWhom == 0)
        $("ExportCompress").selectedIndex = 0;
      var ExportCompressIndex = $("ExportCompress").selectedIndex;
      ExportCompressValue = $("ExportCompress").options[ExportCompressIndex].value;
      }
    $("ProtocolImageOptions").style.display="none";
    }
  else
    { // Handle image protocols
    if (ExportProtocolValue == "MPEG")
      {
      ExportProtocolOK = 4;
      $("ProtocolImageOptions").style.display="table-row";
      $("CompressRow").style.display="none";
      $("ExportProtocolHidden").value = "mpg";
      }
    else if (ExportProtocolValue == "MP4")
      {
      ExportProtocolOK = 4;
      $("ProtocolImageOptions").style.display="table-row";
      $("CompressRow").style.display="none";
      $("ExportProtocolHidden").value = "mp4";
      }
    else if (ExportProtocolValue == "JPEG")
      {
      ExportProtocolOK = 3;
      $("ProtocolImageOptions").style.display="table-row";
      $("CompressRow").style.display="none";
      $("ExportProtocolHidden").value = "jpg";
      }
    // ProtocolOptionsSet: 0 if need to set defaults, 1 if defaults, 2 if user changed
    if (ProtocolOptionsSet == 0)
      ProtocolImageInit();
    if (ProtocolOptionsSet > 0)
      ProtocolImageCheck();
    }
  CheckRediness();
  }

function SetExportCompress()
  {
  ExportQueryOK = 0;
  var protocolparam = ExportProtocolValue;
  if (protocolparam == "FITS" || protocolparam == "as-is")
    {
    if (ExportRecordSetOK)
      {
      var ExportCompressIndex = $("ExportCompress").selectedIndex;
      ExportCompressValue = $("ExportCompress").options[ExportCompressIndex].value;
      for (var i=0; i < SeriesInfo.segments.length; i++)
        {
        var segtype = SeriesInfo.segments[i].type;
        if (ExportCompressValue == "compress Rice" &&  protocolparam == "FITS" && (segtype == "float" || segtype == "double"))
          protocolparam = protocolparam  + ",**NONE**";
        else if (protocolparam == "FITS")
          // PHS do not allow uncompressed.  13 Nov 2014
          // protocolparam = protocolparam  + "," + ExportCompressValue;
          protocolparam = protocolparam  + "," + "compress Rice";
        }
      $("ExportProtocolHidden").value = protocolparam;
      ExportCompressOK = 1;
      }
    else
      {
      ExportCompressOK = 0;
      }
    }
  CheckRediness();
  }

// Notify and Requestor checking is now in the email registration js script.

function ExportShowQuery()
  {
  if ($("ShowQueryCheckbox").checked)
    {
    var paramString = decodeURIComponent(Object.toQueryString(exportparameters));
    $("ExportParameters").innerHTML = paramString.replace(/&/g,"&amp;");
     }
  else
    $("ExportParameters").innerHTML = "";
  }

function CheckRediness()
  {
  var status = ExportQueryOK * ExportRecordSetOK * ExportMethodOK * ExportFilenameFmtOK * ExportProtocolOK * (ExportNotifyOK==1);
  
  if ($("ProcessingCheckbox").checked)
  {
    status = status * (ExportProcessingOK ? 1 : 0) * (ProcessingOK() ? 1 : 0);
  }

  if (status)
    {
    $("ExportButtonMsg").innerHTML = "Please only click once for export request.";
    $("ExportButton").value = "Submit Export Request";
    $("ExportButton").style.backgroundColor = colorGreen;
    $("ExportCheckMsg").style.color = colorBlack;
    $("ExportCheckButton").style.backgroundColor = colorGreen;
    }
  else
    {
    $("ExportCheckMsg").style.color = colorRealRed;
    $("ExportCheckButton").style.backgroundColor = colorYellow;
    $("ExportButton").value = "Not Ready To Submit";
    $("ExportButton").style.backgroundColor = colorRed;
    }
  ExportRedinessStatus = status;
  return(status);
  }

// This is a callback function. It is invoked after the email check has completed.
function SetExportParams()
{
    // All these variables on the RHS are global.
    var isOK = ExportRecordSetOK * ExportMethodOK * ExportFilenameFmtOK * ExportProtocolOK * (ExportNotifyOK==1);
    
    if ($("ProcessingCheckbox").checked)
    {
        isOK = isOK * (ExportProcessingOK ? 1 : 0) * (ProcessingOK() ? 1 : 0);
    }

    if (isOK)
    {
        var protocolparam = $("ExportProtocolHidden").value;
        var RecordSet = $("ExportRecordSet").value;

        // exportparameters is a global.
        exportparameters = new Hash({"op" : $("ExportOpID").value,
                                    "ds" : RecordSet, 
                                    "sizeratio" : $("ExportSizeRatio").value,
                                    "process" :  ExportProcessingArgs,
                                    "requestor" : $("ExportRequestor").value,
                                    "notify" : $("ExportNotify").value,
                                    "method" : ExportMethodValue,
                                    "filenamefmt" : $("ExportFilenameFmt").value,
                                    "format" : "json",
                                    "protocol" : protocolparam });

        ExportShowQuery();
        ExportQueryOK = 1;
    }
    else
    {
        // exportparameters is a global.
        exportparameters = null;
        $("ExportParameters").innerHTML = "";
        ExportQueryOK = 0;
    }
    
    CheckRediness();
}

// This function is called when the user clicks on the "Check Params for Export"
// button. 
// A lot of the calls in this function are asynchronous. 
function CheckExportParamsInternal()
  {
    // complete the SetProcessing part of this check
    // If there was an error in the processing options, then ExportProcessingOK is not true.
    // ProcessingOK() is synchronous.
    if ($("ProcessingCheckbox").checked && (!ExportProcessingOK || !ProcessingOK()))
    {
        $("ExportCheckMsg").innerHTML = "Processing details not correct, fix and retry export request.";
    }
    else
    {
  
  
  if ($("ExportRecordSet").value.length == 0)
  {
    $("ExportCheckButton").style.backgroundColor = colorYellow;
    $("ExportCheckMsg").innerHTML = "Please enter a record-set specification.";
    return 0;
  }
  
  if (RecordCount === null)
    {
    $("ExportCheckButton").style.backgroundColor = colorYellow;
    $("ExportCheckMsg").innerHTML = "Still counting records, wait a second then retry";
    return(0);
    }
    
  while (1) // use with break instead of goto done.
    {
    if (ExportRecordSetOK == 0)
      {
        $("ExportCheckMsg").innerHTML = "Invalid record-set specification";
        break;
      }
    SetExportMethod(1);
    if (ExportMethodOK == 0)
      {
      $("ExportCheckMsg").innerHTML = "Method not given, Enter export method then retry export request.";
      break;
      }
    SetExportFilenameFmt();
    if (ExportFilenameFmtOK == 0)
      {
      $("ExportCheckMsg").innerHTML = "FilenameFmt not given, Enter FilenameFmt then retry export request.";
      break;
      }
      
    SetExportProtocol(1);
    if (ExportProtocolOK == 0)
      {
      $("ExportCheckMsg").innerHTML = "Protocol not given, Enter export protocol then retry export request.";
      break;
      }
    if ((ExportProtocolValue == "FITS" || ExportProtocolValue == "as-is") && ExportMethodValue != "url_quick")
      {
      SetExportCompress();
      }
    else if (protocolEnable)
      {
      ProtocolImageCheck();
      }      
      
    if (ExportNotifyOK == 0 || ExportNotifyOK == 2)
      {
      // This is an asynchronous call, so we need to put the following "isOK" check into a
      // callback function. Return isOK == 0 since we do not know if it is OK to do an export
      // at this point.
      startEmailCheck(SetExportParams);
      return false;
      break;
      }
    $("ExportCheckMsg").innerHTML = "OK to proceed";
    break;
    }
    
    }

    // note - ExportQueryOK is missing here
  var isOK = ExportRecordSetOK * ExportMethodOK * ExportFilenameFmtOK * ExportProtocolOK * (ExportNotifyOK==1);
  
  if ($("ProcessingCheckbox").checked)
  {
      isOK = isOK * (ExportProcessingOK ? 1 : 0) * (ProcessingOK() ? 1 : 0);
  }
  
  if (isOK)
    {
    var protocolparam = $("ExportProtocolHidden").value;
    var RecordSet = $("ExportRecordSet").value;
    
    exportparameters = new Hash( {"op" : $("ExportOpID").value,
                 		      "ds" : RecordSet, 
                                      "sizeratio" : $("ExportSizeRatio").value,
                 		      "process" :  ExportProcessingArgs,
                 		      "requestor" : $("ExportRequestor").value,
                 		      "notify" : $("ExportNotify").value,
                                      "method" : ExportMethodValue,
                                      "filenamefmt" : $("ExportFilenameFmt").value,
			 	      "format" : "json",
                 		      "protocol" : protocolparam });

    ExportShowQuery();
    ExportQueryOK = 1;
    }
  else
    {
    exportparameters = null;
    $("ExportParameters").innerHTML = "";
    ExportQueryOK = 0;
    }
  var isOK = CheckRediness();
  return isOK;
  }
  
function CheckExportParams()
{
    // Up till now, SetProcessing() gets called whenever a processing option checkbox gets clicked.
    // But SetProcessing() does not get called when the user changes processing option values. Call it
    // now with -1 (which means the record-set spec has not changed).
    SetProcessing(-1, CheckExportParamsInternal);  // asynchronous - can't do the rest until this asynchronous call completes.
}

function GetExport() // This is the code executed when the user clicks on the "Submit Export Request" button.
  {
  // ExportReadyOK values
  // use this for state inside GetExport only, use ExportRedinessStatus to determine OK to proceed
  //  0 ready to begin export process
  //  1 ready for status request
  //  2 export complete, OK or failure.
  //  3 Process started, waiting response

  $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
  if (ExportReadyOK == 3)
    {
    alert("Processing request, please wait...");
    return;
    }
    
  if (ExportRedinessStatus) 
    {
    ExportRedinessStatus = 0;
    ExportReadyOK = 3;
    state = 2;
    Cookie.setData("state",state);
    $("ExportStatus").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    $("ExportLocation").innerHTML = "";
    $("ExportButtonMsg").innerHTML = "Export request submitted, please wait...";
    $("ExportButton").value = "Processing ...";
    $("ExportButton").style.backgroundColor = colorDarkRed;
    $("ExportCheckButton").style.backgroundColor = colorYellow;
    }
  else if (ExportReadyOK == 1)
    {
    var requestidtmp = $("RequestIdPlace").innerHTML;
    exportparameters = new Hash( {"op" : "exp_status","requestid":requestidtmp});
    }
  else // ExportReadyOK == 2
    {
    // $("ExportRecordSet").value = "";
    ExportRedinessStatus = 0;
    $("ExportCheckMsg").innerHTML = "Export Request Complete, Please check updated export params before making another export request";
    return;
    }

    var doFetchReqFn = function()
	{
		var arguments = null;
		var jsocfetchCGI = null;

		// If this is the external host, then use jsocextfetch. This CGI will choose the correct db server to handle the series.
		// If this is the internal host, then use jsoc_fetch, which will use the internal db server.
		if (serverMap[Host.toLowerCase()] == INTERNAL_SERVER)
		{
			jsocfetchCGI = JSOC_FETCH;
		}
		else
		{
			jsocfetchCGI = JSOCEXTFETCH;
			exportparameters.update({ "dbhost" : EXTERNAL_SERVER });
		}
    
		arguments = exportparameters.toObject();
        
        $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
        
        new Ajax.Request('http://' + Host + '/cgi-bin/ajax/' + jsocfetchCGI,
        {
            method: 'post',
            parameters: arguments,

            onSuccess: function(transport, json)
            {
                $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
                var response = transport.responseText || "no response text";
                var status = ProcessExportResponse(response);
                var op = $("ExportOpID").value;
            },
            onFailure: function()
            {
                $("ExportButtonMsg").innerHTML = "Export Failure, Problem at JSOC facility.";
                $("ExportButton").value = "FAILURE ...";
                $("ExportButton").style.backgroundColor = colorDarkPink;
                ExportReadyOK = 2;
                alert('Something went wrong...');
            },
            onComplete: function() { $("AjaxBusy").innerHTML = Ajax.activeRequestCount; }
        });
        
        $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
    };
    
    
    // Just call the function. It will determine if it should use the internal or external version of the CGI.
    doFetchReqFn();
  }

function GetReExport()
  {
  $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
  ExportReadyOK = 3;
  state = 2;
  Cookie.setData("state",state);
  $("ExportStatus").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("ExportLocation").innerHTML = "";
  $("ReExportButtonMsg").innerHTML = "Export request submitted, please wait...";
  $("ReExportButton").value = "Processing ...";
  $("ReExportButton").style.backgroundColor = colorPink;
  
  var paramObj = {"op" : "exp_repeat",
                  "requestid" : $("ReRequestID").value,
                  "format" : "json",
                  "notify" : $("ReExportNotify").value};
  
  exportparameters = new Hash(paramObj);
  
  // Use JSOC_FETCH_X, which accesses the internal db, if needed. And this is needed if the request ID string ends in
  // 'X_IN'.
	var jsocfetchCGI = JSOC_FETCH;
	var is_IN = ($("ReRequestID").value.search("_IN") > 0);
    var isExtOrigin = ($("ReRequestID").value.search("_X_IN") > 0);
		
	if (is_IN && (Host.toLowerCase() == EXTERNAL_WEBSERVER || Host.toLowerCase() == EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN))
	{
		if (!isExtOrigin)
		{
			alert('The request ID ' +  $("ReRequestID").value + ' is accessible from http://' + INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN +' only. Please use a request ID generated by a request made on the http://' + EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + ' webserver (which has a format of JSOC_YYYYMMDD_NNN or JSOC_YYYYMMDD_NNN_X_IN).');
			return;
		}

		jsocfetchCGI = JSOCEXTFETCH;
	}
	else if ((!is_IN || isExtOrigin) && (Host.toLowerCase() == INTERNAL_WEBSERVER || Host.toLowerCase() == INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN))
	{
		alert('The request ID ' +  $("ReRequestID").value + ' is accessible from http://' + EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + ' only. Please use a request ID generated by a request made on the http://' + INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + ' webserver (which has a format of JSOC_YYYYMMDD_NNN_IN).');
		return;
	}

    new Ajax.Request('http://' + Host + '/cgi-bin/ajax/' + jsocfetchCGI,
    {
        method: 'post',
        parameters: exportparameters.toObject(),

        onSuccess: function(transport, json)
        {
            $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
            var response = transport.responseText || "no response text";
            var status = ProcessExportResponse(response);
        },
        onFailure: function()
        {
            $("ReExportButtonMsg").innerHTML = "Export Failure, Problem at JSOC facility.";
            ExportReadyOK = 2;
            $("ReExportButton").value = "FAILURE ...";
            $("ReExportButton").style.backgroundColor = colorDarkPink;
            alert('Something went wrong...');
        },
        onComplete: function() { $("AjaxBusy").innerHTML = Ajax.activeRequestCount; }
    });
    $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
  }


function ProcessExportResponse(response)
  {
  var data = response.evalJSON();
  state = 3;
  Cookie.setData("state",state);

  if (data.status == 6)
    {
    // email address was not registered, or export_manage not yet found request. 
    $("ExportCheckMsg").innerHTML = "RequestID not found, status=6, error=" + data.error + "<br>Try again in a few seconds, may just be not ready to respond";
    ExportReadyOK = 3; // keep waiting
    $("ExportButton").value = "Retry";
    $("ExportButtonMsg").innerHTML = data.error;
    $("RequestIdPlace").innerHTML = "";
    $("ExportStatus").innerHTML = "RecordSet not found";
    $("ExportLocation").innerHTML = "";
    }
  else if (data.status == 5)
    {
    $("ExportCheckMsg").innerHTML = "Requested RequestID is too old, data no longer online, error=" + data.error;
    ExportReadyOK = 2;
    $("ExportButton").value = "Export timeout";
    $("ExportButtonMsg").innerHTML = data.error;
    $("RequestIdPlace").innerHTML = "";
    $("ExportStatus").innerHTML = "Export timeout";
    $("ExportLocation").innerHTML = "";
    state = 0;
    Cookie.setData("state",state);
    }
  else if (data.status == 4)
    {
    $("ExportCheckMsg").innerHTML = "Requested RecordSet not found or specification error, status=4, error=" + data.error +
      "<br>The export program failed.<br>" + "JSOC support see: jsoc/exports/tmp/" + data.requestid + ".runlog";
    ExportReadyOK = 2;
    $("ExportButton").value = "Bad RecordSet";
    $("ExportButtonMsg").innerHTML = data.error;
    $("RequestIdPlace").innerHTML = "";
    $("ExportStatus").innerHTML = "RecordSet not found";
    $("ExportLocation").innerHTML = "";
    state = 0;
    Cookie.setData("state",state);
    }
  else if (data.status == 3)
    {
    $("ExportCheckMsg").innerHTML = "Requested export size is too large: " + data.error + " Please contact the JSOC for help.";
    $("ExportButtonMsg").innerHTML = data.error;
    ExportReadyOK = 2;
    $("ExportButton").value = "Export Too Large";
    $("ExportButton").style.backgroundColor = "#D8D8D8";
    RequestID = data.requestid;
    $("RequestIdPlace").innerHTML = data.requestid;
    $("ExportStatus").innerHTML = "Needs Intervention, size=" + data.size + "MB, <br>" +
      data.count + " records found, " +
      data.error + ", contact: " + data.contact;
    $("ExportLocation").innerHTML = "";
    state = 0;
    Cookie.setData("state",state);
    }
  else if (data.status == 1 || data.status == 2 || data.status == 12)
    {
    ClearStatus();
    if (data.status == 1)
      $("StatusButtonMsg").innerHTML = "Export request is being processed";
    else  // status==2
      $("StatusButtonMsg").innerHTML = "Export request waiting for processing";
    ExportReadyOK = 1; // now allow check for status
    $("ExportButton").value = "Request Export Status";
    $("ExportButton").style.backgroundColor = "#D8D8D8";
    //  XXXX FIX $("ExportStatus").innerHTML = "Processing, size=" + data.size + "MB, estimate " + data.wait + " seconds remaining";
    $("ExportStatus").innerHTML = "Processing, size estimate = " + data.size + " MB";
    RequestID = data.requestid;
    $("RequestIdPlace").innerHTML = data.requestid;
    $("StatusRequestID").value = data.requestid;
    Cookie.setData("requestid",data.requestid);
    $("ExportLocation").innerHTML = "";
    $("FileUploadInfo").innerHTML = "File upload done, " + data.rcount + " records requested.";
    if (ExportFromFileList == 1)
      {
      FinishFileUpload();
      $("FileUploadInfoRow").style.display="table-row";
      }
    }
  else // status == 0 implies url_quick format and all online as-is
    {
    var valuetable = "";
    state = 0;
    Cookie.setData("state",state);
    Cookie.setData("requestid","");
    var count = data.count;
    $("ExportButtonMsg").innerHTML = "Fetch your data at URLs below before starting next request";
    ExportReadyOK = 2;
    $("ExportButton").value = "Submit Export Request";
    $("ExportButton").style.backgroundColor = "#D8D8D8";
    RequestID = data.requestid;

    if (RequestID.length == 0) RequestID = "N.A.";
    $("RequestIdPlace").innerHTML = RequestID;
    $("ExportStatus").innerHTML = "Data Ready, size=" + data.size + "MB";
    valuetable = CreateDataTable(data, valuetable);
    $("ExportLocation").innerHTML =  valuetable + "<br>";
    $("FileUploadInfo").innerHTML = "File upload done, " + data.rcount + " records requested.";
    if (ExportMethodValue == "url_quick")
      {
      if (ExportMethodIsDirect) // was url_direct on call
        {
        if (count > 1)
            $("ExportLocation").innerHTML =  "<b>Multiple files returned, direct fetch not possible. <\/b><p>" +
              valuetable + "<br>";
        else
            {
            var path = encodeURI("http://jsoc.stanford.edu" + data.dir + "/" + data.data[0].filename);
    //      doucment.write("<link type=\"application/fits\" href="+path+" />");
    //      fetch image
            }
        }
      else // url_quick on call
        $("ExportLocation").innerHTML = valuetable + "<br>";
      }
    else
      $("ExportLocation").innerHTML =  valuetable + "<br>";
    if (ExportFromFileList == 1)
      {
      FinishFileUpload();
      $("FileUploadRow").style.display="none";
      $("FileUploadInfoRow").style.display="table-row";
      }
    }
  return(data.status);
  }

function ClearStatus()
  {
  $("StatusButton").style.backgroundColor = "#D8D8D8";
  $("StatusStatus").innerHTML = "";
  $("StatusValue").innerHTML = "";
  $("StatusOther").innerHTML = "";
  $("StatusButtonMsg").innerHTML = "Waiting new status request...";
  $("StatusButton").value = "Submit Status Request";
  $("StatusRequestID").value = "";
  $("StatusLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("TarFileLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("KeywordFileLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("StatusDataLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  }

function GetStatus()
  {
  $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
  if ($("StatusRequestID").value.length == 0)
    {
    alert("You must provide a RequestID");
    return;
    }
    
    // An external user can check status on certain internal requests. These requests originated from the external site,
    // but they were passed-through to the internal site because they involved at least one internal series that
    // was whitelisted for external access. The request IDs of those requests contains an 'X':
    //
    // JSOC_20161225_1254_X_IN  
	var jsocfetchCGI = JSOC_FETCH;
	var is_IN = ($("StatusRequestID").value.search("_IN") > 0);
    var isExtOrigin = ($("StatusRequestID").value.search("_X_IN") > 0);

	if (is_IN && (Host.toLowerCase() == EXTERNAL_WEBSERVER || Host.toLowerCase() == EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN))
	{
		if (!isExtOrigin)
		{
			alert('The request ID ' +  $("StatusRequestID").value + ' is accessible from http://' + INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN +' only. Please use a request ID generated by a request made on the http://' + EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN +' webserver (which has a format of JSOC_YYYYMMDD_NNN or JSOC_YYYYMMDD_NNN_X_IN).');
			return;
		}

		jsocfetchCGI = JSOCEXTFETCH;
	}
	else if ((!is_IN || isExtOrigin) && (Host.toLowerCase() == INTERNAL_WEBSERVER || Host.toLowerCase() == INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN))
	{
		alert('The request ID ' +  $("StatusRequestID").value + ' is accessible from http://' + EXTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + ' only. Please use a request ID generated by a request made on the http://' + INTERNAL_WEBSERVER + '.' + STANFORD_DOMAIN + ' webserver (which has a format of JSOC_YYYYMMDD_NNN_IN).');
		return;
	}

  var arguments = {"op" : "exp_status", "requestid" : $("StatusRequestID").value};

  $("StatusLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("TarFileLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("KeywordFileLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("StatusDataLocation").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
  $("StatusButton").style.backgroundColor = colorPink;
  $("StatusStatus").innerHTML = "";
  $("StatusValue").innerHTML = "";
  $("StatusOther").innerHTML = "";
  $("StatusButtonMsg").innerHTML = "Processing status request ...";
  $("StatusButton").value = "Processing ...";
  
  new Ajax.Request('http://' + Host + '/cgi-bin/ajax/' + jsocfetchCGI,
    {
    method: 'get',
    parameters: arguments,

    onSuccess: function(transport, json)
      {
      var response = transport.responseText || "no response text";
      var data = response.evalJSON();
      state = 2;
      Cookie.setData("state",state);
      if (data.status == 6)
        {
        $("StatusButtonMsg").innerHTML = "RequestID not found, status=6, error=" + data.error + "<br>Try again in a few seconds, may just be not ready to respond";
        StatusReadyOK = 0;
        $("StatusButton").value = "Bad RecordSet";
        $("StatusValue").innerHTML = "Requested RecordSet returned error status=6";
        $("StatusOther").innerHTML = $("StatusRequestID").value + " not found,  msg=" + data.error;
        $("ReExportDiv").style.display = "none";
        state = 1;
        Cookie.setData("state",state);
        }
      else if (data.status == 5)
        {
        $("StatusButtonMsg").innerHTML = "Requested RequestID is too old, data no longer online, error=" + data.error;
        ExportReadyOK = 2;
        $("ExportButton").value = "Export timeout";
        $("ExportButtonMsg").innerHTML = data.error;
        $("RequestIdPlace").innerHTML = "";
        $("ExportStatus").innerHTML = "Export timeout";
        $("ExportLocation").innerHTML = "";
        $("ReRequestID").value = data.requestid;
        $("ReExportDiv").style.display = "block";
        }
      else if (data.status == 4)
        {
        StatusReadyOK = 0;
        ExportReadyOK = 2;
        $("StatusButton").value = "Bad RecordSet";
        $("StatusButtonMsg").innerHTML = data.error;
        $("StatusValue").innerHTML = "Requested RecordSet returned error status=4";
        $("StatusOther").innerHTML = $("StatusRequestID").value + "msg=" + data.error;
        $("ReExportDiv").style.display = "none";
        }
      else if (data.status == 3)
        {
        $("StatusButtonMsg").innerHTML = "Requested export size is too large: " + data.error + " Please contact the JSOC for help.";
        $("StatusButton").value = "Export Too Large";
        $("StatusButton").style.backgroundColor = "#D8D8D8";
        ExportReadyOK = 2;
        $("StatusStatus").innerHTML = "Needs Intervention, size=" + data.size + "MB, contact: " + data.contact;
        $("RequestIdPlace").innerHTML = data.requestid;
        $("StatusValue").innerHTML = "Requested RecordSet returned error status=3";
        $("StatusOther").innerHTML = $("StatusRequestID").value +
           "<br>The requested RecordSet is too large for chosen export method." +
           "<br>" + data.count + " records found, " + data.error +
           "<br>Please contact the JSOC for help." ;
        $("ReExportDiv").style.display = "none";
        }
      else if (data.status == 1 || data.status == 2)
	{
        if (data.status == 1)
          $("StatusButtonMsg").innerHTML = "Export request is being processed";
        else  // status==2
          $("StatusButtonMsg").innerHTML = "Export request waiting for processing";
        ExportReadyOK = 2;
        $("StatusButton").value = "Submit Status Request";
        $("StatusButton").style.backgroundColor = "#D8D8D8";
        // XXXXX FIX $("StatusStatus").innerHTML = "Processing, size=" + data.size + "MB, estimate " + data.wait + " seconds remaining";
        var waiting = 10 - data.wait;
        $("StatusStatus").innerHTML = "Processing, size estimate = " + data.size + " MB, " + waiting + " seconds since request";
        $("RequestIdPlace").innerHTML = data.requestid;
        $("ReExportDiv").style.display = "none";
        state = 1;
        Cookie.setData("state",state);
        }
      else // status == 0
        {
        ExportReadyOK = 2;
        var valuetable = "";
        $("StatusButtonMsg").innerHTML = "Please only click once for status request.";
        $("StatusButton").value = "Submit Status Request";
        $("StatusButton").style.backgroundColor = "#D8D8D8";
        $("StatusStatus").innerHTML = "Data Ready, size=" + data.size + "MB";
        $("RequestIdPlace").innerHTML = data.requestid;
        var StatusLoc;
	if (data.method.indexOf("ftp") >= 0)
          StatusLoc = "ftp://pail.stanford.edu/export" + data.dir + "/";
        else
          StatusLoc = "http://jsoc.stanford.edu" + data.dir + "/";
        $("StatusLocation").innerHTML = "<a href='" + StatusLoc + "' target='_blank'>" + StatusLoc + "<\/a>";
        if (data.method.indexOf("-tar") > 0)
          {
          $("TarFileLocation").innerHTML = "<a href='" + data.tarfile + "'>" + data.tarfile + "<\/a>";
          $("TarFileLocationRow").style.display = "table-row";
	  }
        else
          $("TarFileLocationRow").style.display = "none";
        if (data.protocol.indexOf("as-is") >= 0)
          {
          $("KeywordFileLocation").innerHTML = "<a href='" + data.keywords + "' target='_blank'>" + data.keywords + "<\/a>";
          $("KeywordFileLocationRow").style.display = "table-row";
          }
        else
          $("KeywordFileLocationRow").style.display = "none";

        $("ExportStatus").innerHTML = "Data Ready, size=" + data.size + "MB";
        valuetable = CreateDataTable(data, valuetable);
        $("StatusDataLocation").innerHTML =  valuetable + "<br>";
        $("StatusValue").innerHTML = "Success";
        $("StatusOther").innerHTML = "List formats are index.html, index.json, and index.txt<br>" +
             "export script file is " + $("StatusRequestID").value +".drmsrun" ;
        if (ExportFromFileList  == 1)
          FinishFileUpload();
        $("ReExportDiv").style.display = "none";
        state = 1;
        Cookie.setData("state",state);
        }
      },
    onFailure: function()
      {
      $("StatusButtonMsg").innerHTML = "Export Failure, Problem at JSOC facility.";
      $("StatusButton").value = "FAILURE ...";
      $("StatusButton").style.backgroundColor = colorDarkPink;
      alert('Something went wrong...');
      ExportReadyOK = 2;
      },
    onComplete: function() { $("AjaxBusy").innerHTML = Ajax.activeRequestCount; }
    });
  $("AjaxBusy").innerHTML = Ajax.activeRequestCount;
  }

</script>

</head>
<body bgcolor="#E0F0FF" onload="OnLoadInit();" >
<div id="header">
  <a href ="http://jsoc.stanford.edu" id="header_logo"><img src="http://hmi.stanford.edu/images/web/JSOC_120.gif"
    style="vertical-align:middle;height:60px;border:0" alt="JSOC logo"></a>
&nbsp;&nbsp;&nbsp;
<b><big style="vertical-align:middle">&nbsp;&nbsp;JSOC Data Export</big></b>
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
<input id="ResetPageButton" type="button" value="reset page" onClick="ReInitPage();" disabled>
&nbsp;&nbsp;&nbsp;
<input id="TipsOnOffButton" type="button" value="Turn Help Off" onClick="ToggleHelp();" >
&nbsp;&nbsp;<span id="AjaxBusy">0</span> Requests Pending
<span id='systemWorking'>, Loading...</span>
<!-- <br clear=all> -->
<hr>
</div> <!-- end div header -->
<div id="ExportRequestDiv">
<br><b>JSOC Data Export Request Generation</b>

<!-- Start Message of the Day -->
<div id="MOTD">
<!--#include virtual="JSOC_MOTD.html" -->
</div> <!-- end MOTD div -->
<!-- END MODT DIV -->

<span id="RecordSetExample">
&nbsp; &nbsp;
<a href="exportdata.d/ExportDataErrorHelp.html" target="JSOC_Help">Help with Error Messages</a>
&nbsp;
<a href="http://jsoc.stanford.edu/doc/exports/exportdata_lookdata_release_notes.txt" target="JSOC_Help">Release Notes</a>
</span>
<p>
If the Method is changed from "url_quick" or "url_direct" you will have additional options to specify.
"url-direct" is temporarily disabled.
<p>
After the request is submitted
for Methods of "url", "ftp", "url-tar" or "ftp-tar" you will recieve ON THIS PAGE a "Request_ID" that will be used
to access the data when it is ready.
<p>
If you enter an email address you will be notified when the data is ready.
If you do not provide an email address you must leave this page open or save the Request_ID in order to
access the data.
<p>

<!-- Load bulk of html code here -->
<span id="ExportRequestForm"></span>

<div id="iframeHideDiv" style="display:none;">
  <iframe id="FileUploadFrame" onload="uploadDone();" src="" style="height:0px;width:0px;border:0px solid #fff;"></iframe>
</div>

<div id="SubmitResponseDiv">
<table>
  <tr>
    <td>RequestID</td>
    <td colspan="2"><span id="RequestIdPlace" style="width:12em;background-color:#FFF8DC;">&nbsp;</span></td>
    <td>This is the ID tag for your export request.  Use the Status Request button below to retrieve the links to the data.</td>
  </tr>

  <tr>
    <td>Status</td>
    <td colspan="3"> <span id="ExportStatus" style="background-color:#FFF8DC;"> </span ></td>
  </tr>

  <tr>
    <td>Data Location</td>
    <td colspan="3"><span id="ExportLocation" style="background-color:#FFF8DC;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span ></td>
  </tr>

</table>
</div>
<hr>
<div id="ExportDataDiv"  style="background-color:#C0E0FF;">
<b>JSOC Data Export Status and Retrieval</b>
<p>
<table>
  <tr>
    <td style="width:10em" >RequestID</td>
    <td><input type="text" id="StatusRequestID" name="StatusRequestID" style="width:12em;background-color:#FFF8DC;" value="" onChange="GetStatus();"></td>
    <td>This is the ID tag for your export request.</td>
    <td><span id="StatusValue">&nbsp;</span></td>
  </tr>

  <tr>
    <td colspan="2" align="center" >
      <input id="StatusButton" type="button" value="Submit Status Request" style="background-color:#D8D8D8" onClick="GetStatus();" ></td>
    <td><span id="StatusButtonMsg">Please only click once for status request.</span ></td>
    <td rowspan="3"><span id="StatusOther">&nbsp;</span></td>
  </tr>

  <tr>
    <td colspan="2" align="center" >
      <input id="ClearButton" type="button" value="Clear Request" style="background-color:#D8D8D8" onClick="ClearStatus();" ></td>
    <td>Clear old status RequestID</td>
  </tr>

  <tr>
    <td>Status</td>
    <td colspan="2"> <span id="StatusStatus" style="background-color:#FFF8DC;"> </span ></td>
  </tr>

  <tr>
    <td>Data Location</td>
    <td colspan="3"><span id="StatusLocation" style="background-color:#FFF8DC;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span ></td>
  </tr>

  <tr id="TarFileLocationRow" style="display:none;">
    <td>Tar File Location</td>
    <td colspan="3"><span id="TarFileLocation"  style="background-color:#FFF8DC;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span ></td>
  </tr>

  <tr id="KeywordFileLocationRow" style="display:none;">
    <td>Keyword File Location</td>
    <td colspan="3"><span id="KeywordFileLocation"  style="background-color:#FFF8DC;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span ></td>
  </tr>

  <tr>
  <td colspan="4"><span id="StatusDataLocation" style="background-color:#FFF8DC;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span ></td>
  </tr>

</table>
</div> <!-- id="ExportRequestDiv" -->

<div id="ReExportDiv" style="display:none">
<HR>
Use this section to request a renewal/repeat of a prior export for which the data online-retention time has expired.
<table>

  <tr>
    <td style="width:10em" >RequestID</td>
    <td><input type="text" id="ReRequestID" name="ReRequestID" style="background-color:#FFF8DC;" value="" onChange="ExportNop();"></td>
    <td>Enter RequestID for repeat or prior export</td>
    <td><span id="ReStatusValue">&nbsp;</span></td>
  </tr>

  <tr id="ReNotifyRow">
    <td>Notify</td>
    <td><input id="ReExportNotify" type="text" name="Renotify" value="" onChange="ExportNop();" ></td>
    <td colspan="2">
      Provide your email address for notification.
      If Requestor is your SolarMail name you may use "solarmail" here.
    </td>
  </tr>
  
  <tr id="AjaxReExportRequestRow">
    <td colspan="4">
      re-<input id="ReExportButton" type="button" value="Submit Export Request" style="background-color:#D8D8D8" onClick="GetReExport();" >
    <span id="ReExportButtonMsg">Please only click once for re-export request.</span >
    </td>
  </tr>
  
</table>
</div> <!-- id="ReExportDiv" -->
</div>

<HR>
<P style="height:1px">
<div id="footer" style="vertical-align:bottom;text-align:center;">
<I>Home page for:</I>
<a href = "http://jsoc.stanford.edu/" id="footer_link"><b>SDO-JSOC</b></a>
</div>

<script type="text/javascript">
var unescaped_html = unescape(escaped_html);
$("ExportRequestForm").innerHTML = unescaped_html;
// The onload function is called after this. It calls ProcessingInit() and ProcessingEnabled(). Don't do that here as well.
</script>

</body>
</html>
