#!/bin/csh -f
# Create average images of HMI observables over 1/3 CR

@ TEST = 0	# set to 1 for production in namespace hmi_test
set TW
if ("$1" =~ '-test') then
  @ TEST = 1
  set TW = test
  shift
endif

if ($#argv < 2) then
  echo "usage: $0 [-test] [-TYP] CR CL"
  echo "  where TYP = [v|c|z|w|d] (v by default)"
  exit
endif

set DATAVG = datavg

if ($TEST) then
  set TSTOPT = ~rick/hmi/rings/testoptions
  if (!(-r $TSTOPT)) then
    echo Error: unable to read file $TSTOPT for test options
    exit
  endif
  set NMSP = hmi_test
  grep -q "^DATAVG =" $TSTOPT
  if ($status == 0) set DATAVG = `grep "^DATAVG =" $TSTOPT | awk '{print $3}'`
else
  set NMSP = hmi
endif

#  check that required scripts and programs are in path or rooted
foreach CMD ($DATAVG)
  which $CMD > /dev/null
  if ($status) then
    if (!(-x $CMD)) then
      echo Error: command $CMD not in path\; script will fail
      exit
    endif
  endif
end

# add flags
set DATAVG = "$DATAVG -v"

# base naming convention for I/O series and logs
set INMSP = hmi
if ($TEST) then
  set ONMSP = hmi_test
else
  set ONMSP = $INMSP
endif
set SUFX = avg120

set QMASK = 0x80004000
set RDIR = ~rick/hmi/qual/reject

if ($#argv > 2) then
  set FLAG
  set MSCALE = Default
  set MZERO = Default
  set PSCALE = Default
  set PZERO = Default
  switch ($1)
    case "-v":
      set ISER = $INMSP.V\_45s
      set OBS = V
      set RJCT = $RDIR.V
      set FLAG = -o
      set MSCALE = 0.25
      set MZERO = 0.0
      set PSCALE = 10.0
      set PZERO = 327670.0
      breaksw
    case "-c":
      set ISER = $INMSP.Ic\_45s
      set OBS = C
      set RJCT = "Not Specified"
      breaksw
    case "-z":
      set ISER = $INMSP.M\_45s
      set OBS = M
      set RJCT = "Not Specified"
      breaksw
    case "-w":
      set ISER = $INMSP.Lw\_45s
      set OBS = LW
      set RJCT = "Not Specified"
      breaksw
    case "-d":
      set ISER = $INMSP.Ld\_45s
      set OBS = LD
      set RJCT = "Not Specified"
      breaksw
    default:
      echo "usage: $0 [-TYP] CR"
      echo "  where TYP = [v|c|z|w|d]"
      exit
  endsw
  shift
else
  set TYP = vel
  set ISER = $INMSP.V\_45s
  set OBS = V
  set RJCT = $RDIR.V
  set FLAG = -o
  set MSCALE = 0.25
  set MZERO = 0.0
  set PSCALE = 10.0
  set PZERO = 327670.0
endif
@ CROT = `echo $1 | sed  -e "s/^0*//"`
@ CLON = `echo $2 | sed  -e "s/^0*//"`
set CARTIM = $CROT\:`printf %03d $CLON`

set OSER = $ONMSP.$OBS\_$SUFX
if ($TEST) then
  grep -q "^ISER =" $TSTOPT
  if ($status == 0) set ISER = `grep "^ISER =" $TSTOPT | awk '{print $3}'`
  grep -q "^BCKG =" $TSTOPT
  if ($status == 0) set OSER = `grep "^BCKG =" $TSTOPT | awk '{print $3}'`
endif

set PROG = `basename $0`

set TYPE = misc

set AVGKEYS = "DSUN_OBS,CRLT_OBS,RSUN_OBS,+"

# auxiliary files
set HOSTNAME = `hostname`
set HOSTID = `basename $HOSTNAME .Stanford.EDU`
set PROCID = $HOSTID\_$$
set NOTE = ~rick/rings/notify
set TMPFSLOC = ~rick/hmi/tmpfs
if (-r $TMPFSLOC) then
  set TMPFS = `egrep ^/tmp $TMPFSLOC`
  set TEMP = $TMPFS/`whoami`
  if (!(-d $TEMP)) mkdir $TEMP
  if (!(-w $TEMP)) set TEMP = /tmp
  set SCRFS = `egrep ^/scr $TMPFSLOC`
  set SCRT = $SCRFS/`whoami`
  if (!(-d $SCRT)) mkdir $SCRT
  if (!(-w $SCRT)) set SCRT = /tmp
else
  set TEMP = /tmp
  set SCRT = /tmp
endif
set SCRB = $SCRT/$SUFX
if ($TEST) set SCRB = $SCRB.$TW
if (!(-d $SCRB)) mkdir $SCRB
set LOGF = $SCRB/runlog$OBS
set TMPB = $TEMP/$OBS$SUFX
if ($TEST) set TMPB = $TMPB.$TW
if (!(-d $TMPB)) mkdir $TMPB
set MSGS = $TEMP/msgs
if (!(-d $MSGS)) mkdir $MSGS
set RLOG = $TMPB/$CARTIM
if (-e $RLOG)  mv $RLOG $RLOG.bck
set MMSG = $MSGS/msg.$PROCID

#  check that input and product series exist
foreach SER ($ISER $OSER)
  show_info -j ds= $SER >& /dev/null
  if ($status) then
    echo Error: series $SER does not exist\; script will fail
    exit
  endif
end

onintr INTERRUPT

# set up logging, notification
set NOW = `date +%Y.%m.%d_%T`
set SUBJ = "HMI $TW $OBS averaging for $CARTIM"
echo "$NOW begin averaging $CARTIM" > $MMSG
cat $MMSG >> $LOGF

@ BEGUN = `date +%s`
$DATAVG $FLAG in= $ISER tmid= $CARTIM out= $OSER length= 120 \
    qmask= $QMASK reject= $RJCT pkey= T_REC \
    mscale= $MSCALE mzero = $MZERO pscale= $PSCALE pzero= $PZERO \
    average= $AVGKEYS >>& $RLOG
if ($status) then
  set SUBJ = "HMI $TW $OBS averaging for $CARTIM incomplete"
  echo $SUBJ >> $LOGF
  echo "  run log is on $RLOG"  >> $MMSG
else
  set NOW = `date +%Y.%m.%d_%T`
  @ FINIS = `date +%s`
  @ ELAPS = $FINIS - $BEGUN
  @ ELAPS += 30
  @ ELAPS /= 60
  @ RECS = `show_info -q ds= $OSER"[$CROT][$CLON]" key= DataRecs`
  echo "  time for averaging $RECS records on `hostname`: $ELAPS min" >> $MMSG
  echo "  ($CARTIM) time for averaging $RECS records on `hostname`: $ELAPS min" >> $LOGF
  echo "$NOW finish" >> $MMSG
  echo "  average in $OSER""[$CROT][$CLON]" >> $MMSG
  head -20 $RLOG >> $LOGF
  echo "  ..." >> $LOGF
  tail -20 $RLOG >> $LOGF
endif
goto CLEANUP

INTERRUPT:
set SUBJ = "HMI $TW averaging for $CARTIM interrupted"
set TYPE = misc
echo "-> Script $PROG or module aborted! <-" >> $MMSG

CLEANUP:
set NOW = `date +%Y.%m.%d_%T`
set NOTIFY = `grep ^$TYPE $NOTE | awk '{print $2}'`
if ($#NOTIFY) then
  echo $SUBJ > $MSGS/subj.$PROCID
  echo "$NOTIFY" > $MSGS/list.$PROCID
endif
echo "$NOW finish $CARTIM" >> $LOGF
