#!/bin/csh -f
# Create average images of HMI observables over 1/3 CR

@ TEST = 0	# set to 1 for production in namespace hmi_test
if ("$1" =~ '-test') then
  @ TEST = 1
  shift
endif

if ($#argv < 2) then
  echo "usage: $0 [-test] [-TYP] CR CL"
  echo "  where TYP = [v|i|z|w|d] (v by default)"
  exit
endif

set DATAVG = datavg

#  check that required scripts and programs are in path or rooted
foreach CMD ($DATAVG)
  which $CMD > /dev/null
  if ($status) then
    if (!(-x $CMD)) then
      echo Error: command $CMD not in path\; script will fail
      exit
    endif
  endif
end

# add flags
set DATAVG = "$DATAVG -v"

# base naming convention for I/O series and logs
if ($TEST) then
  set NMSP = hmi_test
  set OBSV = 2
else
  set NMSP = hmi
  set OBSV
endif
set SUFX = avg120

set QMASK = 0x80004000
set RDIR = ~rick/hmi/qual/reject

if ($#argv > 2) then
  @ CROT = `echo $2 | sed  -e "s/^0*//"`
  @ CLON = `echo $3 | sed  -e "s/^0*//"`
  set FLAG
  switch ($1)
    case "-v":
      set TYP = vel
      set IN = $NMSP.V$OBSV\_45s
      set OBS = V
      set RJCT = $RDIR.V$OBSV\
      set FLAG = -o
      breaksw
    case "-i":
      set TYP = int
      set IN = $NMSP.Ic$OBSV\_45s
      set OBS = C
      set RJCT = "Not Specified"
      breaksw
    case "-z":
      set TYP = mag
      set IN = $NMSP.M$OBSV\_45s
      set OBS = M
      set RJCT = "Not Specified"
      breaksw
    case "-w":
      set TYP = lwd
      set IN = $NMSP.Lw$OBSV\_45s
      set OBS = LW
      set RJCT = "Not Specified"
      breaksw
    case "-d":
      set TYP = ldp
      set IN = $NMSP.Ld$OBSV\_45s
      set OBS = LD
      set RJCT = "Not Specified"
      breaksw
    default:
      echo "usage: $0 [-TYP] CR"
      echo "  where TYP = [v|i|z|w|d]"
      exit
  endsw
  set OUT = $NMSP.$OBS\_$SUFX
else
  @ CROT = `decimalize $1`
  @ CLON = `decimalize $2`
  set TYP = vel
  set IN = $NMSP.V$OBSV\_45s
  set OBS = V
  set OUT = $NMSP.V$OBSV\_avg120
  set RJCT = $RDIR.V$OBSV\
  set FLAG = -o
endif
set CARTIM = $CROT\:`printf %03d $CLON`

set PROG = `basename $0`

set TYPE = misc

# auxiliary files
set HOSTNAME = `hostname`
set HOSTID = `basename $HOSTNAME .Stanford.EDU`
set PROCID = $HOSTID\_$$
set NOTE = ~rick/rings/notify
set SCRT = /scr21/`whoami`
if (!(-d $SCRT)) set SCRT = /tmp
set SCRB = $SCRT/$SUFX
if (!(-d $SCRB)) mkdir $SCRB
set LOGF = $SCRB/runlog$OBS$OBSV
set TEMP = /tmp23/`whoami`
if (!(-d $TEMP)) set TEMP = /tmp
set TMPB = $TEMP/$OBS$OBSV$SUFX
if (!(-d $TMPB)) mkdir $TMPB
set MSGS = $TEMP/msgs
if (!(-d $MSGS)) mkdir $MSGS
set RLOG = $TMPB/$CARTIM
if (-e $RLOG)  mv $RLOG $RLOG.bck
set MMSG = $MSGS/msg.$PROCID

#  check that input and product series exist
foreach SER ($IN $OUT)
  show_info -j ds= $SER >& /dev/null
  if ($status) then
    echo Error: series $SER does not exist\; script will fail
    exit
  endif
end

onintr INTERRUPT

# set up logging, notification
set NOW = `date +%Y.%m.%d_%T`
set SUBJ = "HMI $OBS averaging for $CARTIM"
echo "$NOW begin averaging $CARTIM" > $MMSG
cat $MMSG >> $LOGF

@ BEGUN = `date +%s`
$DATAVG $FLAG in= $IN tmid= $CARTIM out= $OUT length= 120 mask= $QMASK \
    reject= $RJCT >>& $RLOG
if ($status) then
  set SUBJ = "HMI $OBS averaging for $CARTIM incomplete"
  echo $SUBJ >> $LOGF
  echo "  run log is on $RLOG"  >> $MMSG
else
  @ FINIS = `date +%s`
  @ ELAPS = $FINIS - $BEGUN
  @ ELAPS += 30
  @ ELAPS /= 60
  @ RECS = `show_info -q ds= $OUT"[$CROT][$CLON]" key= DataRecs`
  echo "  time for averaging $RECS on `hostname`: $ELAPS min" >> $MMSG
  echo "  ($CARTIM) time for averaging $RECS on `hostname`: $ELAPS min" >> $LOGF
  echo "$NOW finish" >> $MMSG
  echo "  average in $OUT""[$CROT][$CLON]" >> $MMSG
endif
goto CLEANUP

INTERRUPT:
set SUBJ = "HMI averaging for $CARTIM interrupted"
set TYPE = misc
echo "-> Script $PROG or module aborted! <-" >> $MMSG

CLEANUP:
set NOW = `date +%Y.%m.%d_%T`
set NOTIFY = `grep ^$TYPE $NOTE | awk '{print $2}'`
if ($#NOTIFY) then
  echo $SUBJ > $MSGS/subj.$PROCID
  echo "$NOTIFY" > $MSGS/list.$PROCID
endif
echo "$NOW finish $CARTIM" >> $LOGF
