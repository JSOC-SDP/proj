#include "mex.h"  /* must appear first */
#include <stdio.h>
#include <math.h>
#include "mexhead.h" /* my mex defines */
#include "hmi_segment_docstring.h"  /* autogenerated from this file */

/**************************************************************

%hmi_segment	driver for HMI segmentation
% 
% y=hmi_segment(xm,xp,iter,T,beta,alpha,ctr,rho,mode,m1,...)
% * Integrated routine for deriving HMI segmentations.  Uses
% models (m1,m2,...), plus a magnetogram-photogram pair,
% to deduce an integer labeling.  Besides images and models,
% it also requires some disk parameters and labeling smoothness 
% parameters.
% * The defaults for iter and T are inherited from mrf_segment_wts.
% 
% Inputs:
%   real xm(m,n)
%   real xp(m,n)
%   int iter[1] or [2];
%   real T[0] or [1] or [2] or [3] or [4];
%   real beta[1] or [K,K];
%   real alpha[K] or [0] = [];
%   real ctr(3) or ctr(4) or ctr(5);
%   real rho;
%   string mode
%   real m1(l,k1)
%   ...
%   real mR(l,kR)
% 
% Outputs:
%   int y(m,n)
%   opt real post
% 
% See Also:  makemrfdiscwts, mrf_segment_wts4, mixNprobNd

% turmon oct 2009, june 2010

****************************************************************/

/* standard boilerplate */
#define NARGIN_MIN	10	   /* min number of inputs (2 classes) */
#define NARGIN_MAX	12	   /* max number of inputs (4 classes) */
#define NARGOUT_MIN	1	   /* min number of output args */
#define NARGOUT_MAX	2	   /* max number of output args */

#define ARG_xm    0
#define ARG_xp    1
#define ARG_iter  2
#define ARG_T     3
#define ARG_beta  4
#define ARG_alpha 5
#define ARG_ctr   6
#define ARG_rho   7
#define ARG_m1    8
#define ARG_m2    9
#define ARG_m3    10
#define ARG_m4    11

#define ARG_y     0
#define ARG_post  1

static const char *progname = "hmi_segment";
#define PROGNAME hmi_segment
static const char *in_specs[NARGIN_MAX] = {
  "RM",
  "RM",
  "RS|RV(2)",             // iter
  "RS|RV(2)|RV(3)|RV(4)", // T
  "RS(1)|RM",             // beta
  "RV",                   // alpha
  "RV(3)|RV(4)|RV(5)",    // ctr
  "RS(1)",                // rho
  "RM",                   // m1, etc.
  "RM",
  "RM",
  "RM"};
static const char *in_names[NARGIN_MAX] = {
  "xm",
  "xp",
  "iter",
  "T",
  "beta",
  "alpha",
  "ctr",
  "rho",
  "m1",
  "m2",
  "m3",
  "m4"};
static const char *out_names[NARGOUT_MAX] = {"y", "post"};

// short form of PROGNAME for #include identifiers
#define SHORTNAME Hseg

// declarations of mex-functions we will use
#include "makemrfdiscwts.h"
#include "mixNprob2d.h"
#include "mrf_segment_wts.h"
#include "clean_edge_label.h"

// define the argument numbers we actually use
#define MXT_mdw_NARGIN_USE  MXT_mdw_NARGIN_MAX
#define MXT_mdw_NARGOUT_USE MXT_mdw_NARGOUT_MAX
#define MXT_m2d_NARGIN_USE  MXT_m2d_NARGIN_MIN // omit last arg (mode)
#define MXT_m2d_NARGOUT_USE MXT_m2d_NARGOUT_MAX
#define MXT_msw_NARGIN_USE  MXT_msw_NARGIN_MAX // actually variadic
#define MXT_msw_NARGOUT_USE MXT_msw_NARGOUT_MAX
#define MXT_cel_NARGIN_USE  MXT_cel_NARGIN_MAX
#define MXT_cel_NARGOUT_USE MXT_cel_NARGOUT_MIN // omit last output (nclean)


/************************************************************************
 *
 * Helper routine
 *
 ************************************************************************/

/*
 * Set off-disk image pixels to nan, in-place
 *
 * This is currently used for probability maps, but it could
 * also be used for the source images.
 */

static
void
segment_offdisk_nan(double *p, int maxx, int maxy, double *ctr)
{
  const double cenx = ctr[0];
  const double ceny = ctr[1];
  const double rsun2 = ctr[2]*ctr[2];
  const double nan = mxt_getnand();
  int x, y, inx;
  double dx, dy, r2;

  inx = 0;
  for (x = 0; x < maxx; x++)
    for (y = 0; y < maxy; y++, inx++) {
      // within the loop: inx = x*maxy + y
      if (isnan(p[inx]))
	continue; // already nan
      // offsets from center
      dx = x - cenx;
      dy = y - ceny;
      // radius, squared
      r2 = dx*dx + dy*dy;
      // plunk the nan if off-disk
      if (r2 > rsun2)
	p[inx] = nan;
    } /* end for (x,y) */
}

/*
 * Gateway routine
 */
#ifdef StaticP  /* undefined under mex */
StaticP
#endif
void 
mexFunction(int nlhs, 
	    mxArray *plhs[], 
	    int nrhs,
	    const mxArray *prhsC[])
{
  mxArray **prhs = (mxArray **) prhsC;    // squelch warnings
  // p=mixNprob2d(xm,xp,model)
  mxArray *prhs_m2d[MXT_m2d_NARGIN_USE];
  mxArray *plhs_m2d[MXT_m2d_NARGOUT_USE];
  // dist=makemrfdiscwts(n,del,ctr,rho)
  mxArray *prhs_mdw[MXT_mdw_NARGIN_USE];
  mxArray *plhs_mdw[MXT_mdw_NARGOUT_USE];
  // [yp,post] = mrf_segment_wts(iter,T,beta,alpha,dist,y,p1,p2)
  mxArray *prhs_msw[MXT_msw_NARGIN_USE]; // variadic, this is max #args
  mxArray *plhs_msw[MXT_msw_NARGOUT_USE];
  // res=clean_edge_label(img,center,delta,mode)
  mxArray *prhs_cel[MXT_cel_NARGIN_USE];
  mxArray *plhs_cel[MXT_cel_NARGOUT_USE];
  // general declarations
  int M, N;         // size of disc 
  int Nmod;         // number of models
  int i;
  char errstr[256];
  char *msg;        // returned error message

  /* Hook for introspection (function signature, docstring) */
  if (nrhs < 0) { 
    plhs[0] = mxt_PackSignature((mxt_Signature) (-nrhs), 
				NARGIN_MIN, NARGIN_MAX, 
				NARGOUT_MIN, NARGOUT_MAX, 
				in_names, in_specs, out_names, docstring);
    return;
  }
  /*
   * check args
   */
  if ((nrhs < NARGIN_MIN) || (nrhs > NARGIN_MAX))
    mexErrMsgTxt((snprintf(errstr, sizeof(errstr),
			 "%s: Expect %d <= input args <= %d",
			  progname, NARGIN_MIN, NARGIN_MAX), errstr));
  if ((nlhs < NARGOUT_MIN) || (nlhs > NARGOUT_MAX))
    mexErrMsgTxt((snprintf(errstr, sizeof(errstr),
			 "%s: Expect %d <= output args <= %d",
			  progname, NARGOUT_MIN, NARGOUT_MAX), errstr));
  printf("in hmi_segment\n");
  mexargparse(nrhs, prhsC, in_names, in_specs, NULL, progname);

  start_sizechecking();
  sizeinit(prhs[ARG_xp]);
  sizeagree(prhs[ARG_xm]); /* size(xp) == size(xm) */
  sizecheck_msg(progname, in_names, ARG_xp);

  /*
   * do the computation
   */
  M = mxGetM(prhs[ARG_xp]);
  N = mxGetN(prhs[ARG_xp]);
  Nmod = nrhs - ARG_m1; // number of models

  // disk-weighting function call
  prhs_mdw[MXT_mdw_ARG_n] = mxCreateDoubleMatrix(1, 2, mxREAL); // size
  mxGetPr(prhs_mdw[MXT_mdw_ARG_n])[0] = (double) M;
  mxGetPr(prhs_mdw[MXT_mdw_ARG_n])[1] = (double) N;
  prhs_mdw[MXT_mdw_ARG_del] = mxCreateDoubleScalar(3.0); // del
  prhs_mdw[MXT_mdw_ARG_ctr] = prhs[ARG_ctr]; // ctr
  prhs_mdw[MXT_mdw_ARG_rho] = prhs[ARG_rho]; // rho
  printf("segment: calling makemrfdiscwts\n");
  msg = main_makemrfdiscwts(MXT_mdw_NARGOUT_USE, plhs_mdw, 
			    MXT_mdw_NARGIN_USE,  prhs_mdw);
  if (msg)
    mexErrMsgTxt((snprintf(errstr, sizeof(errstr),
			   "%s: Trouble in make_mrfdiscwts (%s)",
			   progname, msg), errstr));
  // free what we allocated here, if we no longer need it
  mxDestroyArray(prhs_mdw[MXT_mdw_ARG_n]);
  mxDestroyArray(prhs_mdw[MXT_mdw_ARG_del]);

  // set up prob-finder input args
  prhs_m2d[MXT_m2d_ARG_i1] = prhs[ARG_xm]; // i1 = mgram
  prhs_m2d[MXT_m2d_ARG_i2] = prhs[ARG_xp]; // i2 = pgram
  for (i = 0; i < Nmod; i++) {
    prhs_m2d[MXT_m2d_ARG_model] = prhs[ARG_m1+i]; // m1, etc.
    printf("segment: calling mixNprob2d\n");
    msg = main_mixNprob2d(MXT_m2d_NARGOUT_USE, plhs_m2d, 
			  MXT_m2d_NARGIN_USE,  prhs_m2d);
    if (msg)
      mexErrMsgTxt((snprintf(errstr, sizeof(errstr),
			     "%s: Trouble in mixNprob2d[mod=%d] (%s)",
			     progname, i, msg), errstr));
    printf("\tprob%d[2048,2048] = %g\n", i, 
           mxGetPr(plhs_m2d[MXT_m2d_ARG_p])[2048*4096+2048]);
    // set off-disk to nan, in-place
    segment_offdisk_nan(mxGetPr(plhs_m2d[MXT_m2d_ARG_p]),
			M, N, mxGetPr(prhs[ARG_ctr]));
    // plunk into mrf input arg
    prhs_msw[MXT_msw_ARG_lprob1+i] = plhs_m2d[MXT_m2d_ARG_p]; 
  }
  // free what we allocated here, if we no longer need it
  // (we allocated nothing)

  // segmentation
  prhs_msw[MXT_msw_ARG_iters] = prhs[ARG_iter];
  prhs_msw[MXT_msw_ARG_T]     = prhs[ARG_T];
  prhs_msw[MXT_msw_ARG_beta]  = prhs[ARG_beta];
  prhs_msw[MXT_msw_ARG_alpha] = prhs[ARG_alpha];
  prhs_msw[MXT_msw_ARG_dist]  = plhs_mdw[MXT_mdw_ARG_dist];
  prhs_msw[MXT_msw_ARG_y]     = mxCreateDoubleMatrix(0, 0, mxREAL); // IC
  printf("segment: calling mrf_segment\n");
  // segment is variadic, so NARGIN uses #models
  msg = main_mrf_segment_wts(MXT_msw_NARGOUT_USE,     plhs_msw, 
			     MXT_msw_ARG_lprob1+Nmod, prhs_msw);
  if (msg)
    mexErrMsgTxt((snprintf(errstr, sizeof(errstr),
			   "%s: Trouble in mrf_segment (%s)",
			   progname, msg), errstr));
  printf("\tseg[2048,2048] = %g\n", 
	 mxGetPr(plhs_msw[MXT_msw_ARG_yp])[2048*4096+2048]);
  // free what we allocated here, if we no longer need it
  mxDestroyArray(prhs_msw[MXT_msw_ARG_dist]);
  mxDestroyArray(prhs_msw[MXT_msw_ARG_y]);
  for (i = 0; i < Nmod; i++)
    mxDestroyArray(prhs_msw[MXT_msw_ARG_lprob1+i]);

  // set up edge-clean input args
  prhs_cel[MXT_cel_ARG_image]  = plhs_msw[MXT_msw_ARG_yp];
  prhs_cel[MXT_cel_ARG_center] = prhs[ARG_ctr];  // center, used above too
  prhs_cel[MXT_cel_ARG_delta]  = mxCreateDoubleScalar(3.0); // fixed for now
  prhs_cel[MXT_cel_ARG_mode]   = mxCreateDoubleScalar(1.0);
  printf("segment: calling clean_edge_label\n");
  msg = main_clean_edge_label(MXT_cel_NARGOUT_USE, plhs_cel, 
			      MXT_cel_NARGIN_USE,  prhs_cel);
  if (msg)
    mexErrMsgTxt((snprintf(errstr, sizeof(errstr),
			   "%s: Trouble in clean_edge_label (%s)",
			   progname, msg), errstr));
  printf("\tsegp[2048,2048] = %g\n", 
	 mxGetPr(plhs_cel[MXT_cel_ARG_res])[2048*4096+2048]);
  // free what we allocated here, if we no longer need it
  mxDestroyArray(prhs_cel[MXT_cel_ARG_image]);
  mxDestroyArray(prhs_cel[MXT_cel_ARG_delta]);
  mxDestroyArray(prhs_cel[MXT_cel_ARG_mode]);

  // set up output args
  printf("segment: setting up outputs...\n");
  plhs[ARG_y] = plhs_cel[MXT_cel_ARG_res];
  if (nlhs > ARG_post)
    plhs[ARG_post] = plhs_msw[MXT_msw_ARG_post];
  else
    // did not need it after all
    mxDestroyArray(plhs_msw[MXT_msw_ARG_post]);

  printf("segment: returning from hmi_segment...\n");
}



/* Hook for generic tail matter */
#ifdef MEX2C_TAIL_HOOK
#include "mex2c_tail.h"
#endif

