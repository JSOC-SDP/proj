
/*
 * This file is generated by a script, do not edit.
 *
 * This documentation string was generated from
 * a C comment block within a mex program
 * by `doc2docstring.py' on Fri Jul  1 22:35:36 2011.
 */
 
static const char docstring[] =
	"smoothsphere: smooth a projected sphere with a kernel\n"
	"\n"
	" [y,s,p]=smoothsphere(x,geom,k,kparam,kwt,bws)\n"
	" * Given a solar image of location given by `geom', smooth it\n"
	" using the radially-symmetric kernel `k'.\n"
	" * This version is threaded, using 8 threads by default.\n"
	" Set MXT_NUM_THREADS in the environment to lower this number.\n"
	" * Off-disk values are indicated by NaN in the output.\n"
	" * The kernel used is dependent only on the weighted distance\n"
	" between two positions, say P1 and P2, in three-dimensional\n"
	" coordinates, normalized to live on the unit sphere:\n"
	"   d = P1 - P2\n"
	"   dist = d' W d  (>= 0)\n"
	" for a diagonal weight matrix W.\n"
	" The kernel values in `k' are specified for values of `dist'\n"
	" in a linear range from 0 to kparam(1), typically 0.015.\n"
	" Given a certain value of `dist' found between an image pixel\n"
	" and the kernel center, the associated weight is interpolated\n"
	" linearly using the table.  If dot > kparam(1), a zero weight\n"
	" is used.\n"
	" * We have typically let k be a gaussian kernel of width\n"
	" (standard deviation) = 0.0325, i.e.,\n"
	"   k(dist) = C * exp[ -0.5 * dist / sqr(0.0325) ],\n"
	" since dist is a squared quantity already, and C is a constant\n"
	" chosen to make k have unit norm as a spherical kernel.\n"
	" * As a shortcut, if k is a scalar, the kernel is taken to\n"
	" be the above function, but with width 0.0325 multiplied by\n"
	" k(1).  In this case, the LUT consists of 256 points evenly\n"
	" spaced over [0,kparam(1)].\n"
	" * The diagonal portion of the distance weight matrix W may be\n"
	" supplied as a triple kwt.  This weights distances between\n"
	" P1 and P2 in the x, y, and z directions respectively.   The\n"
	" P-angle (rotation in the x-y plane) is taken into account in\n"
	" this weighting, so that y is cross-track, and x and z are\n"
	" always along-track.\n"
	" * Typically the kernel falls to zero rather quickly.  As a\n"
	" computational shortcut, it is assumed that the kernel extends\n"
	" only kparam(2) pixels on each side of its center.  For W = I,\n"
	" this implies that an \"on\" pixel in x extends to influence at\n"
	" most a \"swath\" 2*kparam(2)+1 pixels on a side.  Both the P-angle\n"
	" and the W matrix are taken into account in finding the swath.\n"
	" For instance, a W_y > 1 will cause the y portion of the swath\n"
	" to shrink, because distance decreases faster.  The swath is\n"
	" always parallel to the (i,j) image axes, so P-angles not a\n"
	" multiple of 90 degrees will cause the swath to be enlarged\n"
	" to contain a rotated rectangle.\n"
	" * To decrease computational load, nearby pixels may be grouped\n"
	" into meta-pixels called blocks.  This is especially trouble-free\n"
	" away from the limb, where local geometry is nearly planar, so\n"
	" the blocking is given as a table that depends on z (in [0,1]).\n"
	" A row in the table of (z,bw) means: above the value z, use\n"
	" a blocking of bw (>1).  For z=0 to bws(1,1), no blocking is used.\n"
	" * For example, the small-image default means to use single pixels\n"
	" below 0.4, 2x2 blocks above 0.4, and 4x4 above 0.6.  For typical\n"
	" MDI images, this is 16%, 20%, and 64% of on-disk pixels, respectively.\n"
	" Using block sizes that do not pack together is legal, but causes\n"
	" inefficiency due to poor fits between abutting blocks; diagnose\n"
	" bad packing with the p output.\n"
	" * Supply bws=[] to treat all pixels singly (turn off blocking).\n"
	" * The optional output s is the z-coordinate (in [0,R]).\n"
	" The optional p output is the block (patch) number of each\n"
	" pixel.\n"
	"\n"
	" Inputs:\n"
	"   real x[m,n];\n"
	"   real geom[5];  -- [x0 y0 rsun b0 p0]\n"
	"   real k[p] or k[1];\n"
	"   real kparam[2];  -- [top window]\n"
	"   opt real kwt = [1 1 1];\n"
	"   opt real bws[bwnum,2] = [0.4 2;0.6 4];         -- m <  2048\n"
	"                         = [0.3 2;0.5 4; 0.7 8];  -- m >= 2048\n"
	"\n"
	" Outputs:\n"
	"   real y[m,n];\n"
	"   opt real s[m,n];\n"
	"   opt int  p[m,n];\n"
	"\n"
	" See also:\n"
	"\n"
	" implemented as a mex file\n"
	"\n"
	"";

/* End of generated file */

