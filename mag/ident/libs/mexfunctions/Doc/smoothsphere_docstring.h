
/*
 * This file is generated by a script, do not edit.
 *
 * This documentation string was generated from
 * a C comment block within a mex program
 * by `doc2docstring.py' on Mon May 17 17:04:08 2010.
 */
 
static const char docstring[] =
	"smoothsphere: smooth a projected sphere with a kernel\n"
	"\n"
	" [y,s]=smoothsphere(x,center,p0,k,kparam,kwt,bws)\n"
	" * Given a solar image of location given by center, and\n"
	" p-angle p0, smooth it using the radially-symmetric kernel\n"
	" listed in k.\n"
	"* * Off-disk values are indicated by NaN in the output.\n"
	" * The kernel used is dependent only on the weighted distance\n"
	" between two positions, say P1 and P2, in three-dimensional\n"
	" coordinates, normalized to live on the unit sphere:\n"
	"   d = P1 - P2\n"
	"   dist = d' W d  (>= 0)\n"
	" for a diagonal weight matrix W.\n"
	" The kernel values are specified for values of \"dist\" taken\n"
	" from a linear range from 0 to kparam(1).  Given a certain\n"
	" value of \"dist\" found between an image pixel and the kernel\n"
	" center, the associated weight is interpolated linearly using\n"
	" the table.  If dot > kparam(1), a zero weight is used.\n"
	" * The diagonal portion of the distance weight matrix W may be\n"
	" supplied as a triple kwt.  This weights distances between\n"
	" P1 and P2 in the x, y, and z directions respectively.   The\n"
	" P-angle (rotation in the x-y plane) is taken into account in\n"
	" this weighting, so that y is cross-track, and x and z are\n"
	" always along-track.\n"
	" * Typically the kernel falls to zero rather quickly.  As a\n"
	" computational shortcut, it is assumed that the kernel extends\n"
	" only kparam(2) pixels on each side of its center.  For W = I,\n"
	" this implies that an \"on\" pixel in x extends to influence at\n"
	" most a \"swath\" 2*kparam(2)+1 pixels on a side.  Both the P-angle\n"
	" and the W matrix are taken into account in finding the swath.\n"
	" For instance, a W_y > 1 will cause the y portion of the swath\n"
	" to shrink, because distance decreases faster.  The swath is\n"
	" always parallel to the (i,j) image axes, so P-angles not a\n"
	" multiple of 90 degrees will cause the swath to be enlarged\n"
	" to contain a rotated rectangle.\n"
	" * To decrease computational load, nearby pixels may be grouped\n"
	" into meta-pixels called blocks.  This is especially trouble-free\n"
	" away from the limb, where local geometry is nearly planar, so\n"
	" the blocking is given as a table that depends on z (in [0,1]).\n"
	" A row in the table of (z,bw) means: above the value z, use\n"
	" a blocking of bw (>1).  For z=0 to bws(1,1), no blocking is used.\n"
	" The default means to use single pixels below 0.4, 2x2 blocks\n"
	" above 0.4, and 4x4 above 0.6.  For typical MDI images, this is\n"
	" 16%, 20%, and 64% of on-disk pixels, respectively.  Supply\n"
	" bws=[] to treat all pixels singly (turn off blocking).\n"
	" * The optional output s is the z-coordinate (in [0,R]).\n"
	" The optional p output is the block (patch) number of each\n"
	" pixel.\n"
	"\n"
	" Inputs:\n"
	"   real x[m,n];\n"
	"   real center[3];  -- [center_x center_y r_sun]\n"
	"   real p0;         -- p-angle (degrees)\n"
	"   real k[p];\n"
	"   real kparam[2];  -- [top window]\n"
	"   opt real kwt = [1 1 1];\n"
	"   opt real bws[bwnum,2] = [0.4 2;0.6 4];\n"
	"\n"
	" Outputs:\n"
	"   real y[m,n];\n"
	"   opt real s[m,n];\n"
	"   opt int  p[m,n];\n"
	"\n"
	" See also:\n"
	"\n"
	" implemented as a mex file\n"
	"\n"
	"";

/* End of generated file */

