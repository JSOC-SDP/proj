
/*
 * This file is generated by a script, do not edit.
 *
 * This documentation string was generated from
 * a C comment block within a mex program
 * by `doc2docstring.py' on Thu Jun 16 23:24:56 2011.
 */
 
static const char docstring[] =
	"makemrfdiscwts	make distance metric for mrf segmentation\n"
	"\n"
	" dist=makemrfdiscwts(n,del,ctr,rho,mode,ell)\n"
	" * Given image sizes n, and neighborhood size del, make a distance\n"
	" metric array dist, such that dist(:,m1,n1) is the distance-to-\n"
	" neighbors of the site m1,n1, where 1 <= m1 <= n(1) and 1 <= n1 <= n(2).\n"
	" * Size of del = 3 corresponds to a 3x3 neighborhood around each site.\n"
	" * The distance is computed for a disk of center ctr(1:2) and radius\n"
	" ctr(3); ctr(1) corresponds to x or n1 and ctr(2) to y or m1.\n"
	" ctr(1:2) = [1 1] corresponds to the first pixel.\n"
	" * Thus, for instance, if Cx, Cy, r is the MDI center from mdidisk(),\n"
	" we would specify ctr=[Cx Cy r].  Note that ctr(1) and n(2) correspond\n"
	" to x, while ctr(2) and n(1) correspond to y.\n"
	" * Note that p-angle and b-angle are not needed by this routine.\n"
	" For simplicity, a 5-tuple containing these as entries 4 and 5\n"
	" (a `geom' vector) can be given for ctr, and the tail will be ignored.\n"
	" * The distance scale factor is rho.  Zero corresponds to uniform\n"
	" distances (all one) and large positive values correspond to\n"
	" separation-sensitive distances.  100 (20..200) is a typical value\n"
	" for images of radius 500.  To gain more insight, the raw distances\n"
	" (theta below) are returned when rho=NaN is given.  A histogram\n"
	" of theta values relative to exp(-theta*rho) will show whether most\n"
	" theta's land in the linear part of the exponential.\n"
	" * If rho < 0 is given, the scale factor is taken to be abs(rho), but\n"
	" the distances are rescaled so that the overall max equals 1.  Otherwise,\n"
	" the distances diminish across the entire disk as rho increases.\n"
	" * More explicitly, consider two points (s, s') within the 2d disk.\n"
	" They map to points on the unit sphere, say\n"
	"   s = (x y z), s' = (x' y' z'),\n"
	" The angle theta (>0) between them is found, and the distance\n"
	" is returned as:\n"
	"   dist = exp(-theta*rho)\n"
	" Because theta is very close to zero, the code in fact uses the chord\n"
	" distance rather than the arc distance between the two points.\n"
	" * Because the distance is symmetric, dist only includes distances\n"
	" between sites s,s' where s' is less than s.  This is the case if\n"
	" the pixel corresponding to s' comes before s in the memory footprint\n"
	" of an image.\n"
	" * Elliptical discs are allowed for.  In this case, ctr(3) is the\n"
	" major axis semidiameter, and ell(1) is that of the minor axis.\n"
	" ell(2) is the counterclockwise rotation, in degrees, of the major\n"
	" axis off of the \"m\" or \"y\" axis.  If not given, ell(1)=ctr(3) and\n"
	" ell(2)=0.  The implied condition ell(1) <= ctr(3) is not required\n"
	" by the code.\n"
	" * If either s or s' is off-disk, zero is put in the corresponding\n"
	" distance value.  This is required by mrf_segment_wts.\n"
	" * The required mode string switches between sesw (mode = 'sesw')\n"
	" or transposed (mode = 'sene') pixel ordering, which works as follows.\n"
	" * The normal HMI (and normal MDI) pixel ordering starts in the\n"
	" southeast corner, and the first scan line of pixels runs toward the\n"
	" southwest corner.  This is `sesw' ordering.  The transposed ordering\n"
	" is `sene'; this ordering is what we used for the JPL MDI processing.\n"
	" This is implemented via internal stride parameters.\n"
	" * This is implemented as a MEX file.  It agrees with makemrfdiscwts2.m\n"
	"\n"
	" Inputs:\n"
	"   int n(1) or (2); -- if n is scalar, assume a square image\n"
	"   int del;\n"
	"   real ctr(3) or ctr(4) or ctr(5);\n"
	"   real rho;\n"
	"   string mode;\n"
	"   opt real ell(2) = [ctr(3) 0];\n"
	"\n"
	" Outputs:\n"
	"   real dist ((del*del-1)/2,n(1),n(2));\n"
	"\n"
	" See Also:  makemrfdiscwts2, mrf_segment_wts\n"
	"\n"
	" turmon oct 2006\n"
	"\n"
	"";

/* End of generated file */

