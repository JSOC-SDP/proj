function hmi_init_run_common(scenario, mode, hooks, rgn)
%hmi_init_run_common	tracker file-output begin/end hook
% 
% hmi_init_run_common(scenario, mode, hooks, rgn)
% * Initializes (or finalizes) a tracker run, depending on 
% the sign of the mode input.
% * The type(s) of files created depends on the scenario input:
%   - If it contains "jsoc", the metafiles for ingestion into JSOC
%     are created.  
%   - If it contains "diagnostic", various full-disk
%     and per-track fits and .mat files are created.  
% The scenario can contain both or neither.
% * For initialization, this typically means creating new 
% header files, and also, removing old data files.
% * For finalization, this means writing a completion note
% into the earlier files.
% * The rgn input is an ROI_rgn structure from the 
% tracker.  Its fields are used to provide contextual information
% for the file headers.
% * Within hooks, we use: filename.template, run_name, and 
% tracker_params.
% 
% Inputs:
%   string scenario;
%   real mode;     -- negative or positive
%   struct hooks;  -- we use subfields of hooks
%   struct rgn;    -- the ROI_rgn structure
% 
% Outputs:
%   (to filesystem)
% 
% See Also:

% Written by Michael Turmon (turmon@jpl.nasa.gov) on 31 Dec 2010
% Copyright (c) 2010.  All rights reserved.

%
% Computation
% 
tmpl = hooks.filename.template; % filename template
run_name = hooks.run_name; % text giving tag for tracking run name
tp = hooks.tracker_params; % tracker numeric params

% file type, description, how it is fopen'ed
JSOC_filetypes = {{'final', 'track ID list: final',          ...
                   'cumulative finalized tracks',      'a'}, ...
                  {'new', 'track ID list: new',              ...
                   'most recent finalized tracks',     'w'}, ...
                  {'pending', 'track ID list: pending',      ...
                   'most recent still pending tracks', 'w'}, ...
                  {'param', 'tracker parameter list',          ...
                   'tracker parameters',               'w'}};

if mode < 0,
  %%
  %% Negative mode: Called from tracker_loop_begin
  %%

  if ~isempty(strfind(scenario, 'diagnostic')),
    %% remove files from prior run:
    % s: full-disk segmentations
    % rb: full-disk region boundaries
    % xfd: full-disk metadata (small .mat files)
    % ifd: full-disk instant files containing links to above files
    % mask: per-track scrolls (.mat files)
    % (mask is not written here, but this is a convenient place to remove it)
    for dir1loop = {'s', 'rb', 'xfd', 'ifd', 'mask'},
      dir1 = dir1loop{1}; % (dir1loop is a 1x1 cell)
      % fileparts() returns directory part of the sprintf'ed filename
      dir2 = fileparts(sprintf(tmpl, dir1, '', '', 'txt'));
      system(sprintf('rm -rf %s', dir2)); % with power comes responsibility
      mkdir(dir2);
    end;

    %% header of the fulldisk instant cat file (.../Tracks/track-fd-instant.cat)
    % make the filename
    fn_i = sprintf(tmpl, '', '-fd-instant', '', 'cat');
    fp = fopen(fn_i, 'w');
    % put header
    if fp == -1,
      error('%s: could not write %s, bad template?', mfilename, fn_i);
    end;
    fprintf(fp, '#\n# Cat file for fulldisk instant files\n#\n');
    fprintf(fp, '# Generated by %s on %s from matlab\n#\n', ...
            getenv('USER'), datestr(now));
    fclose(fp);
    
  end;
  
  if ~isempty(strfind(scenario, 'jsoc')),
    %% recreate the "new", "pending", "param" jsoc files
    for filetype_ = JSOC_filetypes,
      filetype = filetype_{1}; % extract 4-element cell
      f_tag = ['-' filetype{1}];
      fn_i = sprintf(tmpl, 'jsoc', f_tag, '', 'txt');
      [junk1,junk2] = mkdir(fileparts(fn_i)); % suppress warning if exists
      fp = fopen(fn_i, filetype{4});
      if fp == -1,
        error('%s: could not write %s, bad template?', mfilename, fn_i);
      end;
      fprintf(fp, '# HMI %s: %s\n', filetype{2}, filetype{3});
      fprintf(fp, '# Created while running: %s\n', run_name);
      fprintf(fp, '# Generated by %s on %s from matlab\n', ...
              getenv('USER'), datestr(now));
      fprintf(fp, '#\n');
      fclose(fp);
    end;
    %% dump the param file
    f_tag = '-param';
    fn_i = sprintf(tmpl, 'jsoc', f_tag, '', 'txt');
    fp = fopen(fn_i, 'a');
    if fp == -1,
      error('%s: could not append to param file %s', mfilename, fn_i);
    end;
    for fn = fieldnames(tp)',
      num = tp.(fn{1});
      num = num(:)'; % force a row vector
      fprintf(fp, '%s: %s\n', fn{1}, mat2str(num, 14));
    end;
    % some extra stuff
    fprintf(fp, 'run_name: %s\n', run_name);
    fprintf(fp, 'run_time: %s\n', datestr(now));
    fprintf(fp, '# end\n');
    fclose(fp);
  end;

else,
  %%
  %% Positive mode: Called from tracker_loop_end
  %%

  if ~isempty(strfind(scenario, 'jsoc')),
    %% close off the "new" and "pending" jsoc files
    for filetype_ = JSOC_filetypes,
      filetype = filetype_{1}; % extract 3-element cell
      f_tag = ['-' filetype{1}];
      fn_i = sprintf(tmpl, 'jsoc', f_tag, '', 'txt');
      [junk1,junk2] = mkdir(fileparts(fn_i)); % suppress warning if exists
      fp = fopen(fn_i, 'a'); % always append at closing time
      if fp == -1,
        error('%s: could not append to %s, bad template?', mfilename, fn_i);
      end;
      fprintf(fp, '# Final frame number = %d\n', rgn.imagenum);
      fprintf(fp, '# Final frame handle = %s\n', rgn.currfile);
      fprintf(fp, '# End of run: %s\n', run_name);
      fprintf(fp, '#\n');
      fclose(fp);
    end;
  end;

end;

return;

