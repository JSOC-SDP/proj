#include "mex.h"  /* must appear first */
#include <stdio.h>
#include <math.h>
#include "mexhead.h"
#include "Doc/rotate_docstring.h"  /* autogenerated from this file */
#include <strings.h>
#include <string.h> // strtok
#include <sys/time.h> // for timing


/**************************************************************

%rotate: rotates the sun for a given number of hours (new version)
% 
% y=rotate(x,geom1,geom2,hours,mode,bb);
% * Given a solar image x with pose given by geom1, rotate it backward
% in time by hours hours, into the pose given by geom2.  Off-disk and
% unknown values are indicated by NaN.
% * The differential rotation coefficients are defined by this routine.
% The rotation speed depends on latitude, according to:
%   omega = coefs(1) + coefs(2) * S + coefs(3) * S^2
% where S = [sin(latitude)]^2, and omega is the apparent
% angular velocity in degrees/day.  The equator rotates fastest,
% but this is not assumed in the code.
% * We use obs_v = 0.9865 deg/day and coefs = [14.6,-2.2,0] deg/day.
% * The required mode parameter selects two things, sesw or transposed 
% pixel ordering, and also full vs. sparse rotation.  These work
% as follows.
% * The normal HMI (and normal MDI) pixel ordering starts in the
% southeast corner, and the first scan line of pixels runs toward the
% southwest corner.  This is `sesw' ordering.  The transposed ordering
% is `sene'; this ordering is what we used for the JPL MDI processing. 
% In particular, the older rotate routine uses the transposed ordering.
% This is implemented via internal stride parameters.
% * The regular full-image rotation looks at every pixel in the
% target image and interpolates a value for each.  Or, a 'sparse'
% algorithm can be specified when the rotated input x is mostly zero,
% as for example indicators of active regions.  This method does 
% a pre-scan of x to determine where the nonzero values are, and
% only computes y in a box bounding the one where x will move to,
% not over the whole disk.  It thus saves computation depending on
% the extent of the nonzeros in x (more compact is better).
% * If the bounding box of nonzeros in x is known, it can be given
% as the last argument and that region will be used to restrict the 
% pre-scan of x.
% * When mode contains `sparse', uncomputed values are left as zero 
% outside this box.  Such zero values can be known, on-disk values 
% that happen to be zero, or off-disk value, or values that would be 
% unknown.  In short, no distinction is made between 0 and NaN as 
% opposed to when mode contains `full'.  But in particular, all 
% non-zero, non-NaN values will match up.
% 
% Inputs:
%   real x(m,n);
%   real geom1(5);              -- [center_x center_y r_sun beta p0]
%   opt real geom2(5) = geom1;  -- (empty defaults to above)
%   real hours;
%   char mode = 'full,sesw'     -- required, in: {full,sparse}x{sesw,sene}
%   opt int bb = [1 1 m n]      -- matlab coordinates
% 
% Outputs:
%   real y(m,n);
% 
% See also:

% implemented as a mex file
% turmon rewrote (again) Sept 2010
****************************************************************/

/* constants and globals used for error checking */

#define NARGIN_MIN	4	   /* min number of inputs */
#define NARGIN_MAX	6	   /* max number of inputs */
#define NARGOUT_MIN	1	   /* min number of outputs */
#define NARGOUT_MAX	1	   /* max number of outputs */

#define ARG_X     0
#define ARG_GEOM1 1
#define ARG_GEOM2 2
#define ARG_HRS   3
#define ARG_MODE  4
#define ARG_BB    5

#define ARG_Y     0

static const char *progname = "rotate";
#define PROGNAME rotate
static const char *in_specs[NARGIN_MAX] = {
  "RM",
  "RV(5)",
  "RS|RV(5)",   // RS permits [], which we want
  "RS",
  "SV",
  "RS|RV(4)"};  // permits []
static const char *in_names[NARGIN_MAX] = {
  "x",
  "geom1",
  "geom2",
  "hours",
  "mode",
  "bb"};
static const char *out_names[NARGOUT_MAX] = {
  "y"};

static int verbose = 0;

/*
 * Solar rotation constants
 * all in deg/day
 * first has sidereal rate, less Earth's rotational rate, to make synodic rate
 * if you're sensitive to these values, you're probably doing something wrong...
 */

#define ROTATE_CONST_K0 (14.6-0.9865) 
#define ROTATE_CONST_K1 (-2.2)
#define ROTATE_CONST_K2 0.0

/*
 * extracts various mode parameters from a free-form string
 *
 * returns 0 if the string was OK, an explanatory tag otherwise
 */
static
char *
extract_mode(char *mode, int *Mfull, int *Msesw) 
{
  char *word;
  char *sep = ", \t";

  if (!mode) return "null"; /* should not happen */
  for (word = strtok(mode, sep); word; word = strtok(NULL, sep)) {
    /* full/sparse */
    if      (strcasecmp(word, "full"  ) == 0) *Mfull = 1;
    else if (strcasecmp(word, "sparse") == 0) *Mfull = 0;
    /* sesw, or transposed */
    else if (strcasecmp(word, "sesw"  ) == 0) *Msesw = 1;
    else if (strcasecmp(word, "sene"  ) == 0) *Msesw = 0;
    /* unrecognized word: not OK */
    else return word; 
  }
  return 0; /* OK */
}



/***
 ***
 ***   BASIC ROTATION SUBROUTINES
 ***
 ***/


/*
 * interpolate in one dimension, returning
 *   l * i0 + (1-l) * i1
 * if possible.  If both are NaN, NaN is returned.
 * If only i0 is NaN, i1 is returned, unless l = 1. 
 * The latter indicates no contribution from i1 
 * is allowed, so NaN must be returned.  
 * Similarly if only i1 is NaN.
 */
inline 
double 
interp1(double l,
	double i0,
	double i1,
	double nan)

{
  switch ((isnan(i1) ? 2 : 0) + (isnan(i0) ? 1 : 0)) {
  case 0:
    return l*i0 + (1.0-l)*i1; /* interpolate */
    break;
  case 1:
    return (l < 1.0) ? i1 : nan; /* i0 is nan, i1 isn't */
    break;
  case 2:
    return (l > 0.0) ? i0 : nan; /* i1 is nan, i0 isn't */
    break;
  case 3:
    return nan; /* hopeless */
    break;
  }
}


/* 
 * is this a valid index into an image: 
 *   0 <= i1 < M1 and 0 <= i2 < M2
 * used in do_rotate and find_extent
 * 
 * undef'd at the end of this file
 */
#define ISVALID(i1,i2,M1,M2) (((i1)>=0) && ((i1)<M1) && \
                              ((i2)>=0) && ((i2)<M2))


/*
 * do_rotate: perform the rotation, b = rotate(a)
 *
 * Algorithm is to scan "target" or b image, and at each site (x,y), try
 * to map it back to the "source" or a image at (xp,yp).  This can't be
 * done if (x,y) is not on-disk in the target (in which case, put NaN).
 * It also fails when (xp, yp) is not visible on the source image, which
 * happens when it has rotated around to the back side.  Again, put NaN.
 *
 * The computation is done only in a bounding box around some region
 * of interest in the target image, given by bb[01][xy].  Ordinarily
 * the box encompasses the whole image.  The sparse mode works by
 * narrowing the range of the box.
 * 
 * The mapping (x,y) -> (xp,yp) can be done many ways.  A general 
 * and foolproof way is to associate a site with a position on 
 * the sphere in three dimensions, say 
 *    p1 = (p1x,p1y,p1z).  
 * Here, (x,y) is the image plane, and z projects back to the 
 * observer (z>=0 for the visible side).  The map from target 
 * "backwards" to source means three rotations: 
 * first, by beta in the y-z plane, then by an amount delta where
 *   delta = f_kappa(hours,sin(lat)^2), 
 *   kappa = [k0 k1 k2],
 * in the x-z plane, and then back by beta in the y-z plane.
 *
 * In vector notation, this can be written
 *    p2 = T_{-beta} S_{delta} T_{beta} p1
 * where T and S are 3x3 rotation matrices parameterized by the
 * given angles.  Note that the reverse transformation is
 *    p1 = T_{-beta} S_{-delta} T_{beta} p2
 * since inv(T_{beta}) = T_{-beta}.
 * 
 * In particular, since T_beta leaves x unchanged,
 *              1     0   0
 *     T_beta = 0  cosB  sinB
 *              0 -sinB  cosB
 * and similarly for S_delta.  Note that delta is a function of
 * latitude(p1) == latitude(p2), and that the sine of this latitude
 * is just the y component of T_{beta} p1.
 *
 * Anyway, the algorithm to find (xp,yp) just implements these 
 * three matrix multiplies, with some calculation in between to 
 * determine delta.  If z<0, the desired point in the target is 
 * off-disk, so fill in NaN.  Otherwise, interpolate the source
 * image using bilinear interpolation around the "quadrant" 
 * [floor(xp),ceil(xp)] X [floor(yp),ceil(yp)].
 */

static
void 
do_rotate(int bb0x,     // "bottom" bounding box corner 
	  int bb0y, 
	  int bb1x,     // "top" bounding box corner 
	  int bb1y,
	  int maxx,     // image size 
	  int maxy,
	  int strx,     // stride of a and b along x, units of doubles
	  int stry,     // stride along y
	  double *a,    // input image
	  double *b,    // output image
	  // geom1
	  double x01,   // x center, in C coords, origin at 0 
	  double y01,   // y center, in C coords, origin at 0 
	  double R1,    // radius, in pixels 
	  double B1,    // tilt angle, radians 
	  double P1,    // twist angle, radians 
	  // geom2
	  double x02,   // x center, in C coords, origin at 0 
	  double y02,   // y center, in C coords, origin at 0 
	  double R2,    // radius, in pixels 
	  double B2,    // tilt angle, radians 
	  double P2,    // twist angle, radians 
	  // velocity coeffs
	  double k0,    // order-0 coefficient, radians 
	  double k1,    // order-1 coefficient, radians 
	  double k2)    // order-2 coefficient, radians 

{
  int    x, y, off0;      // target ("b") image coordinates, offset
  double p1x, p1y, p1z;   // point P1 coords in 3D 
  double p2x, p2y, p2z;   // point P2 coords in 3D 
  double temp;            // workspace slot 
  double cosD, sinD;      // rotation parameters 
  int xs0, ys0;           // position of "lower" pixel in source (a) image 
  double a00, a01, a10, a11; // aXY = src image @ x=xs0+X, yt=ys0+Y 
  double lambdaX, lambdaY; // wts: in 1D, b(xt) = lambda*a0 + (1-lambda)*a1 
  const double nan = mxt_getnand(); // cache nan 
  // cache geom1
  const double cosB1 = cos(B1);
  const double sinB1 = sin(B1);
  const double cosP1 = cos(P1);
  const double sinP1 = sin(P1);
  const double R1_R2 = R1/R2;
  // cache geom2
  const double cosB2 = cos(B2);
  const double sinB2 = sin(B2);
  const double cosP2 = cos(P2);
  const double sinP2 = sin(P2);
  const double R2_inv = 1.0/R2;
  struct timeval tv1, tv2;

  gettimeofday(&tv1, NULL);
  /* loop over all target image pixels, filling each one in */
  for (x = bb0x; x <= bb1x; x++)
    for (y = bb0y; y <= bb1y; y++) {
      /* find target image ("2") vector coordinates P2 = (px2, py2, pz2) */
      p2x = x - x02;
      p2y = y - y02;
      /* computing:  temp = R*R - p2x*p2x - p2y*p2y, but want to avoid
       * subtracting large squares, e.g. when p2x ~= +/- R, which is not
       * numerically good.  We can do so for one subtraction (only) via
       *    a*a - b*b = (a - b)*(a + b).  
       * That way, one factor or the other will be close to zero, before 
       * squaring.
       * We can only rewrite using x or y, but not both.  So we should
       * check which is closer to +/- R, and expand that term.  This costs
       * too much time, so for now just rewrite the x term only,
       * which improves matters half the time.
       */
      temp = (R2 + p2x) * (R2 - p2x) - p2y*p2y; /* R*R-x*x = (R-x)*(R+x) */
      if (temp < 0) { b[x*strx+y*stry] = nan; continue; } /* off-disk */
      p2z = sqrt(temp);  /* the positive sqrt is the visible half-sphere */
      /* rotate P2 into P1 in the xy plane (the p-angle) -- z is unchanged */
      p1x =  cosP2 * p2x + sinP2 * p2y;
      p1y = -sinP2 * p2x + cosP2 * p2y;
      p1z = p2z;
      /* rotate by B2 in yz plane (x axis fixed): P2 = rot(P1) */
      p2x =  p1x;  /* no change to x */
      p2y =  cosB2 * p1y + sinB2 * p1z;
      p2z = -sinB2 * p1y + cosB2 * p1z;
      /* find the rotation angle due to the time difference */
      temp = R2_inv * p2y; // extract sin(lat) from p2y
      temp *= temp;        // temp is now sin(lat)^2
      temp = k0 + temp*(k1 + k2*temp); // k0 + k1*temp + k2*temp^2
      /* temp is now the rotation angle delta, find its sine and cosine */
      cosD = cos(temp);
      sinD = sin(temp);
      /* rotate by delta in xz plane (y fixed): P1 = rot(P2) */
      p1x =  cosD * p2x + sinD * p2z; 
      p1y =  p2y; /* no change to y */
      p1z = -sinD * p2x + cosD * p2z;
      /* de-rotate by B1 in yz plane (x fixed): P2 = rot(P1) */
      p2x =  p1x; /* no change to x */
      p2y =  cosB1 * p1y - sinB1 * p1z;
      p2z =  sinB1 * p1y + cosB1 * p1z;
      /* check for points absent from the front side of the source (a) image */
      if (p2z < 0) { b[x*strx+y*stry] = nan; continue; } /* off-disk */
      /* de-rotate in xy plane by P1, scale by R1/R2, translate back to (x01, y01) */
      p1x = R1_R2 * (cosP1 * p2x - sinP1 * p2y) + x01;
      p1y = R1_R2 * (sinP1 * p2x + cosP1 * p2y) + y01;
      /* in essence b(x,y) = a(p1x,p1y).  But must approximate 
	 a(p1x,p1y), so use bilinear interpolation on the 
	 four pixels surrounding this point, ignoring NaN's */
      /* "lower" corner of box in source image containing remapped (x,y) */
      xs0 = floor(p1x);
      ys0 = floor(p1y);
      /* Find the box of enclosing pixels; if off-image, substitute a NaN */
      off0 = xs0 * strx + ys0 * stry; // offset from a(0,0) to a(xs0,ys0)
      a00 = ISVALID(xs0,   ys0,   maxx, maxy) ? a[off0          ] : nan;
      a01 = ISVALID(xs0,   ys0+1, maxx, maxy) ? a[off0+     stry] : nan;
      a10 = ISVALID(xs0+1, ys0,   maxx, maxy) ? a[off0+strx     ] : nan;
      a11 = ISVALID(xs0+1, ys0+1, maxx, maxy) ? a[off0+strx+stry] : nan;
      /* find the weights associated with smaller-indexed pixels */
      lambdaX = 1 - (p1x - xs0); 
      lambdaY = 1 - (p1y - ys0); 
      /* bilinear interpolation within the box to find the new pixel */
      b[x*strx+y*stry] = interp1(lambdaX,
				 interp1(lambdaY, a00, a01, nan),
				 interp1(lambdaY, a10, a11, nan), nan);
    } /* end for (x,y) */
  gettimeofday(&tv2, NULL);
  int dtval = (((long) tv2.tv_sec) - ((long) tv1.tv_sec)) * 1000000 + 
    (((int) tv2.tv_usec) - ((int) tv1.tv_usec));
  if (verbose)
    mexPrintf("  finishing do_rotate: dt = %.1f ms\n", dtval/1000.0);
}

/***
 ***
 ***   SPARSE BOX-FINDING SUBROUTINES
 ***
 ***   The remaining routines work together to find one (m,n) bounding
 ***   box, within the target, that contains the rotated version of
 ***   all non-zero, non-nan, on-disk source pixels. 
 ***/

/*
 * update_lon: update longitude components of a lat-lon bounding
 * box by passing the previous interval through a latitude-dependent
 * mapping.
 * Background: It is convenient to use interval arithmetic and note that
 * continuous functions of intervals in R yield intervals in R (e.g., Rudin,
 * theorem 4.22).  
 * So, the interval we start with will map to another interval, and we 
 * don't have to do anything fancy along the way, except to remember 
 * the current interval.  (This throws away some constraints that, if 
 * exploited, could further constrain the interval -- but this will always 
 * supply an upper bound on interval location.)
 * The mapping is
 * [lonp0,lonp1] = [lon0,lon1] + [del0,del1]
 * where [del0,del1] = f_kappa(sin^2([lat0,lat1]))
 * Above f_kappa is the quadratic, parameterized by three coeffs k0, k1, k2:
 * f_kappa(a) = k0 + a k1 + a*a k2
 * where (above) a = sin^2(lat).
 * Since [lat0,lat1] is an interval, so is sin^2 of it, and so is f_kappa
 * of that interval, and indeed so is the overall mapping to get lonp.  
 * The only tricky point is that all functions aren't monotonic, so we need
 * to be careful about (for example) 
 *    sin^2([-pi/4,+pi/4]) != [sin^2(-pi/4),sin^2(pi/4)]
 * In general this could be hard, but not for quadratics.  In particular, if
 * g(.) is quadratic, then the endpoints of the interval g([a,b]) are 
 * A = g(a) or B = g(b), or C = g(c), where c is the point in [a,b] (if any) 
 * that extremizes the quadratic.  So we just need to take min(A,B,C) and 
 * max(A,B,C) to find the two endpoints of the interval, where we understand
 * that we set C = B (say) if c is not in [a,b].
 */
/* note, these evaluate their arguments several times */
/* min of three arguments */
#define min3(a,b,c) ( ((a) <= (b)) ? ( ((a) <= (c)) ? (a) : (c) ) : \
                                     ( ((b) <= (c)) ? (b) : (c) ) )
/* max of three arguments */
#define max3(a,b,c) ( ((a) >= (b)) ? ( ((a) >= (c)) ? (a) : (c) ) : \
                                     ( ((b) >= (c)) ? (b) : (c) ) )

static
void 
update_lon(double *lon0p,
	   double *lon1p,
	   double k0,
	   double k1,
	   double k2,
	   double lat0,
	   double lat1,
	   double lon0,
	   double lon1)
{
  double ptA, ptB, ptC;  /* holding places for possible endpoints */
  double alpha0, alpha1; /* for the range of sin^2(.) mapping */
  double delta0, delta1; /* for the range of f(sin^2(.)) mapping */
  double alphaT;         /* temporary alpha value */

  /* first mapping: [alpha0,alpha1] = sin^2([lat0,lat1]) */
  /* (note, sin(.) is easy because it's monotonic for latitude angles) */
  ptA = sin(lat0); ptA *= ptA;  /* one endpoint of the interval */
  ptB = sin(lat1); ptB *= ptB;  /* other endpoint */
  ptC = (lat0 * lat1 < 0) ? 0.0 : ptB; /* ptC = sin^2(0) = 0 if 0 in [lat0,lat1] */
  alpha0 = min3(ptA,ptB,ptC);
  alpha1 = max3(ptA,ptB,ptC);
  /* second mapping: [delta0,delta1] = f_kappa([alpha0,alpha1]) */
  ptA = -(k0 + k1 * alpha0 + k2 * alpha0 * alpha0);
  ptB = -(k0 + k1 * alpha1 + k2 * alpha1 * alpha1);
  ptC = ptB; /* if unchanged below, this will be a no-op */
  if (k2 != 0) {
    alphaT = -k1/(2 * k2);  /* the extremizing (max or min) alpha */
    /* test if alphaT in [alpha0,alpha1] */
    if ((alpha0 - alphaT) * (alpha1 - alphaT) < 0)
      ptC = -(k0 + k1 * alphaT + k2 * alphaT * alphaT); /* ptC = f_kappa(alphaT) */
  }
  delta0 = min3(ptA,ptB,ptC);
  delta1 = max3(ptA,ptB,ptC);
  /* finally, [lon0p,lon1p] = [lon0,lon1] + [delta0,delta1] */
  *lon0p = lon0 + delta0;
  *lon1p = lon1 + delta1;
}  

/* don't leave these macros hanging around */
#undef min3
#undef max3


/*
 * pointmap: map a point in (lat,lon) coordinates on a sphere, at tilt 
 * angle B given by (sinB, cosB), to (x,y,z) coordinates.
 */
static
void
pointmap(double *px, double *py, double *pz, /* output: point coords */
	 double s_lat, double c_lat,         /* lat sine and cosine */
	 double s_lon, double c_lon,         /* lon sine and cosine */
	 double sinB, double cosB,
	 double sinP, double cosP)
{
  // intermediate point coords
  double qx, qy, qz; 
  double rx, ry, rz; 

  qx = c_lat * s_lon;
  qy = s_lat;
  qz = c_lat * c_lon;
  /* rotate by -beta in yz plane (x axis fixed): R = rot(Q) */
  rx =  qx;  /* no change to x */
  ry =  cosB * qy - sinB * qz;
  rz =  sinB * qy + cosB * qz;
  /* rotate by -p in xy plane (z axis fixed): P = rot(R) */
  *px =  cosP * rx - sinP * ry;
  *py =  sinP * rx + cosP * ry;
  *pz =  rz;  // no change to z
}

/*
 * pointunmap: map a point in (x,y,z) coordinates on a sphere, at tilt 
 * angle B given by (sinB, cosB), to (lat,lon) coordinates.
 */
static
void
pointunmap(double *lat, double *lon, /* output: point coords */
	   double px, double py, double pz, 
	   double sinB, double cosB,
	   double sinP, double cosP)
{
  // intermediate point coords
  double qx, qy, qz; 
  double rx, ry, rz; 

  /* rotate by +p in xy plane (z axis fixed): R = rot(P) */
  rx =  cosP * px + sinP * py;
  ry = -sinP * px + cosP * py;
  rz =  pz;  // no change to z
  /* rotate by +beta in yz plane (x axis fixed): Q = rot(R) */
  qx =  rx;  /* no change to x */
  qy =  cosB * ry + sinB * rz;
  qz = -sinB * ry + cosB * rz;
  /* find lat and lon */
  *lon = atan2(qx, qz);  /* p2=(1,0,0), at limb, has lon=pi/2 */
  *lat = asin(qy);
}

/*
 * find_enclosing_xy_bb: find a bounding box in x-y coordinates, say
 * [bb0x,bb1x] X [bb0y,bb1y]
 * that encloses a bounding box in lat-lon coordinates given by
 * [lat0,lat1] X [lon0, lon1].  
 * The lat-lon coordinates are on a sphere at tilt angle beta given 
 * by (sinB, cosB).  The lon coordinates given as input do not have 
 * to be in (-pi,pi).  This is because they arise from adding an 
 * angular displacement to another pair of lon coordinates, and either
 * or both results may land outside (-pi,pi).  Because we want to preserve
 * the ordering (lon0 < lon1), it is important to not wrap them.  (And
 * there is no compelling reason to do so.)
 * 
 * There may be an analytic way to do this.  This code uses that we can
 * easily traverse the edges of the lat-lon patch, and that the x-y 
 * bounding box will need to be only as big as area enclosed by the 
 * boundary.  It therefore divides the boundary into four sides, and 
 * sets up a loop to march along these sides in "nstep" steps.  At each
 * step, the four points along the four boundaries are computed, and
 * their (x,y,z) coords are found from the (lat,lon).  The overall span
 * of x and y is retained as the bounding box.
 * 
 * There are two wrinkles, both related to edge effects.  
 * 
 * First, the traversal is discrete and may be interrupted by the limb.
 * If it is, we may not go out far enough onto the limb, in (lat,lon)
 * coordinates, to encompass the final on-boundary pixel.  Hence, 
 * we indicate by "expand" whether the disk boundary was crossed.  If
 * it is, the entire boundary is expanded by one pixel.  (Discretization
 * can cause other problems, but they are more of a second-order nature 
 * than this one -- e.g., a curved boundary may be traversed in steps,
 * but the fact that it pokes slightly above a pixel border not detected,
 * because it happens between steps.)
 * 
 * Second, wrapping issues may make the x/y extrema not occur on the 
 * boundary.  Take beta = 0 for simplicity.  If a square patch at disk 
 * center is rotated to the limb, it may extend partway around the limb 
 * at the equator.
 * 
 * In this case, both traversed (longitudinal) boundaries will 
 * curve back around the limb at values of x strictly less than
 * unity.  In particular, the boundary does not include the point
 * where the equator crosses behind the limb, but the patch does.
 * This point has x=+/-1 and is thus the true extreme of the patch 
 * in the x direction.  
 * 
 * What has happened?  The extrema of x and y can occur either at 
 * the boundary of the patch (which is the "expected case," and will 
 * be found in the loop), or at the unconstrained extrema: 
 *   (x,y,z) = (+/-1,    0, 0)   (for x)
 *   (x,y,z) = (   0, +/-1, 0)   (for y)
 * These unconstrained extrema may be in the patch, but not on the boundary,
 * so we have to check them.  (There are no other special cases.)
 * 
 * To take care of these cases, we explicitly compute the (lat,lon) coordinates 
 * of these four unconstrained extrema, checking if they fall into the lat-lon 
 * bounding box.  If they do, then the lat/lon bounding box is adjusted
 * accordingly.
 */

// macro updates the 4 BB sides based on a point (px,py,pz)
#define UPDATE_BB \
  if (pts) {pts[inx++] = px; pts[inx++] = py; pts[inx++] = pz;}		\
  if (pz >= 0) {							\
    if (bb0x > px) bb0x = px;						\
    if (bb1x < px) bb1x = px;						\
    if (bb0y > py) bb0y = py;						\
    if (bb1y < py) bb1y = py;						\
  } else {								\
    expand = 1;								\
  }


static
void
find_enclosing_xy_bb(int *P_bb0x,     // BB (x,y) boundary
		     int *P_bb0y, 
		     int *P_bb1x, 
		     int *P_bb1y,
		     double lat0,     // BB (lat,lon) boundary...
		     double lat1,     // lat in -pi/2 .. pi/2 
		     double lon0,     // lon, in radians, unrestricted
		     double lon1, 
		     int maxx,        // image domain
		     int maxy, 
		     double x0,       // x center, in C coords, origin at 0 
		     double y0,       // y center, in C coords, origin at 0 
		     double R,        // radius, in pixels 
		     double B,        // tilt angle, radians 
		     double P)        // twist angle, radians 
{
  // counters and dimensions
  int n;                             // count position on enclosing boundary
  int expand;                        // expand bb by 1 if it wraps to the far side
  double degree_per_pixel;
  int npixel;
  double d_lat;                      // step size along boundaries
  double d_lon;
  // point parameters
  double px, py, pz;                 // their (x,y,z) versions
  double lat, lon;                   // varying positions along boundaries
  double s_lat, c_lat, s_lon, c_lon; // sin,cos of lat,lon (varying with n)
  double bb0x, bb0y, bb1x, bb1y;     // abbreviate the bb boundaries
  // cache geom
  const double cosB  = cos(B);
  const double sinB  = sin(B);
  const double cosP  = cos(P);
  const double sinP  = sin(P);
  // cache lat/lon bb
  const double s_lat0 = sin(lat0); /* sin, cos of lat0, lon0 */
  const double c_lat0 = cos(lat0);
  const double s_lon0 = sin(lon0);
  const double c_lon0 = cos(lon0);
  const double s_lat1 = sin(lat1); /* sin, cos of lat1, lon1 */
  const double c_lat1 = cos(lat1);
  const double s_lon1 = sin(lon1);
  const double c_lon1 = cos(lon1);
  // allow export of points
  double *pts = NULL; // pointer to triples: (x, y, z)
  int inx;
  int npts;

  // ensure there is at least one test point per image pixel along each edge
  // there are R pixels per radian at disk center (2*pi*R pixels / 2*pi radians)
  // so, number of pixels is (pixels/radian) * radians = R * radians
  npixel = ceil(R * max(lat1-lat0, lon1-lon0));
  if (npixel > max(maxx, maxy)) npixel = max(maxx, maxy);
  if (npixel < 10) npixel = 10;
  d_lat = (lat1 - lat0) / npixel;
  d_lon = (lon1 - lon0) / npixel;
  npts = (npixel + 1) * 4; // npixel+1 points X 4 sides
  pts = mxCalloc(npts*3, sizeof(double)); // each point has 3 coords
  // assume we did not cross onto the back side
  expand = 0; 
  // right up until the end of this function, bb is on the unit sphere
  bb0x = bb0y = 1.0; bb1x = bb1y = -1.0; // min <- highval; max <- lowval
  /* move points 1,2,3,4 simultaneously over all four boundaries */
  for (inx=n=0, lat=lat0, lon=lon0; n<=npixel; n++, lat+=d_lat, lon+=d_lon) {
    /* sine, cosine of lat and lon markers (used by all points) */
    s_lat = sin(lat); c_lat = cos(lat);
    s_lon = sin(lon); c_lon = cos(lon);
    /* from lat-lon to xyz: point1 = (lat0, lon) */
    pointmap(&px, &py, &pz, s_lat0, c_lat0, s_lon, c_lon, sinB, cosB, sinP, cosP);
    UPDATE_BB;
    /* from lat-lon to xyz: point2 = (lat1, lon) */
    pointmap(&px, &py, &pz, s_lat1, c_lat1, s_lon, c_lon, sinB, cosB, sinP, cosP);
    UPDATE_BB;
    /* from lat-lon to xyz: point3 = (lat, lon0) */
    pointmap(&px, &py, &pz, s_lat, c_lat, s_lon0, c_lon0, sinB, cosB, sinP, cosP);
    UPDATE_BB;
    /* from lat-lon to xyz: point4 = (lat, lon1) */
    pointmap(&px, &py, &pz, s_lat, c_lat, s_lon1, c_lon1, sinB, cosB, sinP, cosP);
    UPDATE_BB;
  }
  /* Adjust bounding box to allow for disk-edge (z=0) boundary. 
   * Note that the computed lon of these key points is in -pi..pi, so it 
   * must be adjusted to fall in to the [lon0,lon1] interval, which may 
   * lie outside -pi..pi.  */
  /* (1,0,0) */
  pointunmap(&lat, &lon, 1.0, 0.0, 0.0, sinB, cosB, sinP, cosP); 
  while (lon < lon0) lon += 2*M_PI;  /* wrap lon to best fit in [lon0,lon1] */
  while (lon > lon1) lon -= 2*M_PI;
  if (lat0 <= lat && lat <= lat1 && lon0 <= lon && lon <= lon1)
    bb1x = 1.0;
  /* (-1,0,0) */
  pointunmap(&lat, &lon, -1.0, 0.0, 0.0, sinB, cosB, sinP, cosP); 
  while (lon < lon0) lon += 2*M_PI;  /* wrap lon to best fit in [lon0,lon1] */
  while (lon > lon1) lon -= 2*M_PI;
  if (lat0 <= lat && lat <= lat1 && lon0 <= lon && lon <= lon1)
    bb0x = -1.0;
  /* (0,1,0) */
  pointunmap(&lat, &lon, 0.0, 1.0, 0.0, sinB, cosB, sinP, cosP); 
  while (lon < lon0) lon += 2*M_PI;  /* wrap lon to best fit in [lon0,lon1] */
  while (lon > lon1) lon -= 2*M_PI;
  if (lat0 <= lat && lat <= lat1 && lon0 <= lon && lon <= lon1)
    bb1y = 1.0;
  /* (0,-1,0) */
  pointunmap(&lat, &lon, 0.0, -1.0, 0.0, sinB, cosB, sinP, cosP);
  while (lon < lon0) lon += 2*M_PI;  /* wrap lon to best fit in [lon0,lon1] */
  while (lon > lon1) lon -= 2*M_PI;
  if (lat0 <= lat && lat <= lat1 && lon0 <= lon && lon <= lon1)
    bb0y = -1.0;

  /* define the BB corners in full-disk (x,y) coords... */
  bb0x = floor(bb0x * R + x0) - expand;
  bb0y = floor(bb0y * R + y0) - expand;
  bb1x =  ceil(bb1x * R + x0) + expand;
  bb1y =  ceil(bb1y * R + y0) + expand;
  /* ...and ensure the BB corners are on-image */
  if (bb0x < 0)     bb0x = 0;
  if (bb0y < 0)     bb0y = 0;
  if (bb1x >= maxx) bb1x = maxx-1;
  if (bb1y >= maxy) bb1y = maxy-1;
  // plug in output BB (output BB are int's)
  *P_bb0x = (int) bb0x;
  *P_bb0y = (int) bb0y;
  *P_bb1x = (int) bb1x;
  *P_bb1y = (int) bb1y;

  if (pts) {
    mxt_put_matrix("bdry", -1, pts, 3, npts);
    mxFree(pts);
  }

}

/*
 * Given image a, find the lat-lon bounding box of all its non-zero, non-nan pixels.
 * 
 * We consider only the pixels in a in the rectangle [bb0m,bb1m]x[bb0n,bb1n].
 * We use a workspace "b" which is image-sized, and assumed zero-filled.
 */
static
void
find_lat_lon_bb(double *p_lat0,  // low side of (lat,lon) boundary...
		double *p_lon0,  // lon, in radians, unrestricted 
		double *p_lat1,  // lat in -pi/2 .. pi/2 
		double *p_lon1, 
		int bb0x,        // bottom corner of BB to search
		int bb0y, 
		int bb1x,        // top corner of BB
		int bb1y,
		int maxx,        // input size (# points)
		int maxy, 
		int strx,        // stride of a and b along x, units of doubles
		int stry,        // stride along y
		double *a,       // input is maxx X maxy 
		char *b,         // workspace is same size, already zero-filled 
		// geom
		double x0,       // x center, in C coords, origin at 0 
		double y0,       // y center, in C coords, origin at 0 
		double R,        // radius, in pixels 
		double B,        // tilt angle, radians 
		double P)        // twist angle, radians 
{
  int x, y;               // image coordinates 
  int dx, dy;             // coordinates for neighbors 
  int off1, off2;         // array offsets
  double p1x, p1y, p1z;   // point P1 coords in 3D 
  double p2x, p2y, p2z;   // point P2 coords in 3D 
  double temp;            // workspace slot 
  // cache geom
  const double cosB  = cos(B);
  const double sinB  = sin(B);
  const double cosP  = cos(P);
  const double sinP  = sin(P);
  double lat, lon;        // current latitude and longitude 
  double lat0, lon0, lat1, lon1;     // lat-lon BB while accumulating
  struct timeval tv1, tv2;     // crude timings

#if 0
  double *zs   = mxCalloc(maxx*maxy, sizeof(double));
  double *lats = mxCalloc(maxx*maxy, sizeof(double));
  double *lons = mxCalloc(maxx*maxy, sizeof(double));
#endif

  gettimeofday(&tv1, NULL);
  /* Loop over source image pixels, finding a (lat,lon) BB */
  lon0 = 10.0; lon1 = -10.0;   /* will be reset on first iter */
  lat0 = R+1;  lat1 = -(R+1);  /* will be reset on first iter */
  for (x = bb0x; x <= bb1x; x++)
    for (y = bb0y; y <= bb1y; y++) {
      off1 = x*strx + y*stry;
      /* skip zero or NaN (unknown or off-disk) pixels */
      if (a[off1] == 0 || isnan(a[off1])) continue;
      /* ensure (x,y) is itself on-disk */
      p1x = x - x0;
      p1y = y - y0;
      temp = (R + p1x) * (R - p1x) - p1y*p1y; // R*R-x*x = (R-x)*(R+x)
      // zs[x*strx + y*stry] = temp;
      if (temp < 0) continue; // (x,y) is off-disk: skip
      /* found a nonzero, on-disk pixel: get its nbrs lat-lon */
      for (dx = x-1; dx <= x+1; dx++)
	for (dy = y-1; dy <= y+1; dy++) {
	  off2 = dx*strx + dy*stry;
	  if (!ISVALID(dx,dy,maxx,maxy) || b[off2]) 
	    continue; 
	  else 
	    b[off2] = 1;
	  /* find original vector coordinates P2 = (px2, py2, pz2) */
	  p2x = dx - x0;
	  p2y = dy - y0;
	  temp = (R + p2x) * (R - p2x) - p2y*p2y; // R*R-x*x = (R-x)*(R+x)
	  /* temp is the residual which goes into the p1z component */
	  if (temp < 0) { 
	    p2z = -sqrt(-temp);  // barely off-disk - send to back side
	    temp = R / sqrt(p2x*p2x + p2y*p2y + p2z*p2z); // need ||P2|| = 1
	    p2x *= temp; p2y *= temp; p2z *= temp;  // rescale
	  } else {
	    p2z = sqrt(temp);   /* totally OK -- on visible side */
	  }
	  /* rotate by p-angle in xy plane (z axis fixed): P1 = rot(P2) */
	  p1x =  cosP * p2x + sinP * p2y;
	  p1y = -sinP * p2x + cosP * p2y;
	  p1z =  p2z;
	  /* rotate by +beta in yz plane (x axis fixed): P2 = rot(P1) */
	  p2x =  p1x;  /* no change to x */
	  p2y =  cosB * p1y + sinB * p1z;
	  p2z = -sinB * p1y + cosB * p1z;
	  /* find (lat,lon) of the point */
	  lon = atan2(p2x, p2z);  // p2=(1,0,0), at limb, has lon=pi/2 
	  lat = p2y; // take the arcsin out of the loop: need range only

	  // lats[off2] = asin(lat/R);
	  // lons[off2] = lon;

	  /* update bounding box */
	  if (lat < lat0) lat0 = lat;
	  if (lat > lat1) lat1 = lat;
	  if (lon < lon0) lon0 = lon;
	  if (lon > lon1) lon1 = lon;
	} /* for dx, dy */
    } /* for x, y */
  /* map latitude range through (monotone) arcsin function */
  lat0 = asin(lat0 / R); 
  lat1 = asin(lat1 / R);
  /* set up output pointers */
  *p_lat0 = lat0;
  *p_lon0 = lon0;
  *p_lat1 = lat1;
  *p_lon1 = lon1;
  gettimeofday(&tv2, NULL);
  int dtval = (((long) tv2.tv_sec) - ((long) tv1.tv_sec)) * 1000000 + 
    (((int) tv2.tv_usec) - ((int) tv1.tv_usec));
  if (verbose)
    mexPrintf("  finishing find_lat_lon_bb, dt = %.1f ms\n", dtval/1000.0);

#if 0
  if (lats) {
    mxt_put_matrix("zs",   -1,   zs, maxx, maxy);
    mxt_put_matrix("lats", -1, lats, maxx, maxy);
    mxt_put_matrix("lons", -1, lons, maxx, maxy);
    mxFree(zs);
    mxFree(lats);
    mxFree(lons);
  }
#endif
}


/* 
 * find_extent: finds an (m,n) bounding box around the location,
 * in the target image, of all nontrivial source image pixels.
 * This works in three steps:
 * 1: find a (lat,lon) bounding box around all nontrivial source
 * pixels.  (Nontrivial == on-disk, non-zero, non-NaN.)  The step
 * is done in this routine.
 * 2: propagate the (lat,lon) bounding box to the target image
 * using the rules for differential rotation.  The target BB is
 * held in (latp,lonp).  This step is done primarily by update_lon,
 * since latp = lat.
 * 3: find a (m,n) bounding box around the (latp,lonp) bounding
 * box.  This step is done in find_enclosing_xy_bb.
 *
 * The differential rotation and the discretization make this
 * process tricky.  Steps 2 and 3 are mostly explained in their
 * subroutines.  
 * As for step 1, the basic principle is to loop over all 
 * source pixels, skipping trivial pixels.  The remainder
 * are mapped to (lat,lon) coordinates.  The max and min values
 * of both are maintained.  The lon that is used here is zero at disk
 * center, so that it wraps around from pi->-pi not at either limb,
 * but at the far back side of the sun.  This is done so that
 * splotches that are near the limb will not have pixels at lon = pi
 * and lon = -pi.  Such values would force the lon range (which must 
 * be held as a simple interval for efficiency and clarity) to
 * be -pi..pi.  This would not be incorrect, just inefficient.
 * 
 * The main refinement has to do with how interpolation is done by 
 * do_rotate around NaN values, particularly at the limb.  If a 
 * target image pixel lands at (say) (500.1,61.1) in the source, 
 * the closest source pixel is at (500,61).  Suppose this pixel 
 * is NaN.  The interpolated value will be chosen using (501,62), 
 * or (500,62), or (501,61), if any or all are non-NaN:
 *
 *       61   62
 *  500  NaN  4
 *  501  NaN  3
 *
 * Thus, from do_rotate's point of view, (500,62) is NOT the "last 
 * available" nontrivial pixel.  Actually, (500,61+epsilon) is,
 * where epsilon is arbitrarily close to zero.  Looking now at
 * the src-> target mapping, this means that every valid source 
 * pixel (x,y) implies we know a valid value at (x+dx,y+dy) for 
 * all (dx,dy) in [-1,1] X [-1,1].
 * 
 * This can be observed in practice.
 *
 * One solution: Every time a nontrivial pixel is found, loop around
 * the 8 neighbors of the pixel, and compute their lat-lon's as well,
 * to add them to the bounding box.  This would imply a lot more work,
 * so we save the "included pixels" into a scratch array b, which is 
 * assumed ZERO at the outset.  So, we don't waste time re-including 
 * the same pixels.
 *
 * The wrinkle is that some of these surrogate pixels will fall off-disk,
 * when (x+dx,y+dy) is farther than R from (n0,m0) -- even though (x,y)
 * was not.  This typically means that the square patch corresponding to 
 * the surrogate pixel falls only partly on the visible side of the disk:
 * the center happens to be off-disk. 
 * 
 * They can't simply be discarded.  An ad hoc solution is to wrap the patch
 * around the disk.  This is done by setting a negative "z" coordinate
 * (which will have a small value relative to R).  In this case, it is
 * vital that its coordinates in 3D have the right norm, i.e. the
 * "wrapped" center must fall on the sphere.  (This is obvious.)
 * 
 * The simplest test cases show the value of this approach.  Take 
 * beta = 0 and an active region partly intersecting one limb.  Rotate
 * it slightly towards disk center.  Without this approach, the lon
 * part of the bounding box will not go up to pi/2 because no pixel
 * center happens to fall right on the disk edge.  With it, the edge
 * pixels that are only partly visible are wrapped back so their 
 * centers are on the back side, giving a lon > pi/2.  The bounding
 * box will then be wide enough to contain all valid pixels.
 * 
 */
static
void 
find_extent(int *bb0x,    // bottom corner of BB (in/out)
	    int *bb0y, 
	    int *bb1x,    // top corner of BB (in/out)
	    int *bb1y,
	    int maxx,     // input size (# points)
	    int maxy, 
	    int strx,     // stride of a and b along x, units of doubles
	    int stry,     // stride along y
	    double *a,    // input
	    char *b,      // workspace arrives zero-filled 
	    // geom1
	    double x01,   // x center, C coords, origin at 0 
	    double y01,   // y center, C coords, origin at 0 
	    double R1,    // radius, in pixels 
	    double B1,    // tilt angle, radians 
	    double P1,    // twist angle, radians 
	    // geom2
	    double x02,   // x center, C coords, origin at 0 
	    double y02,   // y center, C coords, origin at 0 
	    double R2,    // radius, in pixels 
	    double B2,    // tilt angle, radians 
	    double P2,    // twist angle, radians 
	    // velocity coeffs
	    double k0,    // order-0 coefficient, radians 
	    double k1,    // order-1 coefficient, radians 
	    double k2)    // order-2 coefficient, radians 

{
  double lat0,  lon0,  lat1,  lon1;    // lat-lon BB at start time 
  double lat0p, lon0p, lat1p, lon1p;   // lat-lon BB at end time 

#ifdef DEBUG
  printf("FE1: mnBB = (%d,%d) (%d,%d)\n", *bb0x, *bb0y, *bb1x, *bb1y);
#endif
  /* Step 1: Find a (lat,lon) BB within the source image `a' */
  find_lat_lon_bb(&lat0, &lon0, &lat1, &lon1,
		  *bb0x, *bb0y, *bb1x, *bb1y,
		  maxx, maxy, strx, stry,
		  a, b, 
		  x01, y01, R1, B1, P1);
#ifdef DEBUG
  printf("FE2: llBB = (%f,%f) (%f,%f)\n", 
	 lat0*180/M_PI, lon0*180/M_PI, lat1*180/M_PI, lon1*180/M_PI);
#endif
  /* no active pixels were found: empty BB: eliminate the boundary case */
  if (lat0 > lat1 || lon0 > lon1) {
    *bb0x = *bb0y = *bb1x = *bb1y = 0;
    return;
  }

  /* Step 2: Convert source lat-lon BB to a target lat-lon BB containing it */
  /* step 2a: latitude restrictions do not change */
  lat0p = lat0;
  lat1p = lat1;
  /* step 2b: find longitude restrictions (more tricky) */
  update_lon(&lon0p, &lon1p, k0, k1, k2, lat0, lat1, lon0, lon1);
#ifdef DEBUG
  printf("FE3: llBB = (%f,%f) (%f,%f)\n", 
	 lat0p*180/M_PI, lon0p*180/M_PI, lat1p*180/M_PI, lon1p*180/M_PI);
  printf("     lon0: (%f -> %f); lon1:  (%f -> %f)\n   del_lon: %f, %f  %s\n", 
	 lon0*180/M_PI, lon0p*180/M_PI, 
	 lon1*180/M_PI, lon1p*180/M_PI, 
	 (lon1 - lon0)*180/M_PI, (lon1p - lon0p)*180/M_PI, 
	 ((lon1 - lon0) < (lon1p - lon0p)) ? " " : "!!!");
#endif

  /* Step 3: Identify an enclosing BB in the target in (x,y) coords */
  find_enclosing_xy_bb(bb0x, bb0y, bb1x, bb1y,
		       lat0p, lat1p, lon0p, lon1p, 
		       maxx, maxy, 
		       x02, y02, R2, B2, P2);
#ifdef DEBUG
  printf("FE4: mnBBp = (%d,%d) (%d,%d)\n", *bb0x, *bb0y, *bb1x, *bb1y);
#endif
}

/* gateway routine */

#ifdef StaticP  /* undefined under mex */
StaticP
#endif
void
mexFunction(int nlhs, 
	    mxArray *plhs[], 
	    int nrhs,
	    const mxArray *prhs[])
{
  int m, n;                    // original matlab sizes
  int maxx, maxy;              // sizes, transposed if needed
  int strx, stry;              // strides in images along x and y dims
  int bb0m, bb0n, bb1m, bb1n;  // bounding box coords (original matlab)
  int bb0x, bb0y, bb1x, bb1y;  // bounding box coords (transposed if needed)
  char *mode, *word;           // label for converted mode string and substring
  int mode_full;               // normal = 1, sparse = 0
  int mode_sesw;               // sesw = 1, transposed = 0
  double datamin, datamax;
  char errstr[120];
  double dt;                   // time interval
  double k0, k1, k2;           // rotation coefficients (see below)
  double *src, *targ;          // pointers into "x" for 2d indexing
  char *scratch;               // scratchpad of 0/1 indicators
  double *g;                   // abbreviate head of geometry tuple
  double x01, y01, r1, b1, p1; // geom1
  double x02, y02, r2, b2, p2; // geom2
  struct timeval tv1, tv2;     // crude timings

  gettimeofday(&tv1, NULL);
  /* Hook for introspection (function signature, docstring) */
  if (nrhs < 0) { 
    plhs[0] = mxt_PackSignature((mxt_Signature) (-nrhs), 
				NARGIN_MIN, NARGIN_MAX, 
				NARGOUT_MIN, NARGOUT_MAX, 
				in_names, in_specs, out_names, docstring);
    return;
  }
  /* check number of arguments */
  if ((nrhs < NARGIN_MIN) || (nrhs > NARGIN_MAX))
     mexErrMsgTxt((snprintf(errstr, sizeof(errstr),
			    "%s: Expect %d <= input args <= %d",
			    progname, NARGIN_MIN, NARGIN_MAX), errstr));
  if ((nlhs < NARGOUT_MIN) || (nlhs > NARGOUT_MAX))
      mexErrMsgTxt((snprintf(errstr, sizeof(errstr),
			     "%s: Expect %d <= output args <= %d",
			     progname, NARGOUT_MIN, NARGOUT_MAX), errstr));
  mexargparse(nrhs, prhs, in_names, in_specs, NULL, progname);

  /* get size of input image x, needed below */
  m = (int) mxGetM(prhs[ARG_X]);
  n = (int) mxGetN(prhs[ARG_X]);

  /******************************************************************
   * Read and check arguments in order supplied
   ******************************************************************/

  /*
   * image geometry
   */
  // source image (x) geometry
  g   = mxGetPr(prhs[ARG_GEOM1]); // abbreviate geom1
  x01 = g[0] - 1;         // x0, in C coordinates
  y01 = g[1] - 1;         // y0, in C coordinates
  r1  = g[2];             // disk radius
  b1  = g[3]*M_PI/180.0;  // deg -> rad
  p1  = g[4]*M_PI/180.0;  // deg -> rad
  // target image (y) geometry
  if (mxGetNumberOfElements(prhs[ARG_GEOM2]) > 0)
    g = mxGetPr(prhs[ARG_GEOM2]); // use geom2 instead of geom1
  x02 = g[0] - 1;         // x0, in C coordinates
  y02 = g[1] - 1;         // y0, in C coordinates
  r2  = g[2];             // disk radius
  b2  = g[3]*M_PI/180.0;  // deg -> rad
  p2  = g[4]*M_PI/180.0;  // deg -> rad

  /*
   * Rotation angle coefficients, a function of t
   *
   * omitting units, the basic formula is:
   * given: solar rotation coefficients k, constant, sin(lat)^2, sin(lat)^4
   *        observer's velocity (sidereal), obs_v
   *        time interval, dt
   * compute: rotation angle delta
   *   delta = dt * (k(0) + k(1)*sin(lat)^2 + k(2)*sin(lat)^4 - obs_v)
   *         = dt * ([k(0)-obs_v] + k(1)*sin(lat)^2 + k(2)*sin(lat)^4)
   * We put everything in common units (radians/day) and multiply by dt.  
   * The resulting coeffs need only to be multiplied by the powers of 
   * sin(lat) to get the rotation angle delta in radians.
   */
  dt = mxGetScalar(prhs[ARG_HRS]) / 24.0; /* time, now in days */
  /* note, k0 below has the sidereal velocity component also,
   * all three start in units of degrees/day and are converted, deg/day to rad/day */
  k0 = ROTATE_CONST_K0 * M_PI / 180.0;
  k1 = ROTATE_CONST_K1 * M_PI / 180.0;
  k2 = ROTATE_CONST_K2 * M_PI / 180.0;
  /* multiply through by the time in days to obtain radians */
  k0 *= dt; k1 *= dt; k2 *= dt;

  /* 
   * `mode' input
   * (required)
   */
  if ((mode = mxArrayToString(prhs[ARG_MODE])) == NULL)
    mexErrMsgTxt((snprintf(errstr, sizeof(errstr),
			   "%s: bad mode (non-string?). "
			   "Could not convert mode arg to string.", 
			   progname), errstr));
  /* no default values -- user must specify both explicitly */
  mode_full = mode_sesw = -1; 
  if ((word = extract_mode(mode, &mode_full, &mode_sesw)) != NULL)
    mexErrMsgTxt((snprintf(errstr, sizeof(errstr),
			   "%s: bad word <%s> in mode <%.80s>", 
			   progname, word, /* need a fresh copy of the mode */
			   mxArrayToString(prhs[ARG_MODE])), errstr));
  if (mode_full < 0 || mode_sesw < 0)
    mexErrMsgTxt((snprintf(errstr, sizeof(errstr),
			   "%s: need full/sparse, sesw/sene in mode <%.80s>", 
			   progname, /* need a fresh copy of the mode */
			   mxArrayToString(prhs[ARG_MODE])), errstr));
  mxFree(mode); // done with the mode string
    
  /* 
   * `bb' input
   * (optional)
   */
  if (nrhs <= ARG_BB || mxGetNumberOfElements(prhs[ARG_BB]) == 0) {
    // not supplied or 0 elements is OK, just take full box
    bb0m = 0; bb0n = 0; bb1m = m-1; bb1n = n-1; // C indexing
  } else if (mxGetNumberOfElements(prhs[ARG_BB]) == 4) {
    // source bounding box was given explicitly
    double *bb = mxGetPr(prhs[ARG_BB]); // abbreviation
    bb0m = bb[0];
    bb0n = bb[1];
    bb1m = bb[2];
    bb1n = bb[3];
    if ((bb0m < 1    || bb0m > m) ||
	(bb1m < 1    || bb1m > m) ||
	(bb0n < 1    || bb0n > n) ||
	(bb1n < 1    || bb1n > n) ||
	(bb0m > bb1m || bb0n > bb1n))
      mexErrMsgTxt((snprintf(errstr, sizeof(errstr),
			     "%s: Bounding box `bb' was empty or out-of-range",
			     progname), errstr));
    // convert matlab to C indexing
    bb0m -= 1; bb0n -= 1; bb1m -= 1; bb1n -= 1;
  } else {
    mexErrMsgTxt((snprintf(errstr, sizeof(errstr),
			   "%s: Expect `bb', if nonempty, to be of length 4",
			   progname), errstr));
  }

  /* create output image, which needs to be zero-filled.
   * we do allocation after the argument checking
   */
  if ((plhs[ARG_Y] = mxCreateDoubleMatrix(m, n, mxREAL)) == NULL)
    mexErrMsgTxt((snprintf(errstr, sizeof(errstr),
			   "%s: Failed to allocate space for output array",
			   progname), errstr));

  /*
   * Depending on pixel-order mode, set up strides and bounding boxes in
   * (x,y) coordinates from their (m,n) settings.
   * Note that the (x0,y0) positions, in the geom1 and geom2 inputs, 
   * correspond to x and to y, so they do not need to be swapped.
   */
  if (mode_sesw) {
    // x (E-W axis) varies fastest -- x corresponds to matlab m coordinate
    strx = 1; stry = m; // x varies fastest, x has m points...
    maxx = m; maxy = n; // y has n points
    bb0x = bb0m; bb0y = bb0n;
    bb1x = bb1m; bb1y = bb1n;
  } else {
    // y (N-S axis) varies fastest -- x corresponds to matlab n coordinate
    strx = m; stry = 1; // y varies fastest, y has m points...
    maxx = n; maxy = m; // and x has n points
    bb0x = bb0n; bb0y = bb0m;
    bb1x = bb1n; bb1y = bb1m;
  }

  // convenience for argument passing
  src  = mxGetPr(prhs[ARG_X]);
  targ = mxGetPr(plhs[ARG_Y]);

  /* Depending on sparse/full mode setting, establish bounding box coords 
   * in source image (C conventions) */
  if (!mode_full) {
    // sparse version
    // note, scratchpad must be filled with zeros
    if ((scratch = calloc(m*n, sizeof(char))) == NULL)
      mexErrMsgTxt((snprintf(errstr, sizeof(errstr),
			     "%s: Failed to allocate space for scratchpad matrix",
			     progname), errstr));
    // note, bb* has been set up above as a box within `x'
    find_extent(&bb0x, &bb0y, &bb1x, &bb1y,    // given as input, received as output
		maxx, maxy,                    // size
		strx, stry,                    // strides in units of doubles
		src, scratch,                  // input, and scratchpad
		x01, y01, r1, b1, p1,          // geom1
		x02, y02, r2, b2, p2,          // geom2
		k0, k1, k2);                   // coefficients in radians
    free(scratch);
  }

  /* Rotate the input x to fill in the output y */
  do_rotate(bb0x, bb0y, bb1x, bb1y,        // target image bounding box
	    maxx, maxy,                    // sizes
	    strx, stry,                    // strides in units of doubles
	    src, targ,
	    x01, y01, r1, b1, p1,          // geom1
	    x02, y02, r2, b2, p2,          // geom2
	    k0, k1, k2);                   // coefficients in radians

  /* initialize range of output */
  getrange(prhs[ARG_X], &datamin, &datamax);
  setrange(plhs[ARG_Y], datamin, datamax); 
  gettimeofday(&tv2, NULL);
  int dtval = (((long) tv2.tv_sec) - ((long) tv1.tv_sec)) * 1000000 + 
    (((int) tv2.tv_usec) - ((int) tv1.tv_usec));
  if (verbose)
    mexPrintf("Exiting %s, dt = %.1f ms\n", progname, dtval/1000.0);
}


/* this macro was defined above */
#undef ISVALID


/* Hook for generic tail matter */
#ifdef MEX2C_TAIL_HOOK
#include "mex2c_tail.h"
#endif

