#include "mex.h"  /* must appear first */
#include <math.h>
#include "mexhead.h" /* my mex defines */
#include "Doc/znan_docstring.h"  /* autogenerated from this file */

/******************************************

%znan	zero out NaN's, or set to val
% 
% y=znan(x,val,pattern)
% * Sets y = x, except where pattern = NaN.  In these places, y is
% set to val.  It is equavalent to:
%    y = x; 
%    y(isnan(pattern)) = val;
% * If pattern is not given, it is taken to be x itself, which has
% the effect of zeroing out the NaN's in x.
% 
% Inputs:
%   real x(m,n);
%   opt real val = 0.0;
%   opt real pattern(m,n) = x;
% 
% Outputs:
%   real y(m,n);
% 
% See Also:  isnan
%
******************************************/
/* Updated by -mex2pymex.py-ver1- on Wed Sep 23 16:42:42 2009 */
 
/* constants and globals used for error checking */

#define NARGIN_MIN	1	    /* number of inputs */
#define NARGIN_MAX	3	    /* number of inputs */
#define NARGOUT_MIN	0	    /* number of output args */
#define NARGOUT_MAX	1	    /* number of output args */

#define ARG_X    0  /* input x */
#define ARG_val  1  /* input val */
#define ARG_pat  2  /* pattern */

#define ARG_Y    0  /* output y */

static const char *progname = "znan";
#define PROGNAME znan
static const char *in_specs[NARGIN_MAX] = {
  "RA",
  "RS(1)",
  "RA" };
static const char *in_names[NARGIN_MAX] = {
  "x",
  "val",
  "pattern" };
static const char *out_names[NARGOUT_MAX] = {
  "y" };


/*****************************************************************************/
/*                         Computational routine                             */
/*****************************************************************************/

static
void
znan(double *y, double *x, double val, double *pat, mwSize N)

{
   mwSize i;

   for (i = 0; i < N; i++, x++, y++, pat++) 
     if (isnan(*pat))
       *y = val;
     else
       *y = *x;
}

/*****************************************************************************/
/*                            Gateway routine                                */
/*****************************************************************************/

#ifdef StaticP  /* undefined under mex */
StaticP
#endif
void
mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
  char errstr[1024];
  double lo, hi;

  /* Hook for introspection (function signature, docstring) */
  if (nrhs < 0) { 
    plhs[0] = mxt_PackSignature((mxt_Signature) (-nrhs), 
                               NARGIN_MIN, NARGIN_MAX, 
		      	       NARGOUT_MIN, NARGOUT_MAX, 
                               in_names, in_specs, out_names, docstring);
    return;
  }
  /* argument checking */
  if ((nrhs < NARGIN_MIN) || (nrhs > NARGIN_MAX))
    mexErrMsgTxt((snprintf(errstr, sizeof(errstr),
			   "%s: Expect %d <= input args <= %d",
			   progname, NARGIN_MIN, NARGIN_MAX), errstr));
  if ((nlhs < NARGOUT_MIN) || (nlhs > NARGOUT_MAX))
    mexErrMsgTxt((snprintf(errstr, sizeof(errstr),
			   "%s: Expect %d <= output args <= %d",
			   progname, NARGOUT_MIN, NARGOUT_MAX), errstr));
  mexargparse(nrhs, prhs, in_names, in_specs, NULL, progname);

  /* check size(pat) == size(x) only if pat was supplied */
  if (nrhs > ARG_pat) {
    start_sizechecking();
    sizeinit(prhs[ARG_pat]);
    sizeagree(prhs[ARG_X]); /* size(x) == size(pat) */
    sizecheck_msg(progname, in_names, ARG_pat);
  }

  /* allocate memory for result */
  plhs[ARG_Y] = 
    mxCreateNumericArray(mxGetNumberOfDimensions(prhs[ARG_X]), 
			 mxGetDimensions(prhs[ARG_X]), 
			 mxDOUBLE_CLASS, 
			 mxREAL);
  if (plhs[ARG_Y] == NULL) 
    mexErrMsgTxt((snprintf(errstr, sizeof(errstr),
			 "%s: Could not allocate space for result",
			  progname), errstr));
  getrange(plhs[ARG_X], &lo, &hi);
  if (lo > 0) lo = 0;
  if (hi < 0) hi = 0;
  setrange(plhs[ARG_Y], lo, hi); /* propagate scaling */

  /* call computational routine */
  znan(mxGetPr(plhs[ARG_Y]),  /* output */
       mxGetPr(prhs[ARG_X]),  /* input */
       nrhs > ARG_val ? 
         mxGetScalar(prhs[ARG_val]) : 0.0, /* value, or 0 */
       nrhs > ARG_pat ? 
         mxGetPr(prhs[ARG_pat]) : mxGetPr(prhs[ARG_X]), /* pat, or X */
       mxGetNumberOfElements(prhs[ARG_X])  /* N */
       );
}


/* Hook for generic tail matter */
#ifdef MEX2C_TAIL_HOOK
#include "mex2c_tail.h"
#endif

