
/*
 * This file is generated by a script, do not edit.
 *
 * This documentation string was generated from
 * a C comment block within a mex program
 * by `doc2docstring.py' on Thu Jun 23 18:26:50 2011.
 */
 
static const char docstring[] =
	"rotate: rotates the sun for a given number of hours (new version)\n"
	"\n"
	" y=rotate(x,geom1,geom2,hours,mode,bb);\n"
	" * Given a solar image x with pose given by geom1, rotate it backward\n"
	" in time by hours hours, into the pose given by geom2.  Off-disk and\n"
	" unknown values are indicated by NaN.\n"
	" * The differential rotation coefficients are defined by this routine.\n"
	" The rotation speed depends on latitude, according to:\n"
	"   omega = coefs(1) + coefs(2) * S + coefs(3) * S^2\n"
	" where S = [sin(latitude)]^2, and omega is the apparent\n"
	" angular velocity in degrees/day.  The equator rotates fastest,\n"
	" but this is not assumed in the code.\n"
	" * We use obs_v = 0.9865 deg/day and coefs = [14.6,-2.2,0] deg/day.\n"
	" * The required mode parameter selects two things, sesw or transposed\n"
	" pixel ordering, and also full vs. sparse rotation.  These work\n"
	" as follows.\n"
	" * The normal HMI (and normal MDI) pixel ordering starts in the\n"
	" southeast corner, and the first scan line of pixels runs toward the\n"
	" southwest corner.  This is `sesw' ordering.  The transposed ordering\n"
	" is `sene'; this ordering is what we used for the JPL MDI processing.\n"
	" In particular, the older rotate routine uses the transposed ordering.\n"
	" This is implemented via internal stride parameters.\n"
	" * The regular full-image rotation looks at every pixel in the\n"
	" target image and interpolates a value for each.  Or, a 'sparse'\n"
	" algorithm can be specified when the rotated input x is mostly zero,\n"
	" as for example indicators of active regions.  This method does\n"
	" a pre-scan of x to determine where the nonzero values are, and\n"
	" only computes y in a box bounding the one where x will move to,\n"
	" not over the whole disk.  It thus saves computation depending on\n"
	" the extent of the nonzeros in x (more compact is better).\n"
	" * If the bounding box of nonzeros in x is known, it can be given\n"
	" as the last argument and that region will be used to restrict the\n"
	" pre-scan of x.\n"
	" * When mode contains `sparse', uncomputed values are left as zero\n"
	" outside this box.  Such zero values can be known, on-disk values\n"
	" that happen to be zero, or off-disk value, or values that would be\n"
	" unknown.  In short, no distinction is made between 0 and NaN as\n"
	" opposed to when mode contains `full'.  But in particular, all\n"
	" non-zero, non-NaN values will match up.\n"
	"\n"
	" Inputs:\n"
	"   real x(m,n);\n"
	"   real geom1(5);              -- [center_x center_y r_sun beta p0]\n"
	"   opt real geom2(5) = geom1;  -- (empty defaults to above)\n"
	"   real hours;\n"
	"   char mode = 'full,sesw'     -- required, in: {full,sparse}x{sesw,sene}\n"
	"   opt int bb = [1 1 m n]      -- matlab coordinates\n"
	"\n"
	" Outputs:\n"
	"   real y(m,n);\n"
	"\n"
	" See also:\n"
	"\n"
	" implemented as a mex file\n"
	" turmon rewrote (again) Sept 2010\n"
	"";

/* End of generated file */

