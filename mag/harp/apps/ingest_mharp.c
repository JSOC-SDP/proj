/*
 *  ingest_mharp.c
 *
 * Purpose:
 *  Ingest HARPs that are described in files underneath a
 *  given root directory.  The HARPs ingested are listed by 
 *  number in a set of files ("lists" argument).  Their metadata,
 *  including lat/lon bounding boxes, some space weather keywords,
 *  and bitmap outlines, are present in files and directories 
 *  underneath "root", in locations marked by the harp number 
 *  appearing in the list files.
 *  This set of files is generated by a Matlab tracker, which 
 *  is typically run by a shell script before running this
 *  ingestor.  
 *  There is also a higher-level coordination script which 
 *  stages data, runs the tracker, this ingestor, and other 
 *  programs needed for complete processing.
 *  Thus, you should not generally need to run this ingestor
 *  manually.
 * 
 * Input File Structure:
 *  A directory structure begining at the supplied "root"
 *  ("root" typically ends in Tracks/jsoc), containing:
 *    -- text file(s), named in the "lists" argument to
 *       this routine, containing HARP ID numbers.
 *  For each HARP ID HHHHHH, a directory root/track-HHHHHH, 
 *  containing:
 *    -- a coordinate-frame file with image geometry
 *    -- a statistics summary file containing region statistics
 *  Each of these two files contains one line per appearance of
 *  the HARP (each T_REC).
 *  The same directory also contains:
 *    -- a series of region-mask FITS files, with bitmap masks 
 *       for the on-region pixels, one file for each HARP 
 *       appearance.
 *
 * Output:
 *  The HARP IDs (HHHHHH) named in each of the files given
 *  in "lists" are ingested into JSOC.  For each HARP, this 
 *  includes all appearances (each T_REC), plus a given 
 *  temporal padding (tpad, in units of images)
 *  before/after the HARP.  For NRT processing, you can 
 *  use the trec argument to only ingest a given number of 
 *  the most recent records (use the default of zero to ingest
 *  all available records).
 *
 * Arguments:
 *  root       -- Input file directory, typ. ends in Track/jsoc
 *  lists [track-new.txt] -- files in "root" listing HARP numbers
 *  match [0]  -- +1/-1 to dump match-info to "root", -1 to exit after dump
 *  out        -- Output HARP data series
 *  mag [hmi.M_720s] -- Input magnetogram data series, alter for NRT
 *  mask       -- Input mask data series, e.g. hmi.Marmask_720s
 *  trec [0]   -- Number of T_RECs to ingest (0=all, 1=latest)
 *  tpad [120] -- Temporal padding (in images, >=0, 120=1 day)
 *  verb [1]   -- Verbosity: 0=errors only; 1, 2, 3 = more
 *
 * Usage:
 *  For monthly processing, only the finalized new tracks are
 *  to be ingested, because others are still subject to change.
 *  The default temporal padding of 120 (images) is standard:
 *  ingest_mharp root=/tmp22/tracking/2011/Tracks/jsoc   \
 *               out=hmi.mharp_720s                      \
 *		 lists=track-new.txt                     \
 *               mask=hmi.Marmask_720s
 *
 *  For NRT processing, both new and pending tracks are ingested,
 *  but only the most recent record should be used.  Also, no 
 *  temporal padding should be used:
 *  ingest_mharp root=/tmp22/tracking/2011-nrt/Tracks/jsoc \
 *               out=hmi.mharp_720s_nrt                    \
 *		 lists=track-new.txt,track-pending.txt     \
 *               mag=hmi.M_720s_nrt                        \
 *               mask=hmi.Marmask_720s_nrt                 \
 *               trec=1 tpad=0
 *
 *  Based on M. Turmon's tracking algorithm and ingest_dsds_a.c
 *
 *  Written by X. Sun, M. Turmon
 *
 *	History:
 *	v0.0	Feb 08 2011
 *	v0.1	Feb 26 2011
 *	v0.2	Apr 17 2011
 *	v0.5	Jun 28 2011
 *      v0.6    Aug 2011
 *      v0.7    Oct 2011
 *
 *  Notes:
 *  -- In general, search for FIXME and TODO for loose ends
 *  
 *  -- v0.0
 *     patch-stats.txt not imported
 *     patch-status.txt not modified
 *  -- v0.1
 *     Changed fits reader
 *     Added file parser
 *  -- v0.2
 *     Put all data into the frame structure
 *  -- v0.5
 *     Updated SW keywords and other keywords
 *     Major restructuring:
 *     Compiling a master matrix first, with HARPNUM and T_REC as indices
 *     Ingesting according to T_REC, to minimize I/O of mask series
 *  -- v0.6
 *     fixed crash if no HARPs were present
 *     support for NRT processing: multiple input harp-list files, can specify
 *     no temporal padding and only ingest most recent T_REC
 *     patch for correct bounding-boxes for HARPS that span the equator
 *     more thorough error checking
 *     better logging and status output
 *     cleanups including format and consistent variable naming
 *     documentation and usage
 *  -- v0.7
 *     can match against NOAA ARs in a data series, output match info,
 *     read tracker parameters from root dir
 *
 */


#include "jsoc_main.h"
#include "drms_types.h"
#include <time.h>
#include <math.h>
#include <timeio.h>
#include "fitsio.h"
// lat-lon to image and back
#include "cartography.c"
// patch statistics
#include "roi_stats_mag_defs.h"
// Keyword propagation
#include "propagate_keys.c"


// global to this file: allow any status printf() to use the verbosity status
static int verbflag;

// standard string length
#define STR_MAX 256
// this is one more than the max number of list files in the "lists" argument
#define LIST_MAX 10
// standard file names
// per-run parameter info
#define FN_TRACK_PARAM "track-param.txt"
// per-track coordinate frame info
#define FN_TRACK_FRAME "track-frame.txt"
// per-track space weather keywords
#define FN_TRACK_STATS "track-stats.txt"
// per-track status summary
#define FN_TRACK_STATUS "track-status.txt"
// per-track subdirectory name
#define FN_TRACK_DIR   "track-%06d"
// bitmap outlines, one for each appearance of each track
#define FN_TRACK_FITS  "patch-%06d.fits.gz"
// used for unspecified input arguments
#define kNOT_SPEC	"Not Specified"
// number of pixels in full-disk image
#define NPIX_FULLDISK 4096
// image cadence in seconds -- needs to be a float/double
#define CADENCE 720.0
// below this number of seconds, two records were taken at the same time
#define REC_EPS 10.0
// seconds per day
#define SEC_PER_DAY (24.0*60.0*60.0)

/************************************************************* 
 *
 * Error handling/logging macros
 *
 *************************************************************
 */

// exit with error
//  (standard trick to swallow the semicolon)
//  (ensure nonzero exit even if zero status)
//  (for use *only* in DoIt() routine)
#define DIE(msg) do { \
	fflush(stdout); \
        fprintf(stderr, "%s: FATAL: %s. (status=%d)\n", module_name, msg, status); \
        return(status ? status : 1); \
        } while (0)
// report non-fatal error
//  (standard trick to swallow the semicolon)
#define WARN(msg) do { \
	fflush(stdout); \
        fprintf(stderr, "%s: WARNING: %s. Continuing.\n", module_name, msg); \
	fflush(stderr); \
        } while (0)
// V_printf: facilitate verbflag output
//   if flag is > 0, output is to stdout, if < 0, to stderr
//   if flag is 0, no output is made at all
// The message is printed in the form:
// <module_name>: <first><message>"
// Usage:
// V_printf(VERB > 0, "\t", "Mask(%d) = %d\n", 2048, mask[2048]);
void
V_printf(int flag, char *first, char *format, ...) {
  va_list args;
  extern char *module_name;
  FILE *fp = (flag > 0) ? stdout : stderr;

  va_start(args, format);
  if (flag != 0) {
    // first is a string, even "" -- print the module name too
    // otherwise, omit it
    if (first)
      fprintf(fp, "%s: %s", module_name, first);
    vfprintf(fp, format, args);
    fflush(fp);
  }
  va_end(args);
}


#define RADSINDEG       (M_PI/180.0)
#define RAD2ARCSEC      (648000. / M_PI)

// Macros for WCS transformations.  assume crpix1, crpix2 = CRPIX1, CRPIX2, 
// sina,cosa = sin and cos of CROTA2 resp.
// and crvalx and crvaly are CRVAL1 and CRVAL2, cdelt = CDELT1 == CDELT2, then
// PIX_X and PIX_Y are CCD pixel addresses, WX and WY are arc-sec W and N on the Sun from disk center.
#define PIX_X(wx,wy) ((((wx-crvalx)*cosa + (wy-crvaly)*sina)/cdelt)+crpix1)
#define PIX_Y(wx,wy) ((((wy-crvaly)*cosa - (wx-crvalx)*sina)/cdelt)+crpix2)
#define WX(pix_x,pix_y) (((pix_x-crpix1)*cosa - (pix_y-crpix2)*sina)*cdelt+crvalx)
#define WY(pix_x,pix_y) (((pix_y-crpix2)*cosa + (pix_x-crpix1)*sina)*cdelt+crvaly)

/***********************************************************************
 *
 * Declarations
 *
 ***********************************************************************/

/* 
 * Status of a patch_info_t: initialized to "invalid" upon creation
 */
typedef enum {
  Patch_Invalid = 0,  // uninitialized fields in data structure
  Patch_Normal,       // ordinary, observed image
  Patch_Padding,      // patch is temporal padding: stats not valid, lat/lon BB is
                      // padding occurs at end, and for placeholder ROIs in middle
} patch_status_t;

/*
 * Discrete tag indicating patch type that is read from a file
 *
 * Currently the frame file can have tag = 0, 1, or 2.
 * The tracker internals can have (-1) which is for a placeholder patch,
 * but these patches are not written out by the tracker.  We re-introduce
 * it as Tag_Faint to indicate the patch was too faint to see (even after 
 * trying harder).
 */
typedef enum {
  // a special value we introduce for patches not read from a file
  //   (typically padding patches)
  Patch_Tag_None   = -99,   // no tag was read for this patch
  // not read from file, but inserted by us while interpolating HARP
  Patch_Tag_Faint  =  -1,   // placeholder patch (between t0 and t1 of HARP)
  // these are as read from files and defined in Matlab
  Patch_Tag_Harder =   0,   // tried harder and matched
  Patch_Tag_Normal =   1,   // ordinary, observed image
  Patch_Tag_Merge  =   2,   // tracks were merged on this frame
} patch_tag_t;

/* 
 * Information for one patch: one HARP at one T_REC
 */
typedef struct {
  patch_status_t valid;            // see enum above
  int num;                         // HARP id number
  patch_tag_t tag;                 // tag: patch category from frame file
  int x0, y0;                      // origin of HARP bitmap in FD image (0-based)
  int fits_nx, fits_ny;		   // HARP bitmap size from frame file
  float lat0, lon0, lat1, lon1;    // bounding box from track-frame.txt
  float omega;	                   // HARP-specific angular rotation (deg/day)
  float stats[RS_num_stats];	   // statistics from track-stats.txt
  char patchName[STR_MAX];	   // bitmap image file path
  char *image;		           // bitmap HARP image itself
  int dims[2];	                   // dimension of above image
  int xmin, xmax, ymin, ymax;	   // calculated bounding box (0-based)
} patch_info_t;

/* 
 * Information for a HARP (spans all patches, that is, all T_REC's)
 */
typedef struct {
  int id;            // HARP numeric id
  int rec0, rec1;    // HARP was tracked in rec0..rec1 (index into trec array)
  int rec0p, rec1p;  // HARP ingested during rec0p..rec1p (with pad)
  int n_missing;     // number of missing-image gaps in rec0..rec1
  int n_patch;       // number of valid patches (Normal+Padding) in rec0..rec1
  int n_patchp;      // number of valid patches (Normal+Padding) in rec0p..rec1p
  int n_match;       // number of matches (0 for none)
  int match[5];      // list of matching MARP's (index into MarpInfo array)
} harp_info_t;

/* 
 * Information for a T_REC (spans all HARPs)
 */
typedef struct {
  TIME t;            // T_REC as a number
  char str[24];      // T_REC as a string
  int nharp;         // number of HARP patches to be ingested at this time
} trec_info_t;

/*
 * Whole-run info
 * (run start/end, tracker parameters)
 */
typedef struct {
  int n_par;              // number of parameters
  char **par_names;       // parameter names
  char **par_vals;        // parameter values
} run_info_t;

/* 
 * Information for a match AR (spans all patches, that is, all T_REC's)
 *
 * (rec0, rec1 not set now)
 */
typedef struct {
  int id;            // NOAA AR numeric id
  int rec0, rec1;    // AR was tracked in rec0..rec1 (index into trec array)
} marp_info_t;

/* 
 * Information for one match-patch: one (NOAA) AR at one T_REC
 */
typedef struct {
  patch_status_t valid;      // enum above
  int id;                    // not needed, but makes life easier
  TIME t;                    // time
  float lat, lon;            // center lat/lon (heliographic)
  float lon_carr;            // carrington longitude
  float lon_wid;             // width in degrees longitude
  float area;	             // AR area microhemispheres
  int spot;                  // spot count
  char class_mag[STR_MAX];    // magnetic classification (Alpha, etc.)
  char class_zur[4];         // zurich classification (3 chars)
} match_info_t;

static const char *tracker_run_info_keys[] = {
  // the most important per-run params
  "TKP_KWID", "kwid",
  "TKP_KLAT", "klat",
  "TKP_TAU",  "tau",
  "TKP_TAU2", "tau2",
  "TKP_ACTV", "active",
  "TKP_FNUM", "final_num",
  "TKP_FTIM", "final_time",
  "TKP_MAPR", "maprate",
  // other per-run parameters
  "TKP_RUNN", "run_name",
  // this is present in params, but not currently in JSD, and is unimportant
  // "TKP_RUNC", "run_number", 
  "TKP_RUNT", "run_time",
  // end sentinel -- required
  NULL, NULL,
};

/***********************************************************************
 *
 * Function signatures
 *
 * load_x:  load x from a file
 * set_x:   set up x from already-loaded data
 *
 ***********************************************************************/

// load tracker params from text file
int load_tracker_params(const char *rootDir, run_info_t *ri);
// load master index array info from file
int load_run_info(const char *rootDir, char **, int *nHarp, int *nRec_all, 
		  TIME *, TIME *);
// get HARP ID portion of harp info array
int load_harp_ids(const char *rootDir, char **, harp_info_t *harpInfo);
// main info parser/loader
int load_all_patch_info(const char *rootDir, 
			patch_info_t *, harp_info_t *, trec_info_t *, 
			int nHarp, int, int);
// Frame file parser, one line per time, return 0 if successful
int load_frame(FILE *fp, patch_info_t *pInfo, TIME *t);
// Stats file parser, one line per time, return 0 if successful
int load_stats(FILE *fp, float *stats);
// mark harp as ingested within disk file
int mark_ingested_harp(const char *, run_info_t *, harp_info_t *);
// print one patch to file
void patch_print(FILE *fp, char *s, trec_info_t *tI, patch_info_t *pI);
// set up fields in trec info array
void set_trec_info(trec_info_t *tRec, TIME t0, int nRec_all, int nRec_pad, double cadence);
// ingest one entire HARP (all records)
int ingest_harp(patch_info_t *, harp_info_t *, trec_info_t *trec1, trec_info_t *trec,
		run_info_t *,
		marp_info_t *,
		DRMS_Record_t *magRec, DRMS_Record_t *maskRec, 
		char *maskImg, char *outQuery);
// ingest one record (T_REC) of one HARP
int ingest_record(patch_info_t *, harp_info_t *, trec_info_t *trec1, trec_info_t *trec, 
		  run_info_t *,
		  marp_info_t *,
		  DRMS_Record_t *magRec, DRMS_Record_t *maskRec, char *outQuery);
// Update bitmap image
int update_bitmap(patch_info_t *pInfo, char *maskImg);
// Keywords
int set_keys_code_info(DRMS_Record_t *);
int set_keys_runinfo(DRMS_Record_t *rec, run_info_t *runInfo);
int set_keys_stats(DRMS_Record_t *rec, DRMS_Record_t *magRec, DRMS_Record_t *maskRec, 
		   patch_info_t *, harp_info_t *, trec_info_t *);
int set_keys_match(DRMS_Record_t *rec, harp_info_t  *hInfo, marp_info_t  *mInfo);
// Find pixel bounding box from lat-lon box
int compute_boundary(patch_info_t *, DRMS_Record_t *);
// Distance of one point from disk center
int distance2center(DRMS_Record_t *rec,
		    double x, double y, double *xDist, double *yDist);
// Ad-hoc FITS reader
int load_fits(char *filename, char **image, int *dims);


/************************************************************* 
 *
 * Timing
 * from T. Larson
 *
 *************************************************************
 */
static double getwalltime(void)
{
  struct timeval tv;
  gettimeofday(&tv, NULL);
  return tv.tv_sec * 1000.0 + tv.tv_usec/1000.0;
}

static double getcputime(double *utime, double *stime)
{
  struct rusage ru;
  getrusage(RUSAGE_SELF, &ru);
  *utime = ru.ru_utime.tv_sec * 1000.0 + ru.ru_utime.tv_usec / 1000.0;
  *stime = ru.ru_stime.tv_sec * 1000.0 + ru.ru_stime.tv_usec / 1000.0;
  return *utime + *stime;
}

/***********************************************************************
 *
 * Match ARs: NOAA AR Loader
 *
 ***********************************************************************/

// this is currently just loading info, not matching
#include "mharp_match.c"

/*
 * export harp/marp match distance matrix to files for inspection
 *
 * if rootdir is NULL, skip the exports
 */
static
int
match_harp_export(const char *rootDir,
		  double *dist,
		  match_info_t *matchInfo,
		  marp_info_t  *marpInfo,
		  int nMarp, 
		  patch_info_t *patchInfo,
		  harp_info_t *harpInfo, 
		  trec_info_t *tRec,
		  int nRec_all,
		  int nRec_min,
		  int nHarp)
{
  const int print_if_invalid = 1;  // print a line even if patch is invalid
  FILE *fp, *fp2;
  const char *base = "Param";      // base for filenames of parameters
  const char *extn = "dat";        // extension for above
  char fn[STR_MAX];
  char root[STR_MAX];
  int rv;                          // return value
  int h, m;
  int i, inx, inx1;

  if (!rootDir)
    return 0; // skip it
  snprintf(root, sizeof(root), "%s/%s", rootDir, "Match");
  if (mkdir(root, 0775) != 0) {
    if (errno == EEXIST) {
      V_printf(-1, "", "Match dump: `%s' already exists, continuing.\n", root);
    } else {
      V_printf(-1, "", "Match dump: could not create `%s'.\n", root);
      perror(root);
      return 1;
    }    
  } else {
    V_printf(verbflag > 0, "", "Match dump: dumping to `%s'.\n", root);
  }
  /*
   *  HARP/MARP summary info
   */ 
  // distance
  snprintf(fn, sizeof(fn), "%s/%s-dist.%s", root, base, extn);
  if ((fp = fopen(fn, "w")) == NULL) return 1;
  for (h = 0; h < nHarp; h++) {
    for (m = 0; m < nMarp; m++)
      fprintf(fp, "%g ", dist[h*nMarp+m]);
    fprintf(fp, "\n");
  }
  fclose(fp);
  // harp info
  snprintf(fn, sizeof(fn), "%s/%s-harp.%s", root, base, extn);
  if ((fp = fopen(fn, "w")) == NULL) return 1;
  for (h = 0; h < nHarp; h++) {
    fprintf(fp, "%d\n", harpInfo[h].id);
  }
  fclose(fp);
  // marp info
  snprintf(fn, sizeof(fn), "%s/%s-marp.%s", root, base, extn);
  if ((fp = fopen(fn, "w")) == NULL) return 1;
  for (m = 0; m < nMarp; m++) {
    fprintf(fp, "%d\n", marpInfo[m].id);
  }
  fclose(fp);
  // match-patch info
  snprintf(fn, sizeof(fn), "%s/%s-match.%s", root, base, extn);
  if ((fp = fopen(fn, "w")) == NULL) return 1;
  for (m = 0; m < nMarp; m++) {
    for (i = 0; i < nRec_all; i++) {
      inx = nRec_all * m + i; // offset into match-patch array (marp #m, time #i)
      if (print_if_invalid || matchInfo[inx].valid == Patch_Normal)
	match_ar_print(fp, "", matchInfo+inx);
    }
  }
  fclose(fp);
  // patch info
  snprintf(fn, sizeof(fn), "%s/%s-patch.%s", root, base, extn);
  if ((fp = fopen(fn, "w")) == NULL) return 1;
  for (h = 0; h < nHarp; h++) {
    for (i = 0; i < nRec_all; i++) {
      inx = nRec_all * h + i; // offset into patchInfo array (harp #h, time #i)
      if (print_if_invalid || patchInfo[inx].valid == Patch_Normal)
	patch_print(fp, "", tRec+i, patchInfo+inx);
    }
  }
  /*
   *  Synoptic map info
   */ 
  // ar rotation rate in deg/sec -- crude
  double degsec = 360.0/(27*3600*24); // 360 degrees in 27 days
  double t0 = tRec[0].t; // time of origin
  double d_lon;
  const int Harp_smpl = 1;  // keep at 1 to always get singletons
  const int Marp_smpl = 10; // once per 2 hours

  // overall list, for harps and marps
  snprintf(fn, sizeof(fn), "%s/Patch-list.csv", root);
  if ((fp2 = fopen(fn, "w")) == NULL) return 1;
  // HARPs
  for (h = 0; h < nHarp; h++) {
    // don't export to synoptic map if too short
    // check: length=1  =>  rec1-rec0+1 = 1  => if() succeeds for nRec_min = 2
    if ((harpInfo[h].rec1 - harpInfo[h].rec0 + 1) < nRec_min)
      continue;
    snprintf(fn, sizeof(fn), "%s/harp-%06d.csv", root, harpInfo[h].id);
    if ((fp = fopen(fn, "w")) == NULL) return 1;
    for (inx1 = -1, i = 0; i < nRec_all; i += Harp_smpl) {
      inx = nRec_all * h + i; // offset into patchInfo array (harp #h, time #i)
      if (patchInfo[inx].valid == Patch_Normal) {
	inx1 = inx; // >= 0
	d_lon = (tRec[i].t - t0) * degsec; // longitude offset at current tRec
	fprintf(fp, "%.2f,%.2f,%.16s\n",  // YYYY.MM.DD_HH:MM, strip :00_TAI
		//	Mlat = matchInfo[Minx].lat;
		//	Mlon = matchInfo[Minx].lon;
		patchInfo[inx].stats[RS_ar_area_lat], 
		patchInfo[inx].stats[RS_ar_area_lon] - d_lon, 
		tRec[i].str);
      }
    }
    fclose(fp);
    // record HARP only if present
    if (inx1 >= 0) {
      double lat_wid = patchInfo[inx1].lat1 - patchInfo[inx1].lat0;
      double lon_wid = patchInfo[inx1].lon1 - patchInfo[inx1].lon0;
      fprintf(fp2, "%06d,%s,%.2f,%.2f\n", harpInfo[h].id, "harp", lat_wid, lon_wid);
    }
  }
  // MARPs
  for (h = 0; h < nMarp; h++) {
    snprintf(fn, sizeof(fn), "%s/marp-%06d.csv", root, marpInfo[h].id);
    if ((fp = fopen(fn, "w")) == NULL) return 1;
    for (inx1 = -1, i = 0; i < nRec_all; i += Marp_smpl) {
      inx = nRec_all * h + i; // offset into patchInfo array (marp #h, time #i)
      if (matchInfo[inx].valid == Patch_Normal) {
	inx1 = inx; // >= 0
	d_lon = (tRec[i].t - t0) * degsec; // longitude offset at current tRec
	fprintf(fp, "%.2f,%.2f,%.16s\n", // YYYY.MM.DD_HH:MM, strip :00_TAI
		matchInfo[inx].lat, 
		matchInfo[inx].lon - d_lon, 
		tRec[i].str);
      }
    }
    fclose(fp);
    // record MARP only if present
    if (inx1 >= 0) {
      // TODO: put in a guess for lat
      double lat_wid = 0.0;
      double lon_wid = matchInfo[inx1].lon_wid;
      fprintf(fp2, "%06d,%s,%.2f,%.2f\n", marpInfo[h].id, "marp", lat_wid, lon_wid);
    }
  }
  fclose(fp2);

  // DONE
  V_printf(verbflag > 0, "", "Match dump: dump to `%s' complete.\n", root);
  return 0;
}

/*
 * match harps up with marps by computing distance matrix based on overlap
 */
static
int
match_harp_marp(const char *rootDir,         // place for distance output, or NULL
		match_info_t *matchInfo, 
		marp_info_t  *marpInfo,
		int nMarp, 
		patch_info_t *patchInfo, 
		harp_info_t *harpInfo, 
		trec_info_t *tRec,
		int nRec_all, 
		int nRec_min, 
		int nHarp)
{
  int rec;
  int h, m;
  int Hinx, Minx;
  double d1, wt1, ct1;
  double diff, wt;
  double Hlat, Hlon, Mlat, Mlon;
  double *dist;

  // find the 2d overlap matrix
  if ((dist = calloc(nMarp*nHarp, sizeof(*dist))) == NULL) {
    V_printf(-1, "", "Could not allocate %d x %d match-dist matrix\n",
    	     nMarp, nHarp);
    return 1;
  }
  for (h = 0; h < nHarp; h++)
    for (m = 0; m < nMarp; m++) {
      d1 = 0;
      wt1 = 0;
      ct1 = 0;
      // TODO: could just go from rec0 .. rec1
      for (rec = 0; rec < nRec_all; rec++) {
	Hinx = h*nRec_all+rec;
	Minx = m*nRec_all+rec;
	if (patchInfo[Hinx].valid != Patch_Normal)
	  continue;
	ct1++;
	if (matchInfo[Minx].valid != Patch_Normal)
	  continue;
	// measure distance between the two patches
	Hlat = patchInfo[Hinx].stats[RS_ar_area_lat];
	Hlon = patchInfo[Hinx].stats[RS_ar_area_lon];
	Mlat = matchInfo[Minx].lat;
	Mlon = matchInfo[Minx].lon;
	diff = sqrt(1.00 * (Hlat - Mlat)*(Hlat - Mlat) + 
	            0.25 * (Hlon - Mlon)*(Hlon - Mlon)); // weight lon less
	wt = patchInfo[Hinx].stats[RS_rgn_size]; // projected area
	d1  += diff * wt;
	wt1 += wt;
      }	// end for rec
      // NB: no overlap => wt1 == 0 => dist = NaN
      dist[h*nMarp+m] = d1/wt1; // area-weighted distance
    } // end for h,m
  // export distance metric, etc. (rootDir == NULL means don't)
  if (match_harp_export(rootDir, dist, 
			matchInfo, marpInfo, nMarp, 
			patchInfo, harpInfo, tRec, 
			nRec_all, nRec_min, nHarp) != 0) {
    V_printf(-1, "", "Failed to export (fopen problem?), continuing.\n");
  }
  // assign ARs to HARPs to maximize this matrix
  double d_best;
  const double d_best_enough = 5.0;
  int h_best = 0;
  for (m = 0; m < nMarp; m++) {
    // match marp #m -- it is OK if there is no match
    for (d_best = d_best_enough*1e6, h = 0; h < nHarp; h++) {
      // note: NaNs do not satisfy this condition, which is correct
      if (d_best > dist[h*nMarp+m]) {
	d_best = dist[h*nMarp+m];
	h_best = h;
      }
    }
    if (d_best < d_best_enough) {
      // match harp h to marp m
      V_printf(verbflag > 1, "\t", "Matching HARP %d to MARP %d (%.2f)\n",
	       harpInfo[h_best].id, marpInfo[m].id, d_best);
      // don't worry if two harps match the same marp
      harpInfo[h_best].match[harpInfo[h_best].n_match++] = m;
    } else {
      V_printf(verbflag > 1, "\t", "No match for MARP %d (%g)\n",
	       marpInfo[m].id, d_best);
    }
  }
  // (TBD)
  return 0;
}

/***********************************************************************
 *
 * Module input arguments
 *
 ***********************************************************************/

char *module_name = "ingest_mharp";
char *hmi_mharp_version = "1.0";  // used for keywords

ModuleArgs_t module_args[] = {
  {ARG_STRING, "root",  kNOT_SPEC,   "Input file directory"},
  {ARG_STRING, "lists", "track-new.txt",   "File(s) listing HARP numbers (comma-separated)"},
  {ARG_INT,    "match", "0",         "Dump match-AR summary info? (<0 for post-dump exit)"},
  {ARG_STRING, "out",   kNOT_SPEC,   "Output HARP data series"},
  {ARG_STRING, "mag",   "hmi.M_720s","Input magnetogram data series"},
  {ARG_STRING, "mask",  kNOT_SPEC,   "Input mask data series"},
  {ARG_INT,    "trec",  "0",         "Number of T_RECs to ingest (0=all, 1=latest)"},
  {ARG_INT,    "tpad",  "120",       "Temporal padding (in images, >=0, 120=1 day)"},
  {ARG_INT,    "tmin",  "1",         "Minimum T_REC's needed to ingest a patch (1=all)"},
  {ARG_INT,    "verb",  "1",         "Verbosity: 0=errs only; 1, 2 = more"},
  {ARG_END}
};

/*
 * Note on per-HARP ingestion status.  Each valid patch, or single HARP at a single
 * time, has exactly one of these ingestion statuses:
 *    missing -- no magnetogram at that time
 *    skipped -- HARP not long enough, chose not to ingest
 *    error -- not enough info to ingest (no mask), or ingestion failed
 *    ok -- ingested OK
 * The total number of valid patches = missing + skipped + error + ok.
 * So, the code below maintains 5 accumulators for these counts.
 *
 * Similarly, each T_REC has exactly one of these statuses:
 *    missing -- no magnetogram at that time
 *    error -- no mask
 *    ok -- found the mask and the mag OK
 *    
 * The nested loops in the ingestion step below follow this form:
 *
 *   for t in T_RECs:
 *     R_valid += 1; H_valid += t.nharps
 *     if magnetogram(t) is unavailable:
 *       // all HARPs at t fail -- not an error
 *       R_missing += 1; H_missing += t.nharps 
 *       continue
 *     if mask(t) is unavailable:
 *       // all HARPs at t fail -- is an error
 *       R_errs += 1; H_errs += t.nharps 
 *       continue
 *     R_ok += 1
 *     for h in harps(t):
 *       if h is too short:
 *         H_skipped++  // skipped on purpose
 *         continue
 *       if not ingest(patches(h, t)):
 *         H_errs++     // error for harp h at time t
 *       else:
 *         H_ok++       // all OK
 */

int DoIt(void)
{
  // input parameters
  const char *listNamesIn;
  const char *rootDir;
  int matchStatus;    // 0 -> no match output; +1/-1 -> output; -1 for exit after
  char *outQuery, *maskQuery, *magQuery;
  char maskRecQuery[STR_MAX], magRecQuery[STR_MAX];
  // records, segments, arrays
  DRMS_RecordSet_t *inRecSet, *magRecSet, *maskRecSet;
  DRMS_Record_t *inRec, *maskRec, *magRec;
  DRMS_Segment_t *inSeg, *maskSeg;
  DRMS_Array_t *maskData;
  char *maskImg;
  // harp-list files
  int listNum;
  char *listNames[LIST_MAX]; // heads of all list file names, NULL terminated
  char *listBuf;             // buffer pointed in to by above
  // HARP bookkeeping arrays
  patch_info_t *patchInfo = NULL;  // nHarp X nRec_all array of tracks
  harp_info_t *harpInfo = NULL;    // length = nHarp
  trec_info_t *tRec = NULL;        // length = nRec_all
  run_info_t runInfo;              // overall run info (tracker params)
  // matching-region bookkeeping
  int nMarp;                       // number of match-regions (NOAA ARs)
  match_info_t *matchInfo = NULL;  // patch info of above, like patchInfo
  marp_info_t *marpInfo = NULL;    // per-match-region info (like harpInfo)
  // HARP times, counts, etc.
  TIME t0, t1;               // times
  char t0_S[32], t1_S[32];   // time strings
  int nHarp;                 // number of HARPs being ingested
  int nRec;                  // number of T_REC slots in union of *seen* HARPs
  int nRec_pad;              // padding (context) on either *unseen* end of HARP
  int nRec_all;              // total number of T_REC slots = nRec + 2*nRec_pad
  int nRec_eat;              // number of T_REC slots to ingest (eat)
  int nRec_min;              // number of T_REC slots required before ingestion
  int Rec_valid, Rec_ok;     // count T_RECs
  int Rec_err, Rec_miss;     // count errors finding mask/mag at T_REC
  int Harp_ok0,  Harp_ok1;   // count ingested HARPs
  int Harp_err0, Harp_err1;  // count errors ingesting HARPs
  int Harp_miss1;            // HARPs not ingested due to missing mag (expected)
  int Harp_skip1, Harp_skip0;// HARPs not ingested, skipped as too short (expected)
  int Harp_valid0;           // Valid HARPs at current T_REC
  int Harp_valid1;           // Valid HARPs across all T_RECs
  int rec;                   // record counter
  int i;                     // harp counter
  int rv, status, inx;       // misc ints
  // Time measuring -- ugly, but functional
  double wt0, wt;
  double ut0, ut;
  double st0, st;
  double ct0, ct;
	
  // timings
  wt0 = getwalltime();
  ct0 = getcputime(&ut0, &st0);
  
  // Command line parameters
  rootDir = cmdparams_get_str(&cmdparams, "root", NULL);
  if (strcmp(rootDir, kNOT_SPEC) == 0) DIE("Root directory must be specified");
  outQuery = (char *) cmdparams_get_str(&cmdparams, "out", NULL);
  if (strcmp(outQuery, kNOT_SPEC) == 0) DIE("Output HARP series must be specified");
  listNamesIn = cmdparams_get_str(&cmdparams, "lists", NULL);
  if (strcmp(listNamesIn, kNOT_SPEC) == 0) DIE("HARP list file(s) must be specified");
  matchStatus  = cmdparams_get_int(&cmdparams, "match", NULL);
  magQuery  = (char *) cmdparams_get_str(&cmdparams, "mag",  NULL);
  maskQuery = (char *) cmdparams_get_str(&cmdparams, "mask", NULL);
  if (strcmp(maskQuery, kNOT_SPEC) == 0) DIE("mask series must be specified");
  nRec_eat = cmdparams_get_int(&cmdparams, "trec", NULL);
  nRec_pad = cmdparams_get_int(&cmdparams, "tpad", NULL);
  nRec_min = cmdparams_get_int(&cmdparams, "tmin", NULL);
  verbflag = cmdparams_get_int(&cmdparams, "verb", NULL); // an int, not a flag
  // check numbers for sanity
  if (nRec_min <= 0)
    DIE("tmin must be a positive integer");
  if (nRec_eat < 0)
    DIE("trec must be a nonnegative integer");
  if (nRec_pad < 0)
    DIE("tpad must be a nonnegative integer");
  if ((nRec_eat > 0) && (nRec_eat <= nRec_pad))
    DIE("number of trec to ingest (trec) must be larger than padding (tpad)");
  // separate list files into pieces
  listNum = 0;
  listBuf = strdup(listNamesIn); // below, we write \0's into list names, so must dup
  bzero(listNames, sizeof(listNames)); // ensure it's all zero
  for (char **listp = listNames; (*listp = strsep(&listBuf, ",")) != NULL; listNum++)
    if (**listp != '\0')
      if (++listp >= &listNames[LIST_MAX])
	break; // no more room
  if (listNum >= LIST_MAX || listNames[listNum] != NULL)
    DIE("Got too many list files, reduce or recompile");
  V_printf(verbflag > 0, "", "Got %d list file%s\n", listNum, listNum == 1 ? "" : "s");

  /*
   * First pass: scan all tracks to get dimensions of patch info
   */
  if (load_run_info(rootDir, listNames, &nHarp, &nRec, &t0, &t1))
    DIE("Error finding basic run info (bad rootDir, listfile, or format?)");
  if (load_tracker_params(rootDir, &runInfo))
    WARN("Failed to load tracker parameter file.  Some keys will not be set");
  if (nRec == 0) {
    V_printf(1, "", "Got nHarp = 0.  Using nominal time range.  Setting pad = 0.\n");
    nRec_pad = 0;
  }
  nRec_all = nRec + 2*nRec_pad; // number of T_REC slots needed to cover the HARPs
  // progress update
  sprint_time(t0_S, t0, "TAI", 0);
  sprint_time(t1_S, t1, "TAI", 0);
  V_printf(verbflag > 0, "", "nHarp = %d; nRec = %d; nRec_all = %d; pad = %d.\n", 
	   nHarp, nRec, nRec_all, nRec_pad);
  V_printf(verbflag > 0, "", "t0 = %s\n", t0_S); 
  V_printf(verbflag > 0, "", "t1 = %s\n", t1_S); 
  
  /*
   * Second pass: Insert all HARP information into the master arrays
   */
  // Allocate the informational arrays
  patchInfo = calloc(nHarp * nRec_all, sizeof(*patchInfo));
  harpInfo  = calloc(nHarp,            sizeof(*harpInfo));
  tRec      = calloc(        nRec_all, sizeof(*tRec));
  if (!tRec || !harpInfo || !patchInfo)
    DIE("Memory allocation failure");
  // fill in T_REC array
  V_printf(verbflag > 0, "", "Setting T_REC range list\n");
  set_trec_info(tRec, t0, nRec_all, nRec_pad, CADENCE);
  // load HARP ID array from file
  V_printf(verbflag > 0, "", "Getting HARP id numbers\n");
  if (load_harp_ids(rootDir, listNames, harpInfo) != 0)
    DIE("Error creating HARP id list (bad listfile or format?)");
  // fill in the HARP x T_REC master index
  V_printf(verbflag > 0, "", "Getting detailed HARP info\n");
  if (load_all_patch_info(rootDir, patchInfo, harpInfo, tRec, nHarp, nRec_all, nRec_pad))
    DIE("Error fetching HARP info (bad listfiles/format)");
  // elapsed time so far
  wt = getwalltime();
  ct = getcputime(&ut, &st);
  V_printf(1, "", "elapsed time after indexing: %.3f s wall, %.3f s cpu\n",
	   (wt - wt0)*1e-3, (ct - ct0)*1e-3);

  /*
   * Third step: Compute matching ARs
   */
  V_printf(verbflag > 0, "", "Loading match regions\n");
  // load the matching ARs
  if (match_load_resample(nRec_all, tRec, &nMarp, &marpInfo, &matchInfo) != 0) {
    V_printf(-1, "", "Could not load and resample Match-AR metadata.\n");
    DIE("Unable to read MATCH AR information");
  }
  if (nMarp == 0)
    V_printf(1, "", "No match ARs supplied/found, continuing.\n");
  V_printf(verbflag > 0, "", "Matching %d HARPs to %d Match-regions\n", nHarp, nMarp);
  match_harp_marp((matchStatus == 0) ? NULL : rootDir, // NULL -> no output
		  matchInfo, marpInfo, nMarp, 
		  patchInfo, harpInfo, tRec, 
		  nRec_all, nRec_min, nHarp);
  free(matchInfo);  // no longer needed, but marpInfo is
  matchInfo = NULL;
  // elapsed time so far
  wt = getwalltime();
  ct = getcputime(&ut, &st);
  V_printf(1, "", "elapsed time after matching: %.3f s wall, %.3f s cpu\n",
	   (wt - wt0)*1e-3, (ct - ct0)*1e-3);
  // allow exit without ingestion to facilitate match testing
  if (matchStatus < 0) {
    V_printf(-1, "", "Early exit due to given match option (match = %d)\n", matchStatus);
    return DRMS_SUCCESS;
  }

  /* 
   * Fourth step: Ingest into JSOC, with outer loop done across T_REC 
   */
  if (nRec_eat == 0) 
    nRec_eat = nRec_all; // fill in for the shorthand 0
  if (nRec_eat > nRec_all) {
    nRec_eat = nRec_all;  // cap the number to be ingested
    // this is nonfatal, but warn anyway
    WARN("Specified trec to ingest was larger than total trecs + padding; capping it");
  }
  V_printf(verbflag > 0, "", 
	   "Ingesting %d HARPs at %d distinct T_REC's among %d total T_REC's.\n", 
	   nHarp, nRec_eat, nRec_all); 
  // for more on these counts, see the block comment at the top of the function
  Rec_valid = Rec_err = Rec_ok = Rec_miss = 0;
  Harp_valid1 = Harp_ok1 = Harp_err1 = Harp_miss1 = Harp_skip1 = 0;
  // run the T_REC loop up to nRec_all
  for (rec = (nRec_all - nRec_eat); rec < nRec_all; rec++) {
    V_printf(verbflag > 1, "\t", "Ingesting at %s [%d/%d]\n", tRec[rec].str, rec+1, nRec_all);
    Rec_valid++;
    Harp_valid1 += tRec[rec].nharp;  // number of valid HARPs at this time
    // Open mag record
    snprintf(magRecQuery, sizeof(magRecQuery), "%s[%s]", magQuery, tRec[rec].str);
    V_printf(verbflag > 2, "\t\t", "Opening mag %s\n", magRecQuery);
    status = 0;
    magRecSet = drms_open_records(drms_env, magRecQuery, &status);
    if (status != 0 || magRecSet->n == 0) {
      V_printf(-1, "", "Could not open mag %s -- skipping this T_REC.\n", magRecQuery);
      Rec_miss++;
      Harp_miss1 += tRec[rec].nharp; // an "expected" error -- not an ingestion error
      continue;
    }
    magRec = magRecSet->records[0];
    // quality check to identify missing data 
    int quality = drms_getkey_int(magRec, "QUALITY", &status);
    if (status != 0 || (quality & 0x80000000)) {
      V_printf(-1, "", "Missing mag data %s -- skipping this T_REC.\n", magRecQuery);
      Rec_miss++;
      Harp_miss1 += tRec[rec].nharp; // an "expected" error -- not an ingestion error
      continue;
    }
    // Open mask record
    snprintf(maskRecQuery, sizeof(maskRecQuery), "%s[%s]", maskQuery, tRec[rec].str);
    V_printf(verbflag > 2, "\t\t", "Opening mask %s\n", maskRecQuery);
    maskRecSet = drms_open_records(drms_env, maskRecQuery, &status);
    if (status != 0 || maskRecSet->n != 1) {
      V_printf(-1, "", "Could not open mask %s -- skipping this T_REC.\n", 
	       maskRecQuery);
      // this is *not* considered an "expected" error
      Rec_err++;
      Harp_err1 += tRec[rec].nharp;  // number of valid HARPs at this time
      continue;
    }
    maskRec = maskRecSet->records[0];
    maskSeg = drms_segment_lookup(maskRec, "mask");
    maskData = drms_segment_read(maskSeg, DRMS_TYPE_CHAR, &status); // OK for null arg1
    if (status) {
      V_printf(-1, "", "Could not open mask data %s -- skipping this T_REC.\n", 
	       maskRecQuery);
      // this is *not* considered an "expected" error
      Rec_err++;
      Harp_err1 += tRec[rec].nharp;  // number of valid HARPs at this time
      continue;
    }
    maskImg = (char *) maskData->data;

    Rec_ok++; // the T_REC was OK
    Harp_valid0 = Harp_ok0 = Harp_skip0 = Harp_err0 = 0;
    for (i = 0; i < nHarp; i++) {
      inx = i*nRec_all + rec;
      if (patchInfo[inx].valid == Patch_Invalid)
	continue; // HARP i was not at this T_REC
      Harp_valid0++;
      // check: length=1  =>  rec1-rec0+1 = 1  => if() succeeds for nRec_min = 2
      if ((harpInfo[i].rec1 - harpInfo[i].rec0 + 1) < nRec_min) {
	// only print the message for regular patches, not padding patches
        if (patchInfo[inx].valid == Patch_Normal)
	  V_printf(verbflag > 0, "\t", "  Skipping HARP[%d], too short\n", harpInfo[i].id);
        Harp_skip0++; // an "expected" error -- don't count as an ingestion error
        Harp_skip1++;
	continue; // HARP i too short to ingest
      }
      V_printf(verbflag > 2, "\t\t", "  HARP[%d][%s] begin\n", harpInfo[i].id, tRec[rec].str);
      // ingest the HARP at the current time
      rv = ingest_harp(patchInfo+inx, harpInfo+i, tRec+rec, 
		       tRec,     // need *all* time info to set up keys
		       &runInfo, // run info, also for keys
		       marpInfo, // matching ARs
		       magRec, maskRec, maskImg, outQuery);
      if (rv != 0) {
	V_printf(-1, "", "Error ingesting HARP[%d][%s], skipped\n", harpInfo[i].id, tRec[rec].str);
	Harp_err0++;
	Harp_err1++;
	continue;
      }
      V_printf(verbflag > 1, "\t", "  HARP[%d][%s] done\n", harpInfo[i].id, tRec[rec].str);
      Harp_ok0++;
      Harp_ok1++;
    }
    V_printf(verbflag > 0, "\t", "[%d/%d] %s: %d valid = %d OK + %d too short + %d errors\n", 
	     rec+1, nRec_all, tRec[rec].str, Harp_valid0, Harp_ok0, Harp_skip0, Harp_err0);
    drms_free_array(maskData);
    drms_close_records(magRecSet,  DRMS_FREE_RECORD); magRecSet  = NULL;
    drms_close_records(maskRecSet, DRMS_FREE_RECORD); maskRecSet = NULL;
    
  }
  /* 
   * Fifth step: Record ingested HARPs
   */
  // loop over HARPs, marking them as ingested
  for (i = 0; i < nHarp; i++) {
    if (mark_ingested_harp(rootDir, &runInfo, harpInfo+i) != 0)
      V_printf(-1, "", "HARP %d was ingested into JSOC but not noted in status file.\n", 
	       harpInfo[i].id);
  }

  /* 
   * Print summary info
   */
  V_printf(1, "", "Ingestion summary: across T_REC:\n");
  V_printf(1, "", "  Processed %d T_RECs; ingested across NT = %d T_RECs.\n", nRec_all, Rec_valid);
  V_printf(1, "", "  Of NT, found %d T_RECs with all data present.\n", Rec_ok);
  V_printf(1, "", "  Of NT, skipped %d due to missing mags (not an error).\n", Rec_miss);
  V_printf(1, "", "  Of NT, skipped %d due to missing masks (likely an error).\n", Rec_err);
  if ((Rec_ok + Rec_miss) < Rec_valid)
    V_printf(1, "", "  Note: Some mask records (%d) were missing (not due to simple data gap).\n",
             Rec_valid - (Rec_ok + Rec_miss));
  V_printf(1, "", "Ingestion summary: across all HARP appearances (patches):\n");
  V_printf(1, "", "  NH = %d HARP appearances were processed over all T_RECs.\n", Harp_valid1);
  V_printf(1, "", "  Of NH, %d HARP appearances ingested ok.\n", Harp_ok1);
  V_printf(1, "", "  Of NH, %d patches had a missing mag and were skipped.\n", Harp_miss1);
  V_printf(1, "", "  Of NH, %d HARPs skipped as too short.\n", Harp_skip1);
  V_printf(1, "", "  Of NH, %d errors found while ingesting HARPs.\n", Harp_err1);
  if (Harp_err1 > 0)
    V_printf(1, "", "WARNING: %d HARP ingestion errors occurred that were NOT due to missing mags",
             Harp_err1);
  
  // NULLs OK here
  free(marpInfo);
  free(listBuf);
  free(patchInfo);
  free(tRec);
  free(harpInfo);

  // elapsed time
  wt = getwalltime();
  ct = getcputime(&ut, &st);
  V_printf(1, "", "total time used: %.3f s wall, %.3f s cpu\n",
	   (wt - wt0)*1e-3, (ct - ct0)*1e-3);
  V_printf(1, "", "Exiting OK.\n");
  return DRMS_SUCCESS;
} 

// end of main routine


/***********************************************************************
 *
 * Utility routines
 *
 ***********************************************************************/

/* 
 * Fill in T_REC array
 */
static
void
set_trec_info(trec_info_t *tRec, 
	      TIME t0, 
	      int nRec_all, int nRec_pad, 
	      double cadence)
{
  TIME t;
  int rec;

  for (rec = 0; rec < nRec_all; rec++) {
    t = t0 + (rec - nRec_pad) * CADENCE;
    // fill in fields
    tRec[rec].t = t;
    sprint_time(tRec[rec].str, t, "TAI", 0);
    tRec[rec].nharp = 0; // set up later in load_all_patch_info
  }
}


/*
 * Summarize a patch by printing it -- diagnostic aid
 *
 * tI is a single tRec, pI is a single patch
 * s is a prefix string, "" for none
 */
static
void
patch_print(FILE *fp, char *s, trec_info_t *tI, patch_info_t *pI)
{
  const int human_friendly = 0;
  char trec_str[24];

  if (human_friendly) {
    if (pI->valid != Patch_Normal) {
      fprintf(fp, "%sPatch not valid\n", s);
    } else {
      sprint_time(trec_str, tI->t, "TAI", 0);
      fprintf(fp, 
	      "%sID = %d (%s) @ (%.2f,%.2f) A = %.1f\n", 
	      s, pI->num, trec_str, 
	      pI->stats[RS_ar_area_lat],
	      pI->stats[RS_ar_area_lon],
	      pI->stats[RS_rgn_size]);
    }
  } else {
    // machine-readable output format
    // (time is #seconds since epoch, 1977/01/01)
    fprintf(fp, 
	    "%d\t%d\t%.1f\t"
	    "%.2f\t%.2f\t"
	    "%.2f\t%.2f\t"
	    "%.2f\t%.2f\t"
	    "%.1f\n", 
	    pI->num, pI->valid, (double) tI->t, 
	    pI->stats[RS_ar_area_lat],
	    pI->stats[RS_ar_area_lon],
	    pI->lat0, pI->lon0,
	    pI->lat1, pI->lon1,
	    pI->stats[RS_rgn_size]);
  }
}

/*
 * load tracker parameters
 */
int
load_tracker_params(const char *rootDir, run_info_t *ri)
{
  FILE *fp;
  int p, np, llen;
  char fn[STR_MAX];
  char line[STR_MAX];
  char *val, *name_end;

  snprintf(fn, sizeof(fn), "%s/%s", rootDir, FN_TRACK_PARAM);
  if ((fp = fopen(fn, "r")) == NULL) {
    V_printf(-1, "", "Failed to open `%s'.\n", fn);
    return 1;
  }
  // find the number of parameters to be stored
  np = 0;
  while (fgets(line, sizeof(line), fp) != NULL) {
    llen = strlen(line);
    // we must have read all the way to the newline
    if (line[llen-1] != '\n') {
      V_printf(-1, "", "Line: `%.20s ...' in param file `%s' is too long.\n", line, fn);
      return 1;
    }
    if (line[0] == '#' || line[0] == '\n') continue;
    np++;
  }
  ri->n_par = np;
  if (np == 0) {
    fclose(fp);
    return 0;
  }
  // allocate space
  ri->par_names = calloc(np, sizeof(*(ri->par_names)));
  ri->par_vals  = calloc(np, sizeof(*(ri->par_vals )));
  if (ri->par_names == NULL || ri->par_vals == NULL) {
    V_printf(-1, "", "Calloc fail in load_tracker_params for np = %d\n", np);
    fclose(fp);
    return 1;
  }
  // read params
  rewind(fp);
  p = 0;
  while (fgets(line, sizeof(line), fp) != NULL) {
    llen = strlen(line);
    if (line[0] == '#' || line[0] == '\n') continue;
    // we know it's newline terminated, so drop the newline
    line[--llen] = '\0';
    // drop any other trailing whitespace
    while (line[llen-1] == ' ' || line[llen-1] == '\t')
      line[--llen] = '\0';
    // find the :
    val = strchr(line, (int) ':');
    if (val == NULL) {
      V_printf(-1, "", "load_tracker_params: no colon in line `%s' in file `%s'\n", 
	       line, fn);
      fclose(fp);
      return 1;
    }
    // trim trailing whitespace before : (if any)
    for (name_end = val-1; *name_end == ' ' || *name_end == '\t'; name_end--)
      *name_end = '\0';
    *val++ = '\0'; // null the colon, thus terminating *name
    // null any following whitespace
    while (*val == ' ' || *val == '\t')
      *val++ == '\0';
    // copy params
    ri->par_names[p] = strdup(line);
    ri->par_vals [p] = strdup( val);
    p += 1; // next param
  }
  fclose(fp);
  V_printf(verbflag > 0, "", "Got %d tracker params from `%s'\n", np, fn);
  return 0; // OK
}

/* 
 * Fetch master index array summary info, return 0 if successful 
 */
static
int 
load_run_info(const char *rootDir, char **lists, 
	      int *nHarp, 
	      int *nRec, 
	      TIME *p_t0,  // pointer to t0 
	      TIME *p_t1)  // pointer to t1
{
  char *list1;
  char full_list[STR_MAX], currDir[STR_MAX], frameFile[STR_MAX];
  char line[STR_MAX];
  char *endptr;
  FILE *fp, *frameFp;
  int harp_id;       // external HARP ID number
  int harp_count;    // number of HARPs read (good and bad)
  int line_num;      // friendly error messages
  int rv, status;    // error codes
  patch_info_t pInfo;
  TIME t, t0, t1;    // time, and end times

  harp_count = 0;
  t0 = sscan_time("2999.12.31_23:59:28Z");  // earliest time seen
  t1 = sscan_time("-4712.01.01_11:59:28Z"); // latest time seen
  while ((list1 = *lists++) != NULL) {
    // read from list1
    snprintf(full_list, sizeof(full_list), "%s/%s", rootDir, list1);
    fp = fopen(full_list, "r");
    if (!fp) {
      V_printf(-1, "", "Error: Could not open HARP list file %s\n", full_list);
      return 1;
    }
    status = 0; // OK
    while (fgets(line, sizeof(line), fp)) {
      if (*line == '#') continue; // comment line
      harp_id = strtol(line, &endptr, 10);
      // check for errors here
      if (harp_id <= 0 || harp_id > INT_MAX) {
	// 0 is the error code for strtol
	V_printf(-1, "", "Bad HARP number format in %s: %s\n", full_list, line);
	status = 1;
	break;
      } 
      harp_count++; 
      // HARP was OK, now scan for its time range
      // using implicit string concatenation below to construct format
      snprintf(frameFile, sizeof(frameFile), 
	       "%s/" FN_TRACK_DIR "/%s", rootDir, harp_id, FN_TRACK_FRAME);
      // open the frame info for this HARP
      frameFp = fopen(frameFile, "r");
      if (!frameFp) {
	V_printf(-1, "", "Error: frame list file %s not found for HARP %06d (prescan).\n", 
		 frameFile, harp_id);
	status = 1;
	break;
      }
      // read the frame file, just to find the time range
      for (line_num = 1; 
	   (rv = load_frame(frameFp, &pInfo, &t)) == 0; 
	   line_num++) {
	if (t < t0) t0 = t;
	if (t > t1) t1 = t;
      }
      fclose(frameFp);
      // this value signals format error
      if (rv == 1) {
	V_printf(-1, "", "Error: Bad frame line %d in %s.\n", line_num, frameFile);
	status = 1; // push error upward
	break;
      }
    }
    fclose(fp);
    if (status)
      return 1; // Error: fail out after fclose()
  } // end loop over lists

  // No errors: set up outputs
  // put correct nRec, and a sensible time in, even if there were no HARPs
  if (harp_count > 0) {
    float nRec_check = ((t1 - t0) / CADENCE) + 1; // number of records
    *p_t0 = t0;
    *p_t1 = t1;
    *nHarp = harp_count;
    *nRec = (int) nRec_check;
    if (abs(nRec_check - *nRec) > REC_EPS/CADENCE) {
      V_printf(-1, "", "Error: CADENCE (%f) does not divide HARP TREC range (%f).\n", 
	       CADENCE, t1-t0);
      return 1;
    }
  } else {
    *nHarp = 0;
    *nRec = 0;
    *p_t0 = *p_t1 = sscan_time("2011.02.14_00:00:00_TAI");
  }
  // printf("nHarp = %d, nRec = %d, t0 = %f, t1 = %f\n", *nHarp, *nRec, t0, t1);
  return 0;
}


/* 
 * Get HARP ID field in HarpInfo structure, return 0 if successful 
 */
static 
int 
load_harp_ids(const char *rootDir, char **lists, harp_info_t *harpInfo)
{
  char *list1;
  char full_list[STR_MAX];
  char line[STR_MAX];
  char *endptr;
  FILE *fp;
  long harp_id; // external HARP ID number
  int i;        // internal HARP index (starts at 0)
	
  i = 0; // retain across list files
  while ((list1 = *lists++) != NULL) {
    // read list1
    snprintf(full_list, sizeof(full_list), "%s/%s", rootDir, list1);
    fp = fopen(full_list, "r");
    if (!fp) {
      V_printf(-1, "", "Could not open HARP summary file %s\n", full_list);
      return 1;
    }
    while (fgets(line, sizeof(line), fp)) {
      if (*line == '#')	continue; // comment line
      // this error check was already made by getRunInfo
      harp_id = strtol(line, &endptr, 10);
      if (harp_id <= 0 || harp_id > INT_MAX) {
	// 0 is the error code
	V_printf(-1, "", "Bad HARP ID format in %s: %s\n", full_list, line);
	fclose(fp);
	return 1;
      } 
      harpInfo[i++].id = (int) harp_id;
    }
    fclose(fp);
  }
  return 0;
}


/*
 * Loads the patches from a single HARP
 *   Returns nonzero for failure
 */
static
int 
load_harp_patches(int harp_id,
		  char *currDir,
		  char *frameFile,
		  char *statFile,
		  patch_info_t *patchInfo,  // head of patches for this HARP
		  trec_info_t  *tRec,       // head of full tRec array
		  harp_info_t  *harpInfo,   // info for just this HARP
		  int nRec_all, int nRec_pad)
{
  FILE *frameFp, *statFp;
  int rec, rec0, rec1;    // first and last rec#, plus counter
  TIME t, t_rec0, t_rec1; // time for rec0, rec1
  patch_info_t pInfo;     // place for one frame's info
  int rv1, rv2, status;   // return values, error status
  int line_num, nPatch;   // counters

  // open files
  frameFp = fopen(frameFile, "r");
  if (!frameFp) {
    V_printf(-1, "", "Frame list file `%s' not found for HARP %06d (full scan).\n", 
	     frameFile, harp_id);
    return 1;
  }
  statFp = fopen(statFile, "r");
  if (!statFp) {
    fclose(frameFp);
    V_printf(-1, "", "Stat list file `%s' not found for HARP %06d\n", 
	     statFile, harp_id);
    return 1;
  }

  // read files line-by-line in lockstep
  for (status = 0, nPatch = 1, line_num = 1; 
       status == 0 &&
	 (rv1 = load_frame(frameFp, &pInfo, &t)) == 0 &&
	 (rv2 = load_stats(statFp, pInfo.stats)) == 0; 
       nPatch++, line_num++) {
    // generate filename, start from 000001
    // format is embedded using literal string concatenation
    snprintf(pInfo.patchName, sizeof(pInfo.patchName), 
	     "%s/" FN_TRACK_FITS, currDir, nPatch);
    double rec_check = (t - tRec[0].t) / CADENCE;  // should be integral
    rec = (int) rec_check;
    // check for in-range rec
    if (rec < 0 || rec >= nRec_all) {
      V_printf(-1, "", "Error: time at line %d out-of-range\n", line_num);
      status = 1;
      continue; // will error out
    }
    // rec must be an even multiple of cadence
    if (abs(rec - rec_check) > REC_EPS/CADENCE) {
      V_printf(-1, "", "Error: Mismatch between time at line %d, "
	       "initial time, and CADENCE %f\n", line_num, CADENCE);
      status = 1;
      continue; // will error out
    }
    // insert the patch into its place in the master index
    //  (gaps are allowed and will be left as patch_invalid)
    patchInfo[rec] = pInfo;
  }
  fclose(frameFp);
  fclose(statFp);
  // error out: file trouble
  if (rv1 == 1) {
    V_printf(-1, "", "Error: Bad frame line %d in `%s'.\n", line_num, frameFile);
    status = 1;
  } else if (rv2 == 1) {
    V_printf(-1, "", "Error: Bad stats line %d in `%s'.\n", line_num, statFile);
    status = 1;
  } else if (status) {
    V_printf(-1, "", "Error: Bad line %d in `%s'.\n", line_num, frameFile);
  }
  return status;
}

/* 
 * Extrapolate one HARP forward and backward in time, interpolates placeholder ROIs
 *   returns 0 if successful, nonzero if not
 *   (currently, always successful)
 */ 
static
int
extrapolate_harp(patch_info_t *patchInfo,    // head of array this HARP's patches
		 harp_info_t *harpInfo,      // this HARP's info
		 int nRec_all, int nRec_pad)
{
  int rec;                       // counter
  int rec0p = harpInfo->rec0p;   // first rec within pad
  int rec0  = harpInfo->rec0;    // first rec with a real patch
  int rec1  = harpInfo->rec1;    // last such rec
  int rec1p = harpInfo->rec1p;   // last rec within pad
  float omega;            // harp rotation rate

  // printf("\tHarp %d: recs=[%d, %d]\n", harpInfo->id, rec0, rec1);

  // put in lat/lon for placeholder ROIs, which always occur between rec0 and rec1
  for (rec = rec0; rec <= rec1; rec++) {
    // set up patchInfo[rec]
    if (patchInfo[rec].valid == Patch_Invalid) {
      // it will be invalid if it was never initialized
      patchInfo[rec].valid = Patch_Padding;   // placeholder ROI
      patchInfo[rec].tag   = Patch_Tag_Faint; // indicate HARP not observed
      patchInfo[rec].num   = patchInfo[rec0].num;
      patchInfo[rec].lat0  = patchInfo[rec0].lat0;
      patchInfo[rec].lat1  = patchInfo[rec0].lat1;
      patchInfo[rec].lon0  = patchInfo[rec0].lon0 + (rec - rec0)*omega;
      patchInfo[rec].lon1  = patchInfo[rec0].lon1 + (rec - rec0)*omega;
      patchInfo[rec].omega = patchInfo[rec0].omega;
      strcpy(patchInfo[rec].patchName, ""); // i.e., not a real patch
      for (int sn = 0; sn < RS_num_stats; sn++)
	patchInfo[rec].stats[sn] = DRMS_MISSING_FLOAT;
    }
  }
  // extend backward
  omega = patchInfo[rec0].omega / SEC_PER_DAY * CADENCE;
  for (rec = rec0p; rec < rec0; rec++) {
    // set up patchInfo[rec]
    patchInfo[rec].valid = Patch_Padding;  // extrapolated
    patchInfo[rec].tag   = Patch_Tag_None; // no tag
    patchInfo[rec].num   = patchInfo[rec0].num;
    patchInfo[rec].lat0  = patchInfo[rec0].lat0;
    patchInfo[rec].lat1  = patchInfo[rec0].lat1;
    patchInfo[rec].lon0  = patchInfo[rec0].lon0 + (rec - rec0)*omega;
    patchInfo[rec].lon1  = patchInfo[rec0].lon1 + (rec - rec0)*omega;
    patchInfo[rec].omega = patchInfo[rec0].omega;
    strcpy(patchInfo[rec].patchName, ""); // i.e., not a real patch
    for (int sn = 0; sn < RS_num_stats; sn++)
      patchInfo[rec].stats[sn] = DRMS_MISSING_FLOAT;
  }
  // extend forward (count down)
  omega = patchInfo[rec1].omega / SEC_PER_DAY * CADENCE;
  for (rec = rec1p; rec > rec1; rec--) {
    patchInfo[rec].valid = Patch_Padding;  // extrapolated
    patchInfo[rec].tag   = Patch_Tag_None; // no tag
    patchInfo[rec].num   = patchInfo[rec1].num;
    patchInfo[rec].lat0  = patchInfo[rec1].lat0;
    patchInfo[rec].lat1  = patchInfo[rec1].lat1;
    patchInfo[rec].lon0  = patchInfo[rec1].lon0 + (rec - rec1)*omega;
    patchInfo[rec].lon1  = patchInfo[rec1].lon1 + (rec - rec1)*omega;
    patchInfo[rec].omega = patchInfo[rec1].omega;
    strcpy(patchInfo[rec].patchName, "");
    for (int sn = 0; sn < RS_num_stats; sn++)
      patchInfo[rec].stats[sn] = DRMS_MISSING_FLOAT;
  }
  return 0;  // always OK
}


/* 
 * set up one HARP's boundary info
 *   note, HARP id field is already set
 *   returns 0 if successful, nonzero if not
 */ 
static
int
set_harp_info_bdry(patch_info_t *patchInfo, // offset to this HARP's patches
		   harp_info_t *hInfo,      // offset to this HARP
		   int nRec_all, 
		   int nRec_pad)
{
  int rec;                // T_REC counter
  int rec0,  rec1;        // first and last rec# (normal patches)
  int rec0p, rec1p;       // first and last rec# (padding patches)

  // find range of rec numbers, {rec0..rec1} and {rec0p...rec1p}, for this harp
  rec0 = nRec_all - 1;
  rec1 = 0; 
  for (rec = 0; rec < nRec_all; rec++) {
    if (patchInfo[rec].valid == Patch_Normal) {
      if (rec < rec0) rec0 = rec;
      if (rec > rec1) rec1 = rec;
    }
  }
  // the "empty HARP" case will cause trouble later
  if (rec0 > rec1) {
    V_printf(-1, "", "Error: No patches present in this HARP.\n");
    return 1;
  }
  // account for padding at front and end
  rec0p = rec0 - nRec_pad;
  if (rec0p < 0) rec0p = 0;
  rec1p = rec1 + nRec_pad;
  if (rec1p >= nRec_all) rec1p = nRec_all-1;
  // Cannot count missing patches because extrapolation has not been done yet
  V_printf(verbflag > 2, "\t\t", 
	   "HARP %d: recs = {%d..%d} recspad = {%d..%d}\n", 
	   hInfo->id, rec0, rec1, rec0p, rec1p);
  hInfo->rec0  = rec0;
  hInfo->rec1  = rec1;
  hInfo->rec0p = rec0p;
  hInfo->rec1p = rec1p;
  return 0;
}


/* 
 * set up one HARP's missing patch info
 *   note, HARP boundary info is already set
 *   returns 0 if successful, nonzero if not
 */ 
static
int
set_harp_info_miss(patch_info_t *patchInfo, // offset to this HARP's patches
		   harp_info_t *hInfo,      // offset to this HARP
		   int nRec_all, 
		   int nRec_pad)
{
  int rec;                    // T_REC counter
  int rec0p = hInfo->rec0p;   // first rec within pad
  int rec0  = hInfo->rec0;    // first rec with a real patch
  int rec1  = hInfo->rec1;    // last such rec
  int rec1p = hInfo->rec1p;   // last rec within pad
  int n_missing;              // number of missing patches
  int n_patch, n_patchp;      // patch counter

  // count present and missing T_REC's within the range {rec0..rec1}
  for (n_patch = n_missing = 0, rec = rec0; rec <= rec1; rec++) {
    if (patchInfo[rec].valid != Patch_Invalid)
      n_patch++;
    if (patchInfo[rec].valid == Patch_Invalid)
      n_missing++;
  }
  // count all present T_REC's within the range {rec0p..rec1p}
  for (n_patchp = 0, rec = rec0p; rec <= rec1p; rec++)
    if (patchInfo[rec].valid != Patch_Invalid)
      n_patchp++;
  V_printf(verbflag > 2, "\t\t", 
	   "HARP %d: #patches = %d, %d  #missing = %d\n", 
	   hInfo->id, n_patch, n_patchp, n_missing);
  hInfo->n_missing = n_missing;
  hInfo->n_patch   = n_patch;
  hInfo->n_patchp  = n_patchp;
  return 0;
}

/* 
 * Mark a HARP as ingested: returns 0 if OK
 */
static
int 
mark_ingested_harp(const char *rootDir, 
		   run_info_t *runInfo,
		   harp_info_t *hInfo)
{
  char statusFile[STR_MAX];
  FILE *statusFp;
  int harp_id;
  time_t tloc;
  char timestr[32]; // enough for an ISO date
  const char *run_key = "run_name"; // in runInfo, from tracker_params
  char *run_name; // "" if not found in runInfo
  int p;

  harp_id = hInfo->id;
  // ISO date, like: 20120217T102626
  time(&tloc);
  strftime(timestr, sizeof(timestr), "%Y%m%dT%H%M%S", localtime(&tloc));
  // run name: find a parameter p matching the name in run_key
  run_name = "unnamed_run"; // in case it's not found
  for (p = 0; p < runInfo->n_par; p++) {
    if (strcasecmp(run_key, runInfo->par_names[p]) == 0) {
      run_name = runInfo->par_vals[p];
      break;
    }
  }
  // Name of HARP status file
  // using implicit string concatenation below to construct format
  snprintf(statusFile, sizeof(statusFile), 
	   "%s/" FN_TRACK_DIR "/%s", rootDir, harp_id, FN_TRACK_STATUS);
  // append to status info for this HARP
  statusFp = fopen(statusFile, "a");
  if (!statusFp) {
    V_printf(-1, "", 
	     "Warning: unable to append to status file %s for HARP %06d (post-ingest).\n", 
	     statusFile, harp_id);
    return 1; // probably non-fatal
  }
  fprintf(statusFp, "%s\t%s\t%s\n", "ingested", run_name, timestr);
  fclose(statusFp);
  return 0; // OK
}


/* 
 * Most complete routine for loading patch information
 * Runs after we know how many T_REC's and HARPS we have
 *   returns 0 if successful, nonzero if not
 */ 
static
int 
load_all_patch_info(const char *rootDir, 
		    patch_info_t *patchInfo, 
		    harp_info_t  *harpInfo, 
		    trec_info_t  *tRec, 
		    int nHarp, 
		    int nRec_all, int nRec_pad)
{
  // file info
  char currDir[STR_MAX];
  char frameFile[STR_MAX], statFile[STR_MAX];
  // harp and record info
  int i;                  // harp counter
  int harp_id;            // external harp id number
  int rec, rec0, rec1;    // first and last rec#, plus counter
  int inx, inx0, inx1;    // table index for first and last
  TIME t, t_rec0, t_rec1; // time for rec0, rec1
  patch_info_t pInfo;     // place for one frame's info
  int status;             // return values, error status
  
  for (i = 0; i < nHarp; i++) {
    //
    // Read the per-HARP info for the i'th track given to us
    //
    // assemble file names
    harp_id = harpInfo[i].id; // its external ID
    // using string concatenation to insert dirname format
    snprintf(currDir, sizeof(currDir), "%s/" FN_TRACK_DIR, rootDir, harp_id);
    snprintf(frameFile, sizeof(frameFile), "%s/%s", currDir, FN_TRACK_FRAME);
    snprintf(statFile,  sizeof(statFile),  "%s/%s", currDir, FN_TRACK_STATS);
    // Load all patches for this HARP
    status = load_harp_patches(harp_id,
			       currDir, frameFile, statFile,
			       patchInfo + i*nRec_all, // offset to HARP #i
			       tRec,                   // not offset
			       harpInfo + i,           // offset to HARP #i
			       nRec_all, nRec_pad);
    if (status != 0) {
      V_printf(-1, "", "Error: Could not load HARP %d (id = %06d).\n", i, harp_id);
      return status;
    }
    // Put per-harp temporal extent information into harpInfo[i]
    status = set_harp_info_bdry(patchInfo+nRec_all*i, harpInfo+i, nRec_all, nRec_pad);
    if (status != 0) {
      V_printf(-1, "", "Error: Could not find boundaries: HARP %d (id = %06d).\n", 
	       i, harp_id);
      return status;
    }
    // Extrapolate for nRec_pad patches before and after
    // Interpolates padding for placeholder ROIs in the middle of the HARP
    // (always succeeds)
    extrapolate_harp(patchInfo+nRec_all*i,
		     harpInfo+i,
		     nRec_all, nRec_pad);
    // Put per-harp missing-patch information into harpInfo[i]
    // (after extrapolation)
    set_harp_info_miss(patchInfo+nRec_all*i, harpInfo+i, nRec_all, nRec_pad);
  }
  // set up #valid-harps-at-time count
  // this count includes padding patches
  for (rec = 0; rec < nRec_all; rec++) {
    tRec[rec].nharp = 0;
    for (i = 0; i < nHarp; i++) {
      if (patchInfo[i * nRec_all + rec].valid != Patch_Invalid)
	tRec[rec].nharp++;
    }
  }
  // testing
  if (0)
  for (i = 0; i < 1 && i < nHarp; i++)
    for (rec = 0; rec < nRec_all; rec++) {
      if (patchInfo[i * nRec_all + rec].valid) {
	patch_info_t tmp = patchInfo[i * nRec_all + rec];
	if (tmp.valid != Patch_Normal) continue;
	printf("\trec# = %d, x0 = %d, y0 = %d\n", rec, tmp.x0, tmp.y0);
	printf("\ttrack stats: #pix=%.2f, area1=%.2f, area2=%.2f\n", 
	       tmp.stats[0], tmp.stats[1], tmp.stats[2]);
	fflush(stdout);
	break;
      }
    }
  return 0;
}



/* 
 * ingest one harp at a particular T_REC
 * Returns 0 if successful, 1 if not
 * Some aspects of ingestion may fail in minor ways.  This still results
 * in a "success" exit code.  Two examples: failure to insert some keywords,
 * and the HARP rotating off the disk so that nothing is actually ingested.
 */
static
int 
ingest_harp(patch_info_t *pInfo,     // the patch to ingest, function of (HARP,T_REC)
	    harp_info_t  *hInfo,     // info for the HARP
	    trec_info_t  *tRec1,     // info for the T_REC
	    trec_info_t  *tRec,      // info for *all* T_REC's
	    run_info_t   *runInfo,   // info for whole run
	    marp_info_t  *mInfo,     // matching ARs
	    DRMS_Record_t *magRec,   // mag[T_REC]
	    DRMS_Record_t *maskRec,  // mask[T_REC]
	    char *maskImg,           // fulldisk mask at T_REC
	    char *outQuery)          // e.g., hmi.Mharp[H][T_REC]
{
  int rv;

  if (pInfo->valid == Patch_Invalid) return 0; // not an error
  // 1: Read the bitmap mask of the HARP
  if (pInfo->valid == Patch_Normal) {
    // read fits bitmap
    if (load_fits(pInfo->patchName, &(pInfo->image), pInfo->dims) != 0) {
      V_printf(-1, "", "Patch read failed, could not ingest %s.\n", outQuery);
      return 1; // error
    }
    // detect dimension mismatch
    if (pInfo->dims[0] != pInfo->fits_nx || 
	pInfo->dims[1] != pInfo->fits_ny) {
      free(pInfo->image); 
      pInfo->image = NULL;
      V_printf(-1, "", "Patch dims mismatch: fits = (%d,%d) frame = (%d,%d).\n", 
	       pInfo->dims[0], pInfo->dims[1],
	       pInfo->fits_nx, pInfo->fits_ny);
      V_printf(-1, "", "Patch read failed, could not ingest %s.\n", outQuery);
      return 1; // error
    }
  } else {
    // "padding" images will not have a bitmap
    pInfo->image = NULL;
  }

  // 2: Find x/y boundary of HARP at T_REC using lat/lon info
  //    rv = 0 for OK, 1 for all pix on farside, 2 for error
  rv = compute_boundary(pInfo, magRec);
  // handle exceptional cases
  if (rv == 2) {
    // no geometry found => cannot ingest => error
    V_printf(-1, "", "Failed to access geometry keywords in %s\n", outQuery);
    return 1; // error
  } else if (rv == 1) {
    // entire HARP was on farside (should only happen for extrapolated HARPs)
    //   set to in-valid, to ignore the patch (although it's not used in future)
    pInfo->valid = Patch_Invalid;
    return 0; // nothing to ingest, but not an error
  } 

  // 3: Update HARP outline using the full-disk mask
  // (this implies a size change to pInfo->image, which is reallocated)
  if (update_bitmap(pInfo, maskImg) != 0) {
    V_printf(-1, "", "Could not compute full HARP mask at %s\n", outQuery);
    return 1; // error
  }

  // 4: Write the HARP at T_REC
  // Also frees pInfo->image
  //    rv = 0 for success, 1 if some errors, 2 if record not inserted
  rv = ingest_record(pInfo, hInfo, tRec1, tRec, runInfo, 
		     mInfo, magRec, maskRec, outQuery);
  if (rv == 2) {
    V_printf(-1, "", "Failed to insert %s\n", outQuery);
    return 1;  // failure
  } else if (rv == 1) {
    // typically keyword errors, not always worth noting
    V_printf(verbflag > 1, "", "Some nonfatal errors with %s\n", outQuery);
  }
  return 0; // OK
}

/* 
 * Update bitmap image so it is correct size, and contains mask overlay
 * Input: 
 *    inner HARP bitmap image, as read from file, in pInfo->image
 *    full-disk mask image
 *    desired bitmap image bounding box in pInfo->{xmin, xmax, ymin, ymax}
 * Output: 
 *    updates pInfo->image with enlarged version according to bbox
 * 
 * Returns 0 on success, 1 on failure
 */

static 
int
update_bitmap(patch_info_t *pInfo, char *maskImg)
{
  char *patch_map = pInfo->image;  // HARP mask image
  char  patch_val;                 // one value from above
  int nx = pInfo->xmax - pInfo->xmin + 1; // desired HARP dimensions
  int ny = pInfo->ymax - pInfo->ymin + 1;
  int i, j, i0, j0; // counters

  if (pInfo->valid == Patch_Invalid)
    return 0; // not an error
  // compute the new HARP cutout by merging in the mask to the HARP outline
  // note: merging can cause some off-HARP pixels in pInfo->image to be NaN, 
  // which we correct here by using the fulldisk mask image
  // note dims[] is still the old fits file dimensions
  // Old condition:
  // if (pInfo->xmin != pInfo->x0 || 
  //     pInfo->ymin != pInfo->y0 ||
  //     nx != pInfo->dims[0] || 
  //     ny != pInfo->dims[1]) {

  // space for the updated HARP mask image
  pInfo->image = calloc(nx*ny, sizeof(*(pInfo->image)));
  if (pInfo->image == NULL) {
    pInfo->image = patch_map; // may as well keep the old one
    V_printf(-1, "", "Unable to allocate space for new patch bitmap\n");
    return 1;
  }
  // copy maskImg into new cutout first (it is the "background")
  // note: xmin, ymin are 0-based offsets: (0,0) is the top corner
  for (j = 0; j < ny; j++)
    for (i = 0; i < nx; i++)
      pInfo->image[j*nx + i] = maskImg[(j + pInfo->ymin) * NPIX_FULLDISK + 
				       (i + pInfo->xmin)];
  V_printf(verbflag > 2, "\t\t", "(nx,ny) = (%d, %d) -> (%d, %d)\n", 
	   pInfo->dims[0], pInfo->dims[1], nx, ny);
  // overlay the HARP bitmap, if it was found, onto the mask
  //   (valid == Patch_Padding -> no HARP bitmap)
  if (patch_map) {
    for (j = 0; j < ny; j++) {
      for (i = 0; i < nx; i++) {
	// compute old bitmap index (i0, j0) from expanded bitmap index (i,j)
	// (keep these lines together for clarity, ignore minor speed penalty)
	// note: xmin,ymin and x0,y0 are 0-based offsets
	i0 = pInfo->xmin + i - pInfo->x0;
	j0 = pInfo->ymin + j - pInfo->y0;
	// ensure (i0, j0) is in the old bitmap
	if (i0 < 0 || i0 >= pInfo->dims[0]) continue;
	if (j0 < 0 || j0 >= pInfo->dims[1]) continue;
	patch_val = patch_map[j0 * (pInfo->dims[0]) + i0];
	// plug in new value only if it is nonzero
	// (the unknown portion caused due to merges is zero)
	if (patch_val != 0)
	  pInfo->image[j*nx+i] = patch_val;
      }
    }
    // done with initial HARP overlay
    free(patch_map);
  }
  // change the patch metadata to reflect the new size
  pInfo->x0 = pInfo->xmin; 
  pInfo->y0 = pInfo->ymin;
  pInfo->dims[0] = nx; 
  pInfo->dims[1] = ny;
  return 0;
}

/* 
 * Create and write out record: one HARP at one T_REC
 *
 * Return codes:
 *   0 = all OK
 *   1 = some trouble, but record was inserted
 *   2 = fatal, could not insert this record
 *
 * As a side effect, also frees pInfo->image (if it is non-NULL)
 */

static
int 
ingest_record(patch_info_t *pInfo, 
	      harp_info_t  *hInfo,
	      trec_info_t  *tRec1,     // this particular T_REC
	      trec_info_t  *tRec,      // all T_REC's, for keys
	      run_info_t   *runInfo,   // run metadata, for keys
	      marp_info_t  *mInfo,     // matching ARs, for keys
	      DRMS_Record_t *magRec, 
	      DRMS_Record_t *maskRec, 
	      char *outQuery)
{
  DRMS_Record_t *outRec = NULL;
  DRMS_Segment_t *outSeg = NULL;
  DRMS_Array_t *outData = NULL;
  DRMS_Link_t *link;
  int datavals, totvals;
  double xDist, yDist;
  int status = 0;  // this routine's error status: 0/1/2
  int rv;          // error code for subroutine we call ("return value")
  int ok, not_ok;  // keyword error count
  int i;
	
  rv = 0; // the generic error code return, not the same as "status"
  outRec = drms_create_record(drms_env, outQuery, DRMS_PERMANENT, &rv);
  if (rv) {
    V_printf(-1, "", "Could not create record for patch bitmap.\n");
    return 2;
  }
  outSeg = drms_segment_lookup(outRec, "bitmap");
  if (!outSeg) {
    V_printf(-1, "", "Could not find bitmap segment in patch.\n");
    drms_close_record(outRec, DRMS_FREE_RECORD);
    return 2;
  }
  // pInfo->image will be freed when the DRMS array is freed, below
  outData = drms_array_create(DRMS_TYPE_CHAR, 2, pInfo->dims, pInfo->image, &rv);
  if (rv) {
    V_printf(-1, "", "Could not create array for patch bitmap segment.\n");
    if (outData) 
      drms_free_array(outData);
    return 2; // fatal
  }
  // link outData into outSeg
  outSeg->axis[0] = outData->axis[0];
  outSeg->axis[1] = outData->axis[1];
  outData->parent_segment = outSeg;
    
  /*
   * Keys
   */
  // prime keys
  not_ok = 0;  // count failed keys
  ok = drms_setkey_int   (outRec, "HARPNUM", pInfo->num);
  if (ok != DRMS_SUCCESS) not_ok++;
  ok = drms_setkey_time  (outRec, "T_REC", tRec1->t);
  if (ok != DRMS_SUCCESS) not_ok++;
  // JSOC information
  ok = drms_setkey_string(outRec, "BLD_VERS", jsoc_version);
  if (ok != DRMS_SUCCESS) not_ok++;
  ok = drms_setkey_time  (outRec, "DATE", CURRENT_SYSTEM_TIME);
  if (ok != DRMS_SUCCESS) not_ok++;
  // code version
  not_ok += set_keys_code_info(outRec);
  // per tracker run keys
  not_ok += set_keys_runinfo(outRec, runInfo);
  // patch summary statistics
  not_ok += set_keys_stats(outRec, magRec, maskRec, pInfo, hInfo, tRec);
  // match summary
  not_ok += set_keys_match(outRec, hInfo, mInfo);
  // other keys
  totvals = (pInfo->dims[0])*(pInfo->dims[1]);
  for (datavals = i = 0; i < totvals; i++) 
    if (pInfo->image[i] != 0) datavals++;  // TODO: not enough info to check if on-disk
  ok = drms_setkey_int(outRec, "TOTVALS",  totvals);
  if (ok != DRMS_SUCCESS) not_ok++;
  ok = drms_setkey_int(outRec, "DATAVALS", datavals);
  if (ok != DRMS_SUCCESS) not_ok++;
  ok = drms_setkey_int(outRec, "MISSVALS", totvals-datavals);
  if (ok != DRMS_SUCCESS) not_ok++;
  if (distance2center(magRec, pInfo->x0, pInfo->y0, &xDist, &yDist) == 0) {
    ok = drms_setkey_float(outRec, "CRVAL1", xDist);
    if (ok != DRMS_SUCCESS) not_ok++;
    ok = drms_setkey_float(outRec, "CRVAL2", yDist);
    if (ok != DRMS_SUCCESS) not_ok++;
  } else {
    V_printf(-1, "", "Could not get mag ephemeris to set up patch WCS\n");
    status = 1; // is a nonfatal error
    not_ok += 2;
  }
  if (not_ok > 0) {
    V_printf(-1, "\t", "Failed to set up %d patch keys: %s\n", not_ok, tRec1->str);
    // commented out to make a simple key insertion failure not notable
    // status = 1; 
  }

  // Links
  rv = drms_setlink_static(outRec, "MDATA", magRec->recnum);
  if (rv) {
    status = 1; // is a nonfatal error
    V_printf(-1, "\t", "MDATA link failed\n");
  }
  rv = drms_setlink_static(outRec, "MASK", maskRec->recnum);
  if (rv) {
    status = 1; // is a nonfatal error
    V_printf(-1, "\t", "MASK link failed\n");
  }
  // Write the segment
  rv = drms_segment_write(outSeg, outData, 0);
  if (rv) {
    V_printf(-1, "", "Failed to write segment for patch.\n");
    drms_free_array(outData);
    return 2;  // fatal
  }
  drms_free_array(outData);  // frees pInfo->image
  drms_close_record(outRec, DRMS_INSERT_RECORD);
  return status;  // OK
}


/*
 * utility: return 1 if tag is invalid, 0 otherwise
 * (allow Faint = -1 here, even though don't expect to read it)
 */
static
int 
tag_is_invalid(int tag)
{
  if ((tag == (int) Patch_Tag_Faint ) ||
      (tag == (int) Patch_Tag_Harder) ||
      (tag == (int) Patch_Tag_Normal) ||
      (tag == (int) Patch_Tag_Merge ))
    return 0;  // valid
  else
    return 1;  // invalid
}

/* 
 * Coordinate-Frame file parser, one line per call
 * return 0 if successful, -1 for EOF, +1 for format error
 */
static
int 
load_frame(FILE *fp, patch_info_t *pInfo, TIME *t)
{
  const int rv_expect = 12; // tied to format string below
  char t_rec[24]; // time
  int tag;        // tag
  int rv;

  pInfo->valid = Patch_Invalid; // set to invalid
  // reading rv_expect items
  rv = fscanf(fp, "%d %23s %d %d %d %d %d %f %f %f %f %f", 
	      &(pInfo->num), 
	      t_rec, // string
	      &tag,
	      &(pInfo->fits_nx), 
	      &(pInfo->fits_ny),
	      &(pInfo->x0), 
	      &(pInfo->y0),
	      &(pInfo->lat0), 
	      &(pInfo->lon0), 
	      &(pInfo->lat1), 
	      &(pInfo->lon1),
	      &(pInfo->omega));
  if (rv == EOF) return -1; // regular EOF
  if (rv != rv_expect) {
    V_printf(-1, "", "Warning: could not read frame line, bad file?\n");
    return 1;
  }
  if (tag_is_invalid(tag)) {
    V_printf(-1, "", "Warning: could not read frame tag (%d), bad value?\n", tag);
    return 1;
  } else {
    pInfo->tag = (patch_tag_t) tag;
  }
  // convert inputs, which were from Matlab and have origin=1 (x0,y0), 
  // to origin=0 in keeping with typical C usage
  pInfo->x0 -= 1;
  pInfo->y0 -= 1;
  // convert the time to a rec number
  *t = sscan_time(t_rec);
  if (time_is_invalid(*t)) {
    V_printf(-1, "", "Warning: could not read frame time (%s), bad file?\n", t_rec);
    return 1;
  }
  if (isnan(pInfo->lat0) || isnan(pInfo->lat1) ||
      isnan(pInfo->lon0) || isnan(pInfo->lon1) || isnan(pInfo->omega)) {
    V_printf(-1, "", "Warning: found a NaN in frame line, bad file?\n");
    return 1;
  }

  // now it's OK
  pInfo->valid = Patch_Normal; // regular patch
  return 0;
}

/* 
 * Stats file parser
 * return 0 if successful, -1 for EOF, +1 for format error
 */
static
int 
load_stats(FILE *fp, float *stats)
{
  int i;
  int rv;
  float x;
	
  for (i = 0; i < RS_num_stats; i++) {
    rv = fscanf(fp, "%f", &x); // EOF, 1, or 0
    if (rv == EOF) return -1; // regular end-of-file
    if (rv != 1) {
      V_printf(-1, "", "Warning: load_stats could not read stat #%d, bad file?\n", i+1);
      return 1; // error
    }
    stats[i] = x;
    // printf("%g ", stats[i]);
  }
  return 0; // OK
}

/*
 * Fits reader
 * returns 0 for success, 1 for error
 */

static
int 
load_fits(char *filename, char **image, int *dims)
{
  char *data = NULL;     // must init to null
  fitsfile *fptr;        // fitsio input file pointer
  int fstatus = 0;       // fitsio status variable: all ok now
  int mem_err = 0;       // no allocation error now
  int bitpix;	         // Data type of fits file
  int naxis;	         // number of axes from fits file
  long datasize;         // number of pixels
  long dims_long[2];     // dimension of image
  long fpixel[2] = {1, 1}; // start reading at image pixel (1,1)
  
  fits_open_file(&fptr, filename, READONLY, &fstatus);
  if (fstatus != 0) goto done;
  fits_get_img_param(fptr, 2, &bitpix, &naxis, dims_long, &fstatus);
  if (fstatus != 0) goto done;
  // sizing
  datasize = dims_long[0] * dims_long[1];
  if ((data = calloc(datasize, sizeof(*data))) == NULL) { 
    mem_err = 1; // allocation error, not a fits error
    goto done;
  }
  // load image array
  fits_read_pix(fptr, TSBYTE, fpixel, datasize, NULL, data, NULL, &fstatus);
  if (fstatus != 0) goto done;
  // note, fstatus = 0
 done:
  fits_close_file(fptr, &fstatus);
  if (fstatus || mem_err) {
    // report the error
    char err_msg[FLEN_STATUS];
    if (mem_err)
      strncpy(err_msg, "failed calloc for image data", sizeof(err_msg));
    else
      fits_get_errstatus(fstatus, err_msg);
    V_printf(-1, "", "Error opening fits file `%s': %s\n", filename, err_msg);
    // free the image if it was allocated (data == NULL is OK)
    free(data);
    // clear outputs
    *image = NULL;
    dims[0] = dims[1] = 0;
  } else {
    // set up outputs
    *image = data;
    dims[0] = dims_long[0]; 
    dims[1] = dims_long[1];
  }
  return (fstatus || mem_err) ? 1 : 0;
}

/*
 * set up code information keywords 
 */
static int
set_keys_code_info(DRMS_Record_t *outRec)
{
  extern char *hmi_mharp_version; // defined globally
  char keystr[80]; // plausible FITS keyword length
  int ok;
  int not_ok = 0;

  // version number (of the present code)
  snprintf(keystr, sizeof(keystr), "%s ver: %s", module_name, hmi_mharp_version);
  ok = drms_setkey_string(outRec, "HRPCODEV", keystr);
  if (ok != DRMS_SUCCESS) not_ok++;
  // url points to descriptive text in wiki
  ok = drms_setkey_string(outRec, 
			  "HRPDOCU", 
			  "http://jsoc.stanford.edu/jsocwiki/HARPDataSeries");
  if (ok != DRMS_SUCCESS) not_ok++;
  return not_ok;
}

/*
 * set_keys_runinfo: set up drms keys using per-tracker-run keys
 * which are stored in runInfo
 */
static
int
set_keys_runinfo(DRMS_Record_t *rec, 
		 run_info_t *runInfo)
{
  const char **keys = tracker_run_info_keys;
  const char *drms_key;
  const char *tracker_key;
  int not_ok, iKey;    // outer loop
  int p, found, ok;    // inner loop

  for (not_ok = iKey = 0; keys[iKey] != NULL; iKey += 2) {
    // map drms_key -> tracker_key
    drms_key    = keys[iKey];
    tracker_key = keys[iKey+1];
    // find a parameter p matching tracker_key
    for (found = p = 0; p < runInfo->n_par; p++) {
      if (strcasecmp(tracker_key, runInfo->par_names[p]) == 0) {
	found = 1;
	ok = drms_setkey_string(rec, drms_key, runInfo->par_vals[p]);
	if (ok != DRMS_SUCCESS) not_ok++;
      }
    }
    if (!found) not_ok++; // could not find a tracker param for the key
  }
  return not_ok;
}

/* 
 * Set HARP keywords for region-matches (NOAA_AR, etc.)
 * returns: number of failed insertions (0 if all OK)
 */
static
int
set_keys_match(DRMS_Record_t *rec, 
	       harp_info_t  *hInfo, 
	       marp_info_t  *mInfo)   // NB: head of *all* marpInfo array
{
  int ok, status;
  int not_ok = 0; // count failed insertions
  const int nMatch = hInfo->n_match;
  int best_match, m;
  char str[20];  // enough for an int in decimal
  char all_match[STR_MAX];

  // number of matching ARs (0 OK)
  ok = drms_setkey_int(rec, "NOAA_NUM", nMatch);
  if (ok != DRMS_SUCCESS) not_ok++;
  // NOAA ID of best matching AR (0 OK)
  if (nMatch == 0)
    best_match = 0; // no match
  else
    best_match = mInfo[hInfo->match[0]].id;
  ok = drms_setkey_int(rec, "NOAA_AR", best_match);
  if (ok != DRMS_SUCCESS) not_ok++;
  // string of all matches (more than one OK)
  *all_match = '\0';
  for (m = 0; m < nMatch; m++) {
    snprintf(str, sizeof(str), "%s%d", (m == 0) ? "" : ",", mInfo[hInfo->match[m]].id);
    strncat(all_match, str, sizeof(all_match));
  }
  ok = drms_setkey_string(rec, "NOAA_ARS", all_match);
  if (ok != DRMS_SUCCESS) not_ok++;
  return not_ok;
}

/* 
 * Set HARP keywords
 *
 * returns: number of failed insertions (0 if all OK)
 */
static
int
set_keys_stats(DRMS_Record_t *rec, 
	       DRMS_Record_t *magRec, 
	       DRMS_Record_t *maskRec, 
	       patch_info_t *pInfo, 
	       harp_info_t  *hInfo, 
	       trec_info_t  *tRec)   // NB: head of *all* trec array
{
  float *stats = pInfo->stats;
  int ok, status;
  int not_ok = 0; // count failed insertions

  status = propagate_keys_harp(magRec, maskRec, rec);
  if (status == -1) {
    // this should never happen
    V_printf(-1, "", "set_keys: propagate_keys failed (null record)\n");
  } else {
    not_ok += status;
  }
  // remainder of WCS
  // x0, y0 are 0-based offsets
  ok = drms_setkey_float(rec, "CRPIX1", pInfo->x0);
  if (ok != DRMS_SUCCESS) not_ok++;
  ok = drms_setkey_float(rec, "CRPIX2", pInfo->y0);
  if (ok != DRMS_SUCCESS) not_ok++;
  // sizes (not part of WCS, but related to CRPIX* above)
  ok = drms_setkey_float(rec, "CRSIZE1", pInfo->dims[0]);
  if (ok != DRMS_SUCCESS) not_ok++;
  ok = drms_setkey_float(rec, "CRSIZE2", pInfo->dims[1]);
  if (ok != DRMS_SUCCESS) not_ok++;
  // harp-extent metadata
  ok = drms_setkey_time(rec, "T_FRST",  tRec[hInfo->rec0p].t);
  if (ok != DRMS_SUCCESS) not_ok++;
  ok = drms_setkey_time(rec, "T_FRST1", tRec[hInfo->rec0 ].t);
  if (ok != DRMS_SUCCESS) not_ok++;
  ok = drms_setkey_time(rec, "T_LAST1", tRec[hInfo->rec1 ].t);
  if (ok != DRMS_SUCCESS) not_ok++;
  ok = drms_setkey_time(rec, "T_LAST",  tRec[hInfo->rec1p].t);
  if (ok != DRMS_SUCCESS) not_ok++;
  ok = drms_setkey_int(rec, "N_PATCH",  hInfo->n_patchp);
  if (ok != DRMS_SUCCESS) not_ok++;
  ok = drms_setkey_int(rec, "N_PATCH1", hInfo->n_patch);
  if (ok != DRMS_SUCCESS) not_ok++;
  ok = drms_setkey_int(rec, "N_PATCHM", hInfo->n_missing);
  if (ok != DRMS_SUCCESS) not_ok++;
  // other metadata, from frame file
  // tag, from ROI_s(patch).tag
  ok = drms_setkey_int(rec, "H_MERGE", (pInfo->tag == Patch_Tag_Merge ) ? 1 : 0);
  if (ok != DRMS_SUCCESS) not_ok++;
  ok = drms_setkey_int(rec, "H_FAINT", 
		       ((pInfo->tag == Patch_Tag_Harder) || 
			(pInfo->tag == Patch_Tag_Faint )) ? 1 : 0);
  if (ok != DRMS_SUCCESS) not_ok++;
  // Note, these are for the whole disk transit ("DT")
  ok = drms_setkey_float(rec, "LONDTMIN", pInfo->lon0);
  if (ok != DRMS_SUCCESS) not_ok++;
  ok = drms_setkey_float(rec, "LATDTMIN", pInfo->lat0);
  if (ok != DRMS_SUCCESS) not_ok++;
  ok = drms_setkey_float(rec, "LONDTMAX", pInfo->lon1);
  if (ok != DRMS_SUCCESS) not_ok++;
  ok = drms_setkey_float(rec, "LATDTMAX", pInfo->lat1);
  if (ok != DRMS_SUCCESS) not_ok++;
  ok = drms_setkey_float(rec, "OMEGA_DT",  pInfo->omega);
  if (ok != DRMS_SUCCESS) not_ok++;
  // insert "stats" keywords
  int sn;
  for (sn = 0; sn < RS_num_stats; sn++) {
    char *name1 = (char *) RS_index2keyname[sn];
    //		printf("%s ", name1+1);
    // insert if HMI keyword name is non-null
    if (name1) {
      switch (*name1) {
      case 'i':
	ok = drms_setkey_int(rec, name1+1, (int) stats[sn]);
	break;
      case 'f':
	ok = drms_setkey_float(rec, name1+1, (float) stats[sn]);
	break;
      default:
	// should never happen
	V_printf(-1, "", "set_keys: Unknown key type (first char of keyname %s)\n", name1);
	ok = DRMS_SUCCESS + 1; // i.e., != DRMS_SUCCESS
	break;
      }
      if (ok != DRMS_SUCCESS) not_ok++;
      V_printf(ok != DRMS_SUCCESS, "", "set_keys: failed to set %s -> %f\n", name1, stats[sn]);
    }
  }
  return not_ok;
}


/* 
 * Find bounding box from given lat/lon range 
 *
 * Computes: pInfo->{xmin, xmax, ymin, ymax}
 *
 * return value:
 *   2 if geometry was not found (an error)
 *   1 if all pixels were off-disk (not an error)
 *   0 otherwise
 *
 * Not sure if the caller cares about +1 value, but someone should 
 * handle this case.
 * We handle the case where the hi/lo pixel site is not on the 
 * lat/lon bounding box (e.g., lat1 = -lat0 = 20, lon0 = 45,
 * lon1 = 45+90).
 */
// macro to update local variables
#define UPDATE_RANGE  do { \
                       ondisk = 1; \
                       if (x < xmin) xmin = x; \
                       if (x > xmax) xmax = x; \
                       if (y < ymin) ymin = y; \
                       if (y > ymax) ymax = y; \
                      } while (0)

static
int 
compute_boundary(patch_info_t *pInfo, DRMS_Record_t *rec)
{
  // Scan along the edge, sampling in the lat/lon space
  // with 0.03 degree resolution
  int status;
  int farside, ondisk;
  double xmin, xmax, ymin, ymax;
  double x, y, lat, lon, lat0, lon0, lat1, lon1, dl;		// loop control
	
  // ephemeris
  status = 0;
  float rSun_ref = drms_getkey_float(rec, "RSUN_REF", &status);
  if (status) rSun_ref = 6.96e8;
  status = 0;
  double dSun   = drms_getkey_float(rec, "DSUN_OBS", &status);
  double cdelt  = drms_getkey_float(rec, "CDELT1", &status);  // arcsec, if dx=dy
  double ang_r  = asin(rSun_ref / dSun); // rSun in radians -- about .26 deg
  double rsun   = asin(rSun_ref / dSun) * RAD2ARCSEC / cdelt;
  double crvalx = drms_getkey_float(rec, "CRVAL1", &status);  // disc center, arcsec
  double crvaly = drms_getkey_float(rec, "CRVAL2", &status);
  double crpix1 = drms_getkey_float(rec, "CRPIX1", &status);  // center, ccd, orig.
  double crpix2 = drms_getkey_float(rec, "CRPIX2", &status);
  double crota2 = drms_getkey_float(rec, "CROTA2", &status);
  double sina   = sin(crota2 * RADSINDEG); 
  double cosa   = cos(crota2 * RADSINDEG);
  double xcen   = PIX_X(0.0,0.0) - 1.0;           // Center of disk, starting at 0
  double ycen   = PIX_Y(0.0,0.0) - 1.0;
  double latc   = drms_getkey_float(rec, "CRLT_OBS", &status) * RADSINDEG;
  double lonc   = drms_getkey_float(rec, "CRLN_OBS", &status) * RADSINDEG;
  double peff   = - crota2 * RADSINDEG;
	
  V_printf(verbflag > 2, "\t\t", "cen = (%.2f, %.2f) R=%f. latc=%.2f, lonc=%.2f\n", 
	   xcen, ycen, rsun, latc/RADSINDEG, lonc/RADSINDEG);
  // we require all the geometry
  if (status)
    return 2;
  // check for missing keys
  if (isnan(rsun) || isnan(sina) || isnan(xcen) || isnan(latc))
    return 2;

  // Step 0: The initial lat/lon bounding box in degrees
  lat0 = pInfo->lat0 * RADSINDEG;
  lat1 = pInfo->lat1 * RADSINDEG;
  lon0 = pInfo->lon0 * RADSINDEG + lonc;
  lon1 = pInfo->lon1 * RADSINDEG + lonc;
  dl = 0.03 * RADSINDEG; // lat and lon step size -- a design parameter
  
  // Step 1: Traverse lat/lon BB edges to find pixel BB
  /*  sphere2img synopsis:
   *  Perform a mapping from heliographic coordinates latitude and longitude
   *    (in radians) to plate location on an image of the sun.  The plate
   *    location is in units of the image radius and is given relative to
   *    the image center.  The function returns 1 if the requested point is
   *    on the far side (>90 deg from disc center), 0 otherwise.
   */
  farside = 0; // do any pixels in the lat/lon BB map to the far side?
  // the five variables below are maintained by the UPDATE_RANGE macro
  ondisk = 0;  // do any pixels in the lat/lon BB map to the visible disk?
  xmin = ymin =  HUGE_VAL; // will be reset in the loop
  xmax = ymax = -HUGE_VAL;
  // Scan latitude
  for (lat = lat0; lat <= lat1; lat += dl) {
    if (!sphere2img(lat, lon0, latc, lonc, &x, &y, xcen, ycen,
		    rsun, peff, 0., 0., 0., 0.))
      UPDATE_RANGE; 
    else 
      farside = 1;
    if (!sphere2img(lat, lon1, latc, lonc, &x, &y, xcen, ycen,
		    rsun, peff, 0., 0., 0., 0.))
      UPDATE_RANGE; 
    else 
      farside = 1;
  }
  // Scan longitude
  for (lon = lon0; lon <= lon1; lon += dl) {
    if (!sphere2img(lat0, lon, latc, lonc, &x, &y, xcen, ycen,
		    rsun, peff, 0., 0., 0., 0.))
      UPDATE_RANGE;
    else 
      farside = 1;
    if (!sphere2img(lat1, lon, latc, lonc, &x, &y, xcen, ycen,
		    rsun, peff, 0., 0., 0., 0.))
      UPDATE_RANGE;
    else 
      farside = 1;
  }
  V_printf(verbflag > 2, "\t\t", 
	   "BB: (%.2f, %.2f) X (%.2f, %.2f), %s, %s\n", xmin, xmax, ymin, ymax, 
	   ondisk  ? "some on-disk pixels" : "no visible pixels", 
	   farside ? "some farside pixels" : "no farside pixels");
  // off-disk, skip it
  if (!ondisk)
    return 1; // whole HARP, not just one pixel, was on farside
  // below this if (!ondisk), the BB has been set up OK

  // Step 2: If the box crossed partly to the farside, expand all sides.
  // We may have missed the precise boundary as we traversed the edge.
  if (farside) {
    xmin -= 1.0;
    xmax += 1.0;
    ymin -= 1.0;
    ymax += 1.0;
  }

  // Step 3: Check if the equator/poles were in the lat/lon BB
  // If they were, the pixel BB must be adjusted because the extremum might
  // not be on any edge of the lat/lon BB.
  // int img2sphere (double x, double y, 
  //                 double ang_r, double latc, double lonc, double pa, 
  //                 double *rho, double *lat, double *lon, 
  //                 double *sinlat, double *coslat, 
  //                 double *sig, double *mu, double *chi)
  double rho, sinlat, coslat, sig, mu, chi;  // dummy output arguments
  int rv;
  for (double xpos = -1; xpos <= 1; xpos += 1)
    for (double ypos = -1; ypos <= 1; ypos += 1) {
      if (!(xpos == 0 || ypos == 0)) continue;
      if (xpos == 0 && ypos == 0) continue;
      rv = img2sphere(xpos, ypos, 
		      ang_r, latc, lonc, peff,
		      &rho, &lat, &lon, &sinlat, &coslat, &sig, &mu, &chi);
      if (rv)
	V_printf(verbflag > 3, "\t\t\t", "(%f,%f) not on sphere\n", xpos, ypos);
      else
	V_printf(verbflag > 3, "\t\t\t", 
		 "(x,y) = (% .1f,% .1f) -> (lat,lon) = (% 6.1f,% 6.1f)\n", 
		 xpos, ypos, lat/RADSINDEG, lon/RADSINDEG);
      // Determine whether (lat,lon) is in the lat-lon BB
      while (lon < lon0) lon += 2*M_PI;  /* wrap lon to best fit in [lon0,lon1] */
      while (lon > lon1) lon -= 2*M_PI;
      if (lat0 <= lat && lat <= lat1 && lon0 <= lon && lon <= lon1) {
	// this is rare, so announce it
	V_printf(verbflag > 2, "\t\t", "Note: Extremum found off the box boundary.\n");
	// patch up the pixel BB to include the pixel:
	//  (xpos, ypos) * rsun + (xc,yc)
	x = xcen + rsun*xpos;
	y = ycen + rsun*ypos;
	UPDATE_RANGE;
      }
    }

  // Step 4: Make pixel BB into an integer box and clip to image size
  // clip to legal range {0..Npix - 1}
  V_printf(verbflag > 2, "\t\t", "BB pre : (%g, %g) X (%g, %g)\n", 
	   xmin, xmax, ymin, ymax);
  if (xmin < 0   ) xmin = 0;
  if (xmax >= NPIX_FULLDISK) xmax = NPIX_FULLDISK-1;
  if (ymin < 0   ) ymin = 0;
  if (ymax >= NPIX_FULLDISK) ymax = NPIX_FULLDISK-1;
  V_printf(verbflag > 2, "\t\t", "BB clip: (%g, %g) X (%g, %g)\n", 
	   xmin, xmax, ymin, ymax);
  // integer boundaries
  pInfo->xmin = floor(xmin); 
  pInfo->xmax = ceil(xmax);
  pInfo->ymin = floor(ymin); 
  pInfo->ymax = ceil(ymax);
  V_printf(verbflag > 2, "\t\t", "BB final: (%d, %d) X (%d, %d)\n", 
	   pInfo->xmin, pInfo->xmax, pInfo->ymin, pInfo->ymax);
  
  return 0;
}

// clean namespace
#undef UPDATE_RANGE



/*
 * get distance of points x and y from center to set up WCS
 * Return 0 if successful, 1 if not
 * (Only error condition is missing WCS in "rec" input)
 * x, y start from 0
 */

static
int 
distance2center(DRMS_Record_t *rec, double x, double y, double *xDist, double *yDist)
{
  int status = 0;

  float cdelt  = drms_getkey_float(rec, "CDELT1", &status); // in arcsec, assumimg dx=dy
  float crvalx = drms_getkey_float(rec, "CRVAL1", &status); // center of disc in arcsec
  float crvaly = drms_getkey_float(rec, "CRVAL2", &status);
  float crpix1 = drms_getkey_float(rec, "CRPIX1", &status); // disk center, ccd, original
  float crpix2 = drms_getkey_float(rec, "CRPIX2", &status);
  float crota2 = drms_getkey_float(rec, "CROTA2", &status);
  float sina = sin(crota2 * RADSINDEG); 
  float cosa = cos(crota2 * RADSINDEG);
  float pix_x = x + 1.0;
  float pix_y = y + 1.0;
	
  *xDist = WX(pix_x,pix_y);
  *yDist = WY(pix_x,pix_y);
	
  // printf("%f,%f\n", xDist, yDist);
  if (status != 0 || isnan(sina) || isnan(*xDist))
    return 1;
  else
    return 0;
}
